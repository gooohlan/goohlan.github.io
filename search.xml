<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>构造二叉树</title>
      <link href="uncategorized/55605.html"/>
      <url>uncategorized/55605.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis初探</title>
      <link href="skill/back-end/14555.html"/>
      <url>skill/back-end/14555.html</url>
      
        <content type="html"><![CDATA[<p>带着问题去寻找答案往往会是最好的学习方法，开始探究前，先问几个关于Redis的问题：</p><ul><li>Redis有哪些数据结构，其底层是什么</li><li>Redis持久化机制</li><li>Redis为什么是单进程的？为什么快？</li><li>Redis如何保证的原子性</li><li>Redis过期策略及其淘汰机制</li><li>Redis的瓶颈及解决方案</li></ul><p>由简入难，一个一个的研究，对每个关键点做到知其然并知其所以然</p><h2 id="redis有哪些数据结构-其底层结构是什么">Redis有哪些数据结构，其底层结构是什么</h2><p><code>redis</code>的常见的5种数据结构，分别是<code>string(字符串)</code>、<code>list(列表)</code>、<code>hash(哈希)</code>、<code>set(集合)</code>、<code>sorted set(有序集合)</code>。这些数据结构是暴露给外部接口调用的。</p><p>底层的数据结构有6种：<code>robj</code>、<code>sds(简单动态字符串)</code>、<code>dict(字典)</code>、<code>intset(整数集合)</code>、<code>skiplist(跳跃表)</code>、<code>ziplist(压缩列表)</code>、<code>quicklist(快速列表)</code>。</p><p>关于底层数据结构的很多，这里就不赘述了：</p><ul><li><p><a href="https://blog.csdn.net/a745233700/article/details/113449889">Redis的五种数据结构的底层实现原理(推荐阅读)</a></p></li><li><p><a href="https://www.modb.pro/db/71948">一文理解Redis底层数据结构</a></p></li><li><p><a href="https://juejin.cn/post/6844903936520880135">深入了解Redis底层数据结构</a></p></li></ul><p>对于常用的数据结构已经有了理解，那么不常用的呢？</p><ul><li><p>Streams</p><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。</p><p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></li><li><p>Geospatial</p><p>可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？</p></li><li><p>HyperLogLog</p><p>供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV</p></li><li><p>Bitmaps</p><p>位图是支持按 bit 位来存储信息，可以用来实现 <strong>布隆过滤器（BloomFilter）</strong></p></li><li><p>Bitfields</p><p>将 Redis 字符串视为一个位数组，并且能够处理具有不同位宽和任意非（必要）对齐偏移量的特定整数字段。实际上，使用此命令可以将位偏移量为1234的带符号5位整数设置为特定值，从偏移量4567中检索31位无符号整数。类似地，该命令处理指定整数的递增和递减，提供保证和良好指定的溢出和下溢行为，用户可以配置</p></li></ul><h2 id="redis持久化机制">Redis持久化机制</h2><p>Redis支持两种方式的持久化：</p><ul><li>RDB: 在指定的时间间隔内对你的数据进行快照存储</li><li>AOF：记录每次对服务器写的操作，当服务器重启时会重新执行这些命令来回复原始的数据</li></ul><p>相关定义网上的文章很多，在这里不做多余的赘述，简单说下优缺点</p><h3 id="rdb-vs-aof">RDB vs AOF</h3><h4 id="rdb优点">RDB优点</h4><ul><li>RDB是一个紧凑压缩的二进制文件，代表Redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等场景。</li><li>RDB对灾难恢复、数据迁移非常友好，RDB文件可以转移至任何需要的地方并重新加载。</li><li>RDB是Redis数据的内存快照，数据恢复速度较快，相比于AOF的命令重放有着更高的性能。</li></ul><h4 id="rdb缺点">RDB缺点</h4><ul><li>RDB方式无法做到实时或秒级持久化。因为持久化过程是通过fork子进程后由子进程完成的，子进程的内存只是在fork操作那一时刻父进程的数据快照，而fork操作后父进程持续对外服务，内部数据时刻变更，子进程的数据不再更新，两者始终存在差异，所以无法做到实时性。</li><li>RDB持久化过程中的fork操作，会导致内存占用加倍，而且父进程数据越多，fork过程越长。</li><li>Redis请求高并发可能会频繁命中save规则，导致fork操作及持久化备份的频率不可控；</li><li>RDB文件有文件格式要求，不同版本的Redis会对文件格式进行调整，存在老版本无法兼容新版本的问题。</li></ul><h4 id="aof优点">AOF优点</h4><ul><li>AOF持久化有更好的实时性，我们可以选择三种不同的方式（appendfsync）：no、every second、always，every second作为默认的策略具有最好的性能，极端情况下可能会丢失一秒的数据。</li><li>AOF文件只有append操作，无复杂的seek等文件操作，没有损坏风险。即使最后写入数据被截断，也很容易使用<code>redis-check-aof</code>工具修复；</li><li>当AOF文件变大时，Redis可在后台自动重写。重写过程中旧文件会持续写入，重写完成后新文件将变得更小，并且重写过程中的增量命令也会append到新文件。</li><li>AOF文件以已于理解与解析的方式包含了对Redis中数据的所有操作命令。即使不小心错误的清除了所有数据，只要没有对AOF文件重写，我们就可以通过移除最后一条命令找回所有数据。</li><li>AOF已经支持混合持久化，文件大小可以有效控制，并提高了数据加载时的效率。</li></ul><h4 id="aof缺点">AOF缺点</h4><ul><li>对于相同的数据集合，AOF文件通常会比RDB文件大；</li><li>在特定的fsync策略下，AOF会比RDB略慢。一般来讲，fsync_every_second的性能仍然很高，fsync_no的性能与RDB相当。但是在巨大的写压力下，RDB更能提供最大的低延时保障。</li><li>在AOF上，Redis曾经遇到一些几乎不可能在RDB上遇到的罕见bug。一些特殊的指令（如BRPOPLPUSH）导致重新加载的数据与持久化之前不一致，Redis官方曾经在相同的条件下进行测试，但是无法复现问题。</li></ul><h4 id="aof混合持久">AOF混合持久</h4><p><strong>AOF文件重写的流程是什么？听说Redis支持混合持久化，对AOF文件重写有什么影响？</strong></p><p>从4.0版本开始，Redis在AOF模式中引入了混合持久化方案，即：纯AOF方式、RDB+AOF方式，这一策略由配置参数<code>aof-use-rdb-preamble</code>（使用RDB作为AOF文件的前半段）控制，默认关闭(no)，设置为yes可开启。所以，在AOF重写过程中文件的写入会有两种不同的方式。当<code>aof-use-rdb-preamble</code>的值是：</p><ul><li>no：按照AOF格式写入命令，与4.0前版本无差别；</li><li>yes：先按照RDB格式写入数据状态，然后把重写期间AOF缓冲区的内容以AOF格式写入，文件前半部分为RDB格式，后半部分为AOF格式</li></ul><p>结合源码（6.0版本，源码太多这里不贴出，可参考<code>aof.c</code>）及参考资料，绘制AOF重写（BGREWRITEAOF）流程图：</p><p><img src="https://cdn.inkdp.cn/img/20221007192359.png" alt="E5CAEE8F-32FB-4A33-A09E-39633394A7D5"></p><p>结合上图，总结一下AOF文件重写的流程：</p><ul><li>rewriteAppendOnlyFileBackground开始执行，检查是否有正在进行的AOF重写或RDB持久化子进程：如果有，则退出该流程；如果没有，则继续创建接下来父子进程间数据传输的通信管道。执行fork()操作，成功后父子进程分别执行不同的流程。</li><li>父进程：<ul><li>记录子进程信息（pid）、时间戳等；</li><li>继续响应其他客户端请求；</li><li>收集AOF重写期间的命令，追加至aof_rewrite_buffer；</li><li>等待并向子进程同步aof_rewrite_buffer的内容；</li></ul></li><li>子进程：<ul><li>修改当前进程名称，创建重写所需的临时文件，调用rewriteAppendOnlyFile函数；</li><li>根据<code>aof-use-rdb-preamble</code>配置，以RDB或AOF方式写入前半部分，并同步至硬盘；</li><li>从父进程接收增量AOF命令，以AOF方式写入后半部分，并同步至硬盘；</li><li>重命名AOF文件，子进程退出。</li></ul></li></ul><h3 id="从持久化中恢复数据">从持久化中恢复数据</h3><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：</p><p><img src="https://cdn.inkdp.cn/img/20221007193841.png" alt="image-20221007193840977"></p><p>Redis 4.0版本后AOF支持了混合持久化，加载AOF文件需要考虑版本兼容性，所以回复数据流程发生了变化：</p><p><img src="https://cdn.inkdp.cn/img/20221007203352.png" alt="image-20221007203352211"></p><p>在AOF方式下，开启混合持久化机制生成的文件是“RDB头+AOF尾”，未开启时生成的文件全部为AOF格式。考虑两种文件格式的兼容性，如果Redis发现AOF文件为RDB头，会使用RDB数据加载的方法读取并恢复前半部分；然后再使用AOF方式读取并恢复后半部分。由于AOF格式存储的数据为RESP协议命令，Redis采用伪客户端执行命令的方式来恢复数据。</p><p>如果在AOF命令追加过程中发生宕机，由于延迟写的技术特点，AOF的RESP命令可能不完整（被截断）。遇到这种情况时，Redis会按照配置项<code>aof-load-truncated</code>执行不同的处理策略。这个配置是告诉Redis启动时读取aof文件，如果发现文件被截断（不完整）时该如何处理：</p><ul><li>yes：则尽可能多的加载数据，并以日志的方式通知用户；</li><li>no：则以系统错误的方式崩溃，并禁止启动，需要用户修复文件后再重启。</li></ul><h2 id="redis为什么是单进程的？为什么快？">Redis为什么是单进程的？为什么快？</h2><h3 id="为什么是单进程的">为什么是单进程的</h3><p>官方FAQ：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p><blockquote><p><code>注1</code>：这里我们一直在强调的单线程，只是在<code>处理我们的网络请求</code>的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！ 例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）</p><p><code>注2</code>：从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！以后的版本中是否还是单线程的方式需要考证！</p></blockquote><h4 id="优势与劣势">优势与劣势</h4><p><strong>优势：</strong></p><ul><li>代码更清晰，处理逻辑更简单</li><li>不用考虑各种锁问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ul><p><strong>劣势：</strong></p><ul><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善</li></ul><h3 id="为什么快">为什么快</h3><ul><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>使用多路I/O复用模型，非阻塞IO</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ul><h2 id="redis如何保证的原子性">Redis如何保证的原子性</h2><p>Redis的每个命令都是原子性的，但是这并不代表Redis就不存在原子性问题</p><p><strong>库存问题</strong></p><p>假设现在redis有个叫<code>stock</code>的key，用于存放商品的库存数据，只要进货了库存就加一，出货了库存就减一。于是这时候机智的程序员小王这样设计了一下，每次通过get获取stock的值，然后再set stock=stock+1。在某个时间点有两个业务员A、B同时进货了，此时程序运行流程大概是这样的：</p><p><img src="https://cdn.inkdp.cn/img/20221008081240.png" alt="image-20221008081240945"></p><ul><li><p>A 获取stock的值为100</p></li><li><p>B 获取stock的值为100</p></li><li><p>A 设置stock的值为101</p></li><li><p>B 设置stock的值为101</p></li></ul><p>整个流程下来，我们发现库存丢了一个。整个操作并没有保证原子性，最终丢失了库存</p><h3 id="解决方式">解决方式</h3><h4 id="原生命令">原生命令</h4><p>对于上述的增量操作，使用 <code>incr</code> 和 <code>decr</code> 而非直接<code>set</code>，对于常规 <code>get</code> + <code>set</code> 推荐使用 <code>setnx</code> + <code>expire</code> 的方式，批量设置多个值的场景可以用  <code>mset</code>，批量获取多个值的  <code>mget</code>。从命令和业务上实现原子性，避免非原子性的操作。</p><h3 id="加锁">加锁</h3><p>通过加锁的方式去保证原子性，只有获取到了锁的线程，才能执行对应的业务。获取锁的方式跟方式一一样，通过<code>setnx</code>命令去设置一个固定的代表锁的key，若设置成功，则代表获取锁成功，然后执行上面的<code>get</code>和<code>set</code>操作；操作完成后，再将这个代表锁的key删除掉即可。</p><p>但是这样加锁的话需要有两个风险点：</p><p>（1）客户端在执行了<code>setnx</code>命令获取到锁之后，在后续的业务操作中发生了异常，没有执行删除锁的操作，导致锁一直被占用，其他线程就无法拿到锁。</p><p>**解决方案：**在设置锁的时候，设置一个过期过期时间，到期后自动释放锁。</p><p>（2）客户端A获取到了锁，但是业务操作太久了，导致客户端A获取的锁自动释放掉了，且这时客户端B在锁被释放掉后获取到了锁，开始他的业务操作，此时客户端A的业务执行完了，去执行释放锁的操作，就会把B获取到了锁给释放掉了，导致B的业务没有锁的保证。</p><p>**解决方案：**在设置锁的时候，客户端给自己设置的锁设置一个唯一值，在释放锁的时候，只释放这个唯一值对应的key。</p><h3 id="lua脚本">Lua脚本</h3><p>即使redis支持很多原子命令，但是还是无法满足所有场景，于是redis在2.6之后开始支持开发者编写lua脚本传到redis中，使用lua脚本的好处就是：</p><ul><li>减少网络开销，通过lua脚本可以一次性的将多个请求合并成一个请求。</li><li>原子操作，redis将lua脚本作为一个整体，执行过程中，不会被其他命令打断，不会出现竞态问题。</li><li>复用，客户端发送的lua脚本会永远存在redis服务中。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVAL &quot;redis.call(&#x27;SET&#x27;,KEYS[1],ARGV[1]);redis.call(&#x27;EXPIRE&#x27;,KEYS[1],ARGV[2]);return 1;&quot; 1 name sun 60</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;sun&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure><p>通过<code>eval</code>关键字指明导入<code>lua</code>，在redis收到lua指令时，会把整个lua指令作为一个整体，比如上面的set和expire之间不会有其他客户端请求的指令，一定是set和expire一起做完之后，其他的命令才能执行。</p><h2 id="redis过期策略及其淘汰机制">Redis过期策略及其淘汰机制</h2><h3 id="过期策略">过期策略</h3><p>Redis的过期策略是<strong>定期删除+惰性删除</strong>两种</p><h3 id="定期删除-惰性删除">定期删除+惰性删除</h3><p>定期删除很好理解，每隔一段时间去执行一次删除即可。redis默认<code>100ms</code>就<strong>随机抽取</strong>设置了过期时间的key，检测是否过期，过期了就删除</p><blockquote><p>通过配置文件<code>redis.conf </code>中的<code>hz</code>选项来调整这个次数，<code>hz 10</code>表示每秒执行10次，默认为<code>10</code>，建议不超过100，否则会对CPU造成极大的压力</p></blockquote><p><strong>为啥不扫描全部设置了过期时间的key呢？</strong></p><p>全部扫描，虽然所有的key都得到了及时释放，但是整个过程十分消耗CPU，可能直接就卡死了。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key。</p><p><strong>如果一直没随机到过期key，里面不就存在大量的无效key了吗？</strong></p><p>这个时候，<strong>惰性删除</strong>就派上了用场。惰性嘛，就是懒，我不主动删，当你来主动获取某个key的时候，redis会检查一下，如果已经过期，就直接删了不给你返回。</p><p><strong>那万一定期没删，我也没查询，那不还是有无效key吗？</strong></p><p>办法自然是有的，内存淘汰机制</p><h3 id="内存淘汰机制">内存淘汰机制</h3><p>在配置文件<code>redis.conf</code>中，通过设置<code> maxmemory &lt;bytes&gt;</code> 来设定最大内存，不设置改参数默认是<strong>无限制</strong>的，通常会设定其为物理内存的四分之三。</p><p>我们先看下官网给出的8种内存淘汰策略：</p><ul><li><em>noeviction</em>*：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；</li><li><strong>lkeys-lru</strong>：淘汰整个键值中最久未使用的键值</li><li><strong>llkeys-random</strong>：随机淘汰任意键值</li><li><strong>olatile-lru</strong>：淘汰所有设置了过期时间的键值中最久未使用的键值</li><li><strong>olatile-random</strong>：随机淘汰设置了过期时间的任意键值</li><li><strong>olatile-ttl</strong>：优先淘汰更早过期的键值</li></ul><p>在Redis4.0中新增了两种淘汰机制：</p><ul><li><strong>volatile-lfu</strong>：淘汰所有设置了过期时间的键值中，最少使用的键值；</li><li><strong>allkeys-lfu</strong>：淘汰整个键值中最少使用的键值</li></ul><p>设置Redis淘汰策略的方式有两种：</p><ul><li>通过命令<code>“config set maxmemory-policy 策略</code>可以立即修改策略，但是重启后会失效</li><li>修改配置文件<code>redis.conf</code>中<code>maxmemory-policy</code>的值，必须重启Redis服务才能生效</li></ul><blockquote><p>当现有内存大于<code>maxmemory</code>，就会触发redis通过设置的淘汰策略释放内存，换言之不设置<code>maxmemory</code>无法通过淘汰策略释放空间</p><p>如果没有设置 expire 的key，不满足先决条件(prerequisites)； 那么 volatile-lru，volatile-random， volatile-ttl，volatile-lfu策略的行为，和 noeviction(不删除) 基本上一致</p></blockquote><h3 id="lru与lfu">LRU与LFU</h3><p><strong>LRU</strong> 全称是<code>Least Recently Used</code>译为最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰</p><p><strong>LFU</strong> 全称是<code>Least Frequently Used</code>翻译为最不常用的，最不常用的算法是根据总访问次数来淘汰数据的，它的核心思想是”如果数据过去被访问多次，那么将来被访问的频率也更高”</p><p>具体算法内容在此不做解释</p><h2 id="redis的瓶颈及解决方案">Redis的瓶颈及解决方案</h2><blockquote><p>官方FAQ：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）</p></blockquote><p><strong>网络带宽</strong></p><p>实际生产环境可能会出现Redis客户端与服务端部署在不同机器上的情况，因为网络传输距离的原因，会导致速度变慢，这个时候使用<code>Pipeline</code>可以得到改善</p><h3 id="机器内存">机器内存</h3><p>Redis的存放量与机器内存大小成正比，而且在实际生产环境中不能让Redis直接把内存打满。</p><p>设置<code>maxmemory</code>调整Redis内存大小，一旦到达阙值，Redis会触发淘汰策略清理内存</p><h4 id="pika">PIKA</h4><blockquote><p>pika的定位不是为了取代redis（也做不到，毕竟一个内存，一个磁盘），只是作为一个补充，对在数据量巨大（相对内存而言）的场景下仍想使用redis的人，提供一种选择，所以我们对redis近百个命令进行了实现，虽然用kv接口封装list的做法显得很“蠢”，性能较内存list也不够高（类似pika的一些同类开源项目在这里干脆选择不做list，直接做成array或者queue），但毕竟与redis接口兼容，给合适的用户从redis迁移到pika降低成本</p></blockquote><p><a href="https://github.com/OpenAtomFoundation/pika">pika</a>是360 DBA和基础架构组联合开发的类redis存储系统，使用Redis协议，兼容redis绝大多数命令（String，Hash，List，ZSet，Set），用户不需要修改任何代码, 就可以将服务迁移至pika。因为存储在磁盘，所以速度相对来说要比Redis慢一些，在一些应用场景可以作为<code>Redis</code>的替代。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划框架思路</title>
      <link href="skill/algorithm/50147.html"/>
      <url>skill/algorithm/50147.html</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划的特点与解题思路">动态规划的特点与解题思路</h2><p>动态规划是一个运筹学上的一个最优化算法，所以<strong>动态规划问题一把都是求最值</strong>，比如让你求最长递增子序列，最小编辑距离等。</p><p>这类求最值的问题，他的核心是什么？<strong>其核心一定是穷举</strong>。因为要求最值，所以肯定要把所有的答案穷举出来，在其中找出最值。</p><p>虽然穷举听起来很简单，但是也不能小看他。动态规划问题一般都比较复杂，需要你熟练掌握递归。动态规划的三要素**「重叠子问题」<strong>，</strong>「状态转移方程」<strong>，</strong>「最优子结构」<strong>，其中</strong>「状态转移方程」<strong>最为关键，只有写出正确的</strong>「状态转移方程」<strong>，才可以正确的穷举。</strong>「重叠子问题」<strong>与</strong>「最优子结构」<strong>可以算是特性，我发现这个问题存在</strong>「重叠子问题」<strong>且具备</strong>「最优子结构」<strong>，那么这就是一个动态规划问题。动态规划存在</strong>「重叠子问题」**，在穷举时效率会很低，我们需要使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>这里提供一个思维框架，辅助你思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p><p>按照上面的思路，最后的解法代码就会是如下的框架：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自顶向下递归的动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(状态1， 状态2...)</span> 最值</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> 选择 := <span class="keyword">range</span> 所有可能的选择 &#123;</span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自底向上迭代的动态规划</span></span><br><span class="line"><span class="comment">// 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"><span class="comment">// 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> := <span class="keyword">range</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> := <span class="keyword">range</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>后续通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理，前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程</p><h2 id="509-斐波那契数"><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h2><p><img src="https://cdn.inkdp.cn/img/20220918195946.png" alt="image-20220918195946282"></p><h3 id="1-暴力递归解法">1. 暴力递归解法</h3><p>题目中就直接给出了递归公式，直接套用即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib1(n<span class="number">-1</span>) + fib1(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码简单易懂，但却十分低效，为什么低效，我们假设n=20，画出递归树：</p><p><img src="https://cdn.inkdp.cn/img/20220918201313.png" alt="image-20220918201313942"></p><blockquote><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p></blockquote><p>从上图的递归树种可知，要求出<code>f(20)</code>，我们要先计算出子问题<code>f(18)</code>和<code>f(19)</code>，我们要计算<code>f(19)</code>，我就要先计算出<code>f(18)</code>和<code>f(17)</code>，以此类推，最后遇到<code>f(1)</code>或者<code>f(2)</code>的时候，停止递归。</p><p>上述解法的时间复杂度为<code>o(2^n)</code>，指数级别。</p><blockquote><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间</strong>。</p><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)</p></blockquote><p>重新观察递归树很明显就能发现低效原因：存在大量的重复计算，比如图中的<code>f(18)</code>和<code>f（17)</code>都被计算了两次，而且以<code>f(18)</code>和<code>f(17)</code>为跟的这个递归树体量巨大，多算一遍，就会消耗巨大的时间，而且这个重复还指数级的。</p><p>这就是动态规划问题的第一个性质：<strong>「重叠子问题」</strong>。下面，我们想办法解决这个问题</p><h3 id="2-带备忘录的递归解法">2. 带备忘录的递归解法</h3><p>明确了问题，其实我们就已经把问题解决了一半。居然耗时的原因是因为重复计算，那解决重复计算即可，采用上文提到的「备忘录」来优化即可。首先创造一个<code>备忘录</code>，每次计算完子问题的答案先放入<code>备忘录</code>再返回，每次需要计算一个子问题时，先去<code>备忘录</code>里查一查，存在则不需要重复计算。</p><blockquote><p>一半使用数组和哈希表来充当这个<code>备忘录</code>，他们思路一样。使用数组是需要额外申请一个多余空间，因为数组下标从0开始的</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化备忘录</span></span><br><span class="line">    memo := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> helper(n, memo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(n <span class="keyword">int</span>, memo []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否计算过</span></span><br><span class="line">    <span class="keyword">if</span> memo[n] != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 已经计算过了</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] = helper(n<span class="number">-1</span>, memo) + helper(n<span class="number">-2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次画出递归树</p><p><img src="https://cdn.inkdp.cn/img/20220918205145.png" alt="image-20220918205145334"></p><p>实际上，带「备忘录」的递归算法，就是把一颗巨量赘余的递归树进行修剪，把冗余的部分全部去掉，极大的减少了子问题的个数。</p><p><img src="https://cdn.inkdp.cn/img/20220918210310.png" alt="image-20220918210310089"></p><p>此时算法的时间复杂度为<code>o(n)</code>，相比与上面的，完全不在一个级别。</p><p>此时带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。但是与动态规划还是有区别，因为这种解法是「自顶向下」进行「递归」，常见的动态规划是「自底向上」进行「递推」。</p><p>何为「自顶向下」？观察上面我们画的递归树，是从上向下延伸，都是从一个规模较大的原问题比如<code>f(20)</code>向下逐渐分解规模，到直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个<code>base case</code>，然后逐层返回答案，</p><p>那么「自底向上」呢？反过来，我们从底下、最简单、问题规模最小、已知结果的<code>f(1)</code> 和 <code>f(2)</code> 这两个<code>base case</code>开始往上推，直到推到我们想要的答案 <code>f(20)</code>。这就是「递推」的思路，这也是动态规划一般都脱离了递归，而是由循环迭代完成计算的原因。</p><h3 id="3-使用dp数组的迭代-递推-解法">3. 使用<code>dp</code>数组的迭代(递推)解法</h3><p>根据上一步「备忘录」的启发，我们可以把这个「备忘录」独立成一个表，同城叫做「DP table」，在这张表上完成「自底向上」的「递推」。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 初始化 base case</span></span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220918212701.png" alt="image-20220918212701427"></p><p>通过上图可以发现这个「DP table」特别像上面那个修剪后的递归树，只是顺序反过来了。实际上，带备忘录的递归解法中的「备忘录」，就是动态规划中的「DP table」，这两个解法是差不多的，大部分情况下，效率也基本相同。</p><p>此时我们引出**「状态转移方程」**这个名词，实际上就是描述问题结构的数学形式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(n) = \begin{cases}1,n=1,2\\f(n-1)+f(n-2),n&gt;2\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><code>f(n)</code>的函数参数会不断的变化，所以你把参数<code>n</code>想想要的一个状态，这个状态<code>n</code>是由状态<code>n - 1</code>和<code>n - 2</code>转移（相加）而来，仅此而已。</p><p>上面几种解法中的所有操作，例如<code>return fib(n-1) + fib(n-2)</code>，<code>dp[i] = dp[i-1] + dp[i-2]</code>，以及对「备忘录」或「DP table」的初始化操作，都是威少这个方程式的不同表现形态，有此可见列出「状态转移方程」的重要性，它是解决问题的核心，而且很容易发现，其实状态转移方程直接代表着暴力解法。</p><p>千万不要看不起暴力解法，动态规划问题最困难的就是写出这个暴力解，即状态转移方程。只要写出暴力解，优化方案无非是备忘录或DP table。</p><h3 id="4-细节优化">4. 细节优化</h3><p>根据菲波那切数列的状态转移方程，当前状态只和之前两个状态有关，那么我们就不需要那么长一个DP table来存储所有的状态，只需存储前两个状态即可，根据此思路，进一步优化，把空间复杂度降为<code>0(1)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib4</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    prev, curr := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="comment">//dp[i-1], dp[i] = dp[i], dp[i-1] + dp[i-2]</span></span><br><span class="line">        prev, curr = curr, prev+curr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一般是动态规划问题的最后一步优化，如果我们发现状态转移只需要DP table中的一部分，那么可以尝试缩小DP table的大小，只记录必要的数据，降低空间复杂度。上述例子就相当于把DP table的大小从<code>n</code>降到了<code>2</code>。</p><p>此题并没有涉及动态规划的另一个重要特性「最优子结构」，因为菲波那切数列严格莱索不算动态规划，因为没有涉及到求最值，上文旨在说明重叠子问题的消除方法，演示的到最优解法的逐步优化过程。</p><h2 id="322-零钱兑换"><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><p><img src="https://cdn.inkdp.cn/img/20220918222935.png" alt="image-20220918222935849"></p><h3 id="1-暴力递归">1. 暴力递归</h3><p>首先这个问题是动态规划问题，因为它具有「最优子结构」。要符合**「最优子结构」**，子问题必须互相独立。什么是相互独立？我们用一个简单且直观的例子来说明。</p><blockquote><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。</p><p>这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。</p></blockquote><p>回答凑零钱问题，为什么说它符合最优子结构呢？假设你有面值为<code>1,2,5</code>的硬币，你想求<code>amount = 11</code> 时的最少硬币数，如果你知道凑出<code>amount = 10, 9, 6</code>的最少硬币数（子问题），你只需要把子问题的答案<code>+1</code>（再选一枚面值为<code>1, 2, 5</code>的硬币），求个最小值，就是原问题的答案，因为硬币数量没有限制，所以子问题没有相互限制，是互相独立的。</p><p>那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？</p><blockquote><p><strong>1、确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p><strong>2、确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p><strong>3、确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p><strong>4、明确 <code>dp</code> 函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。</p></blockquote><p><strong>所以我们可以这样定义 <code>dp</code> 函数：<code>dp(n)</code> 表示，输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 所需的最少硬币数量</strong>。</p><p>根据定义写成代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dp(coins, amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要凑出金额 n，至少要 dp(coins, n) 个硬币</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> amount &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := math.MaxInt</span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        <span class="comment">// 计算子问题的结果</span></span><br><span class="line">        number := dp(coins, amount-coin)</span><br><span class="line">        <span class="comment">// 子问题无解则跳过</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在子问题中选择最优解，然后加一</span></span><br><span class="line">        <span class="keyword">if</span> res &gt; number &#123;</span><br><span class="line">            res = number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> res == math.MaxInt &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：这里<code>coinChange</code>和<code>dp</code>函数签名完全一样，为了后文方便讲解，额外写一个<code>dp</code>函数来实现主逻辑</p></blockquote><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">{</mo><mi>d</mi><mi>p</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo>∈</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>s</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp(n) = \begin{cases}0,n=0\\-1,n&lt;0\\\min\lbrace dp(n - coin) + 1 | coin \in coins\rbrace, n &gt; 0\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">min</span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = &#123;1,2,5&#125;</code> 时画出递归树看看：</p><p><img src="https://cdn.inkdp.cn/img/20220918230530.png" alt="image-20220918230530146"></p><p><strong>递归算法的时间复杂度分析：子问题总数 x 解决每个子问题所需的时间</strong></p><blockquote><p>假设目标金额为 <code>n</code>，给定的硬币个数为 <code>k</code>，那么递归树最坏情况下高度为 <code>n</code>（全用面额为 1 的硬币），然后再假设这是一棵满 <code>k</code> 叉树，则节点的总数在 <code>k^n</code> 这个数量级。</p><p>接下来看每个子问题的复杂度，由于每次递归包含一个 for 循环，复杂度为 <code>O(k)</code>，相乘得到总时间复杂度为 <code>O(k^n)</code>，指数级别。</p></blockquote><h3 id="2-带备忘录的递归">2.带备忘录的递归</h3><p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange1</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    memo = <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> memo &#123;</span><br><span class="line">        <span class="comment">// 备忘录初始化为一个不会被取到的特殊值，代表还未被计算</span></span><br><span class="line">        memo[i] = <span class="number">-2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp1(coins, amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dp1</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> amount &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查备忘录，防止重复计算</span></span><br><span class="line">    <span class="keyword">if</span> memo[amount] != <span class="number">-2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[amount]</span><br><span class="line">    &#125;</span><br><span class="line">    res := math.MaxInt</span><br><span class="line">    <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        <span class="comment">// 计算子问题的结果</span></span><br><span class="line">        number := dp1(coins, amount-coin)</span><br><span class="line">        <span class="comment">// 子问题无解则跳过</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在子问题中选择最优解，然后加一</span></span><br><span class="line">        <span class="keyword">if</span> res &gt; number &#123;</span><br><span class="line">            res = number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把计算结果存入备忘录</span></span><br><span class="line">    <span class="keyword">if</span> res == math.MaxInt &#123;</span><br><span class="line">        memo[amount] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memo[amount] = res + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用「备忘录」大大减小了子问题数目，完全消除了子问题的赘余，所以子问题的总数不会超过金额数<code>n</code>，即子问题数目为<code>O(n)</code>。处理一个子问题的时间不变，仍是 <code>O(k)</code>，所以总的时间复杂度是 <code>O(kn)</code>。</p><h3 id="3-dp-数组的迭代解法">3. dp 数组的迭代解法</h3><p>同样，我们可以自底向上使用「DP table」来消除重叠子问题，关于「状态」「选择」和「base case」与之前没有什么区别，<code>dp数组</code>的定义和刚才的<code>dp函数</code>类似，也是把「状态（金额）」作为变量，不过<code>dp函数</code>体现在函数参数，<code>dp数组</code>体现在数组索引：</p><p><strong><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出</strong></p><p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange2</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = amount + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> i-coin &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// dp[i-coin] == dp(coins, amount-coin)</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; dp[i-coin] &#123;</span><br><span class="line">                dp[i] = dp[i-coin] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dp[amount] == amount+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220918235221.jpg" alt="img"></p><blockquote><p>PS：<code>dp</code>数组初始化为<code>amount + 1</code>与上述递归解法中<code>memo[i] = -2</code>和暴力解法中的<code>res := math.MaxInt</code>意义一样</p></blockquote><h2 id="总结">总结</h2><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p>看到这里，相信你已经掌握了这个算法的设计技巧。</p><p>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两种思路手撕二叉树</title>
      <link href="skill/algorithm/14521.html"/>
      <url>skill/algorithm/14521.html</url>
      
        <content type="html"><![CDATA[<p>先在开头总结一下，二叉树解题的思维模式分两类：</p><blockquote><p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p><p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p><p>无论使用哪种思维模式，你都需要思考：</p><p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p></blockquote><p>下文通过几道简单的题目，实践运用这几条总纲，理解「遍历」和「分解问题」的思维又和区别和联系</p><p>二叉树相关的题目，无非是在二叉树遍历时的前序/中序/后续位置做文章，当然这并不能包含所有的，但是大部分如此，万变不离其宗，因此我们可以定义出一个基础框架：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    traverse(root.Left)</span><br><span class="line">    <span class="comment">// 中序位置</span></span><br><span class="line">    traverse(root.Right)</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不管所以为的前中后序，单看<code>traverse</code>，他在做的无非就是把整个二叉树所有节点遍历一遍，本质上与你遍历数组和链表类似。</p><h2 id="144-二叉树的前序遍历"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><p><img src="https://cdn.inkdp.cn/img/20220915081346.png" alt="image-20220915081346242"></p><div class="tabs" id="104"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#104-1">遍历</button></li><li class="tab"><button type="button" data-href="#104-2">分解问题</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="104-1"><p><strong>解题思路：</strong></p><div class="note no-icon info simple"><p>经典二叉树前序遍历，二叉树入门级题目，套入上文的框架，前序遍历则在前序位置将节点放入数组即可</p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   preorder(root)</span><br><span class="line">   <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorder</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   list = <span class="built_in">append</span>(list, node.Val)</span><br><span class="line">   preorder(node.Left)</span><br><span class="line">   preorder(node.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用了<code>全局变量</code>，在<code>leetcode</code>提交时会有问题，稍微改造一下即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">   preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      list = <span class="built_in">append</span>(list, node.Val)</span><br><span class="line">      preorder(node.Left)</span><br><span class="line">      preorder(node.Right)</span><br><span class="line">   &#125;</span><br><span class="line">   preorder(root)</span><br><span class="line">   <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="104-2"><p><strong>解题思路：</strong></p><div class="note info no-icon simple"><p>二叉树的前序遍历，是先拿出根节点，再拿到左子树的节点，再拿到右子树的节点，将他们三个合并到一起，就是一颗二叉树的前序遍历。我们把一整颗二叉树的遍历分解成一个又一个小数的遍历，最后合并到一起，这就是分解的思路</p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">   <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 分解</span></span><br><span class="line">   left := preorderTraversal(root.Left)</span><br><span class="line">   right := preorderTraversal(root.Right)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并</span></span><br><span class="line">   res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">   res = <span class="built_in">append</span>(res, left...)</span><br><span class="line">   res = <span class="built_in">append</span>(res, right...)</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="145-二叉树的后序遍历"><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2><p><img src="https://cdn.inkdp.cn/img/20220915224054.png" alt="image-20220915224053997"></p><p><strong>解题思路：</strong></p><div class="note info no-icon simple"><p>两种思路与上一题都一致，唯一不同时根据顺序调整插入当前节点的位置</p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> list []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">preorder(node.Left)</span><br><span class="line">preorder(node.Right)</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Val)</span><br><span class="line">&#125;</span><br><span class="line">preorder(root)</span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal2</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解</span></span><br><span class="line">left := postorderTraversal2(root.Left)</span><br><span class="line">right := postorderTraversal2(root.Right)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line">res = <span class="built_in">append</span>(res, left...)</span><br><span class="line">res = <span class="built_in">append</span>(res, right...)</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><img src="https://cdn.inkdp.cn/img/20220915225409.png" alt="image-20220915225409195" style="zoom:50%;" /><div class="tabs" id="104"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#104-1">遍历</button></li><li class="tab"><button type="button" data-href="#104-2">分解问题</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="104-1"><p><strong>解题思路：</strong></p><div class="note no-icon info simple"><p>定义两个全局变量<code>res</code>和<code>depth</code>，<code>res</code>负责记录最大深度，<code>depth</code>像一个游标，跟着递归遍历到每一个节点记录其深度，向下遍历时<code>depth++</code>，返回时<code>depth--</code></p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">unc maxDepth(root *TreeNode) <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> traverse <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    <span class="keyword">var</span> depth <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    traverse = <span class="function"><span class="keyword">func</span> <span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    depth++</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 到达叶子节点,更新最大深度</span></span><br><span class="line">    <span class="keyword">if</span> depth &gt; result &#123;</span><br><span class="line">    result = depth</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.Left)</span><br><span class="line">    traverse(root.Right)</span><br><span class="line">    <span class="comment">// 后序位置</span></span><br><span class="line">    depth--</span><br><span class="line">    &#125;</span><br><span class="line">traverse(root)</span><br><span class="line"><span class="keyword">return</span>  result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="104-2"><p><strong>解题思路：</strong></p><div class="note no-icon info simple"><p>一个二叉树的最大深度可以通过子树的最大深度推倒出来，所以我们只需要求出一个子树的最大深度即可</p><p>一个树的最大深度就是左子树或是右子树深度中最大值，在加上自身就是这颗树的最大深度</p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 计算左右子树的最大深度</span></span><br><span class="line">   leftMax := maxDepth(root.Left)</span><br><span class="line">   rightMax := maxDepth(root.Right)</span><br><span class="line">    <span class="comment">// 整棵树的最大深度等于左右子树深度的最大值，在加上自己</span></span><br><span class="line">   <span class="keyword">if</span> leftMax &lt; rightMax &#123;</span><br><span class="line">      <span class="keyword">return</span> rightMax + <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> leftMax + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2><p><img src="https://cdn.inkdp.cn/img/20220915231158.png" alt="image-20220915231157978"></p><p><strong>解题思路：</strong></p><div class="note no-icon info simple"><p>此题中二叉树的左右节点连接很简单，比如示例中的<code>2 -&gt; 3</code>，<code>4 -&gt; 5</code>，<code>6 -&gt; 7</code>，比较难得是左右节点子节点之间的连接，比如<code>5 -&gt; 6</code>的连接，采用分解问题的思路：</p><p>我们把两个二叉树中两个节点抽象成一个节点，这样一颗二叉树就变成了「三叉树」，然后我们遍历这颗「三叉树」，把每个「三叉树节点」中的连个节点链接就可以了，下图中的每个方块看做是一个节点</p><p><img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/3.png" alt="img"></p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">(root *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">   connectTraverse(root.Left, root.Right)</span><br><span class="line">   <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三叉树遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectTraverse</span><span class="params">(leftNode *Node, rightNode *Node)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> leftNode == <span class="literal">nil</span> || rightNode == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 首先连接自身</span></span><br><span class="line">   leftNode.Next = rightNode</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">   connectTraverse(leftNode.Left, leftNode.Right)</span><br><span class="line">   connectTraverse(rightNode.Left, rightNode.Right)</span><br><span class="line">   <span class="comment">// 连接相邻节点的子节点</span></span><br><span class="line">   connectTraverse(leftNode.Right, rightNode.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考：上述函数还有优化空间吗？</p><p>有，在连接相同父节点的两个子节点时，左子树的右节点，和右子树的左节点已经完成了其子节点的连接，在连接相邻节点的时候会重复，即<code>leftNode.Right.Left -&gt; leftNode.Right.Right</code>和<code>rightNode.Left.Left -&gt; rightNode.Left.Right</code>，可以小优化一下，但不优化也问题不大</p></blockquote><h2 id="226-翻转二叉树"><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><p><img src="https://cdn.inkdp.cn/img/20220915234911.png" alt="image-20220915234910970"></p><div class="tabs" id="226"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#226-1">遍历</button></li><li class="tab"><button type="button" data-href="#226-2">分解问题</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="226-1"><p><strong>解题思路：</strong></p><div class="note no-icon info simple"><p>遍历每一个节点，交换每个节点的子节点</p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line">root.Left, root.Right = root.Right, root.Left</span><br><span class="line">invertTree1(root.Left)</span><br><span class="line">invertTree1(root.Right)</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="226-2"><p><strong>解题思路：</strong></p><div class="note no-icon info simple"><p>将树分解成N个树，每棵树先翻转自己的左右子树，然后交换左右子节点，放回翻转完的树，将他们组合起来就可以了。</p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line">left := invertTree(root.Left)</span><br><span class="line">right := invertTree(root.Right)</span><br><span class="line"></span><br><span class="line">root.Left = right</span><br><span class="line">root.Right = left</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="543-二叉树的直径"><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><p><img src="https://cdn.inkdp.cn/img/20220916001541.png" alt="image-20220916001541457"></p><p><strong>解题思路：</strong></p><div class="note no-icon info simple"><p>此题关键在于<strong>每一条二叉树的「直径」，就是一个节点的左右子树的最大深度之和</strong></p><p>使用分解的思路，分别计算出每个节点的左右最大深度，相加之后加上自身返回给上级，组合起来就求出了每个节点的最大直径，取其中最大的一个即可</p></div><p><strong>示例代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDiameter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameterOfBinaryTree</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> diameter(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diameter</span><span class="params">(node *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">leftDiameter := diameter(node.Left)</span><br><span class="line">rightDiameter := diameter(node.Right)</span><br><span class="line"></span><br><span class="line">diameter := leftDiameter + rightDiameter</span><br><span class="line">maxDiameter = max(maxDiameter, diameter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> leftDiameter &gt; rightDiameter &#123;</span><br><span class="line"><span class="keyword">return</span> leftDiameter + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max(leftDiameter, rightDiameter) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考链接：</strong></p><ul><li><a href="https://labuladong.github.io/algo/1/6/">东哥带你刷二叉树（纲领篇）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针技巧秒杀数组</title>
      <link href="skill/algorithm/17874.html"/>
      <url>skill/algorithm/17874.html</url>
      
        <content type="html"><![CDATA[<h3 id="26-删除有序数组中的重复项"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h3><p><img src="https://cdn.inkdp.cn/img/20220913081623.png" alt="image-20220913081623626"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>因为数组是有序的，所以直接往后遍历即可</p><p>定义快慢指针，快指针<code>fast</code>在前方探路，<code>slow</code>跟着后面，当<code>fast</code>发现一个新元素时，<code>slow</code>前进一步并赋值</p><p>当<code>fast</code>走到末尾时，<code>nums[:slow]</code>就是一个完全去重的数组</p><img src="https://cdn.inkdp.cn/img/20220913082037.gif" alt="1" style="zoom:50%;" /></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    slow := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; <span class="built_in">len</span>(nums); fast++ &#123;</span><br><span class="line">      <span class="keyword">if</span> nums[slow] != nums[fast] &#123;</span><br><span class="line">         slow++</span><br><span class="line">         nums[slow] = nums[fast]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-移除元素"><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h3><p><img src="https://cdn.inkdp.cn/img/20220913082134.png" alt="image-20220913082134931"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>思路与前一题类似，依旧是定义快慢指针，不同的地方在于，前一题是<code>fast</code>遇到不同的元素，则<code>slow</code>前进并赋值，此题是<code>fast</code>遇到值不为<code>val</code>元素时，<code>slow</code><mark class="hl-label red">赋值并前进</mark></p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   slow := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; <span class="built_in">len</span>(nums); fast++ &#123;</span><br><span class="line">      <span class="keyword">if</span> nums[fast] != val &#123;</span><br><span class="line">         nums[slow] = nums[fast]</span><br><span class="line">         slow++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 因为先复制后前进,所以返回值不+1</span></span><br><span class="line">   <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="283-移动零"><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h3><p><img src="https://cdn.inkdp.cn/img/20220913082948.png" alt="image-20220913082948040"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>快指针<code>fast</code>向前遍历，遇到非<code>0</code>值就与慢指针<code>slow</code>所在值进行交换，<code>fast</code>遍历结束，所有的<code>0</code>都处于数组后半段</p><p>此题与26和27的思路类似，可以看做是27题的移除元素0的升级版，把移除变成了交换位置</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">slow := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> fast := <span class="number">0</span>; fast &lt; <span class="built_in">len</span>(nums); fast++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[fast] != <span class="number">0</span> &#123;</span><br><span class="line">nums[fast], nums[slow] = nums[slow], nums[fast]</span><br><span class="line">slow++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="167-两数之和-ii-输入有序数组"><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h3><p><img src="https://cdn.inkdp.cn/img/20220913083308.png" alt="image-20220913083308448"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>根据题意，数组是有序的，定义左右指针<code>left</code>和<code>right</code>分别指向数组头和尾，通过调节<code>left</code>和<code>right</code>来调整和的大小与<code>target</code>进行对比，即：</p><p>比<code>target</code>大时，<code>right--</code>，和变小<br>比<code>target</code>小时，<code>left++</code>，和变大</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(numbers)<span class="number">-1</span>; i &lt; j; &#123;</span><br><span class="line"><span class="keyword">if</span> numbers[i]+numbers[j] &lt; target &#123;</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> numbers[i]+numbers[j] &gt; target &#123;</span><br><span class="line">j--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="344-反转字符串"><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p><img src="https://cdn.inkdp.cn/img/20220913083804.png" alt="image-20220913083804229"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>定义左右指针，相向而行，交换值</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">s[i], s[j] = s[j], s[i]</span><br><span class="line">i++</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最长回文子串"><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p><img src="https://cdn.inkdp.cn/img/20220913083951.png" alt="image-20220913083951766"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>采用中心拓展的方式可以判断出一个字符串是否为回文串</p><p>回文串根据长度区分，可分为奇数与偶数两种，如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符</p><p>之后我们遍历输入的字符串，求每(两)个字符串的回文串，最终返回最长的那一个即可满足条件</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心拓展获取回文串，当i与j相同时则取出的是奇数回文串，i与j相邻时取出的是偶数回文串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPalindrome</span><span class="params">(s <span class="keyword">string</span>, i, j <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="built_in">len</span>(s) &amp;&amp; s[i] == s[j] &#123;</span><br><span class="line">i--</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s[i+<span class="number">1</span> : j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">res := getPalindrome(s, i, i)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="built_in">len</span>(str) &#123;</span><br><span class="line">str = res</span><br><span class="line">&#125;</span><br><span class="line">res = getPalindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="built_in">len</span>(str) &#123;</span><br><span class="line">str = res</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接：">参考链接：</h3><ul><li><a href="https://labuladong.github.io/algo/1/5/">双指针技巧秒杀七道数组题目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针技巧秒杀链表</title>
      <link href="skill/algorithm/13378.html"/>
      <url>skill/algorithm/13378.html</url>
      
        <content type="html"><![CDATA[<h3 id="21-合并两个有序链表"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><p><img src="https://cdn.inkdp.cn/img/20220905235445.png" alt="image-20220905235445328"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>同时循环两个链表，去除较小的一个只放入新链表，直到其中一个节点为<code>nil</code></p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别取出两个链表的当前值比较,较小的赋值给新链表</span></span><br><span class="line"><span class="comment">// 初始化时需要声明一个虚拟节点,避免空指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   head := &amp;ListNode&#123;&#125;</span><br><span class="line">   pre := head</span><br><span class="line">   <span class="keyword">for</span> list1 != <span class="literal">nil</span> &amp;&amp; list2 != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 比较两个节点的值, 将较小的节点放到pre指针</span></span><br><span class="line">      <span class="keyword">if</span> list1.Val &lt; list2.Val &#123;</span><br><span class="line">         pre.Next = list1</span><br><span class="line">         list1 = list1.Next</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         pre.Next = list2</span><br><span class="line">         list2 = list2.Next</span><br><span class="line">      &#125;</span><br><span class="line">      pre = pre.Next</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> list1 != <span class="literal">nil</span> &#123;</span><br><span class="line">      pre.Next = list1</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> list2 != <span class="literal">nil</span> &#123;</span><br><span class="line">      pre.Next = list2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-合并k个升序链表"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h3><p><img src="https://cdn.inkdp.cn/img/20220907222209.png" alt="image-20220907222209208"></p><div class="tabs" id="23"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#23-1">分治法</button></li><li class="tab"><button type="button" data-href="#23-2">最小堆</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="23-1"><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>简单粗暴，从第一个往后一依次合并</p><p>**进阶：**使用递归合并</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists1</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   pre := &amp;ListNode&#123;&#125;</span><br><span class="line">   cur := &amp;ListNode&#123;&#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   pre = lists[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(lists); i++ &#123;</span><br><span class="line">      cur = lists[i]</span><br><span class="line">      pre = mergeTwoLists(pre, cur) <span class="comment">// 21题函数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23-2"><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>此题关键难点在于，如何快速从<code>K</code>个链表中找出最小节点</p><p>这里我们使用<a href="https://labuladong.github.io/algo/2/23/65/">优先级队列（二叉堆）</a> 这种数据结构，构建一个<a href="https://www.cnblogs.com/ganshuoos/p/14199368.html">最小堆</a>，把所有链表节点放入其中，然后每次取出最小节点加入新链表即可。</p><p>注意：取出节点后需要将下一个节点放入最小堆中</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用最小堆存储所有链表头结点节点</span></span><br><span class="line"><span class="comment">// 遍历最小堆,取出最小节点添加到新链表,同时将取出节点下一个节点放入最小堆中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   h := <span class="built_in">new</span>(minHeap)</span><br><span class="line">   <span class="comment">// 将所有链表的头结点放入最小堆</span></span><br><span class="line">   <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">      <span class="keyword">if</span> list != <span class="literal">nil</span> &#123;</span><br><span class="line">         heap.Push(h, list)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   head := &amp;ListNode&#123;&#125;</span><br><span class="line">   pre := head</span><br><span class="line">   <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 取出最小节点</span></span><br><span class="line">      node := heap.Pop(h).(*ListNode)</span><br><span class="line">      <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 将最小节点下一节点加入最小堆</span></span><br><span class="line">         heap.Push(h, node.Next)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 最小节点放入链表</span></span><br><span class="line">      pre.Next = node</span><br><span class="line">      pre = pre.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="86-分隔链表"><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h3><p><img src="https://cdn.inkdp.cn/img/20220906221020.png" alt="image-20220906221020843"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>遍历原链表，根据需求把链表分成两个小链表，一个链表所有元素小于<code>x</code>，另一个链表所有元素大于等于<code>x</code>，最后把两个链表连接到一起就可以了。</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(head *ListNode, x <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   head1 := &amp;ListNode&#123;&#125; <span class="comment">// 存放小于x的链表</span></span><br><span class="line">   head2 := &amp;ListNode&#123;&#125; <span class="comment">// 存放大于等于x的链表</span></span><br><span class="line">   p1, p2 := head1, head2</span><br><span class="line">   <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> head.Val &lt; x &#123;</span><br><span class="line">         p1.Next = head</span><br><span class="line">         p1 = p1.Next</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         p2.Next = head</span><br><span class="line">         p2 = p2.Next</span><br><span class="line">      &#125;</span><br><span class="line">      head = head.Next</span><br><span class="line">   &#125;</span><br><span class="line">   p2.Next = <span class="literal">nil</span></span><br><span class="line">   <span class="comment">// 连接两个链表</span></span><br><span class="line">   p1.Next = head2.Next</span><br><span class="line">   <span class="keyword">return</span> head1.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-n-个结点"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p><img src="https://cdn.inkdp.cn/img/20220908225311.png" alt="image-20220908225311074"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>假设链表有<code>n</code>个节点,那么倒数第<code>k</code>个节点,就是正数第<code>n-k+1</code>个节点</p><p>遍历一次链表,获取链表长度<code>n</code>,再重新遍历一次找到第<code>n-k+1</code>个节点即可</p><p>能不能遍历一次就搞定呢</p><p>首先我们定义一个指针<code>p1</code>,<code>p1</code>先走<code>k</code>步,那么他还需要走<code>n-k</code>步即可到达尾部</p><p>此时我们再申明一个指针<code>p2</code>,指向头部, <code>p1</code>和<code>p2</code>同时前进,当<code>p1</code>到达尾部时,<code>p1</code>正好走了<code>n-k</code>步,在<code>n-k+1</code>个节点上,就是倒数第k个节点</p><p>为了方便删除操作,申明<code>p2</code>时申明一个前置节点,按照上述步骤,<code>p1</code>到达末尾, <code>p2</code>到达倒数第<code>n</code>个节点的前置节点, 直接删除<code>p2</code>下一个节点即可</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   p := &amp;ListNode&#123;<span class="number">0</span>, head&#125;</span><br><span class="line">   p1, p2 := head, p</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      p1 = p1.Next</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">      p1 = p1.Next</span><br><span class="line">      p2 = p2.Next</span><br><span class="line">   &#125;</span><br><span class="line">   p2.Next = p2.Next.Next</span><br><span class="line">   <span class="keyword">return</span> p.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="876-链表的中间结点"><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h3><p><img src="https://cdn.inkdp.cn/img/20220911214530.png" alt="image-20220909221844640"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>要找到中间节点,常规的办法是遍历一遍,拿到链表的长度,再遍历一次得到n/2个节点,也就是中间节点</p><p>使用快慢指针的方式,申明两个指针,每当慢指针前进一步,快指针就前进两步,这当看指针走到链表末尾,慢指针刚好到链表的中间节点</p><p>当链表长度为偶数时,快指针走到指针末尾,而慢指针刚好走到两个中间节点靠后的那个节点,符合题意</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   slow, fast := head, head</span><br><span class="line">   <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">      slow = slow.Next</span><br><span class="line">      fast = fast.Next.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p><img src="https://cdn.inkdp.cn/img/20220911214752.png" alt="image-20220911214752291"></p><div class="tabs" id="160"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#160-1">双指针-同尾法</button></li><li class="tab"><button type="button" data-href="#160-2">双指针-链表相连</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="160-1"><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>需要判断两个链表是否有交点,其核心在于两个链表同时到达相交点<code>c1</code></p><p>先让两个指针同时走到距离尾部相同的距离</p><p>然后依次往后遍历, 如果<code>p1</code>与<code>p2</code>相等,他们就走到了相交的节点,否则会走到链表尾部</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> lenA, lenB <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> p := headA; p != <span class="literal">nil</span>; p = p.Next &#123;</span><br><span class="line">      lenA++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> p := headB; p != <span class="literal">nil</span>; p = p.Next &#123;</span><br><span class="line">      lenB++</span><br><span class="line">   &#125;</span><br><span class="line">   p1, p2 := headA, headB</span><br><span class="line">   <span class="keyword">if</span> lenA &gt; lenB &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenA-lenB; i++ &#123;</span><br><span class="line">         p1 = p1.Next</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; lenB-lenA; i++ &#123;</span><br><span class="line">         p2 = p2.Next</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注意题意,提供的两个链表中存在相同链表,所以直接判断两个链表相等即可</span></span><br><span class="line">   <span class="keyword">for</span> p1 != p2 &#123;</span><br><span class="line">      p1 = p1.Next</span><br><span class="line">      p2 = p2.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="160-2"><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>解题的核心依旧是如何同时到达相交节点<code>c1</code></p><p>把两个链表收尾相连，这样两个链表的长度就一致了，即<code>p1 = headA + headB, p2 = headB + headA</code></p><p>同事遍历两个链表，如果有相交点，他们会同时到达<code>c1</code>，否则会走向链表尾部</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   p1, p2 := headA, headB</span><br><span class="line">   <span class="keyword">for</span> p1 != p2 &#123;</span><br><span class="line">      <span class="keyword">if</span> p1 == <span class="literal">nil</span> &#123;</span><br><span class="line">         p1 = headB</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> p2 == <span class="literal">nil</span> &#123;</span><br><span class="line">         p2 = headA</span><br><span class="line">      &#125;</span><br><span class="line">      p1 = p1.Next</span><br><span class="line">      p2 = p2.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="141-环形链表"><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><p><img src="https://cdn.inkdp.cn/img/20220911221220.png" alt="image-20220911221219998"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>定义快慢指针,慢指针每次走1步,快指针走两步</p><p>如果链表中存在环,那么快指针会追上慢指针,否则快指针会走到链表末尾</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   slow, fast := head, head</span><br><span class="line">   <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">      slow = slow.Next</span><br><span class="line">      fast = fast.Next.Next</span><br><span class="line">      <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表-ii"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p><img src="https://cdn.inkdp.cn/img/20220911215656.png" alt="image-20220911215656884"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>假设快慢指针相遇，慢指针走了<code>k</code>步,那么快指针一定走了<code>2k</code>步，快指针多走的这k步就是在环里转圈圈,所以<code>k</code>的值就是环长度的整数倍</p><p>假设相遇点为<code>m</code>，那么环起点就为<code>k-m</code>，也就是说，从链表头部前进<code>k-m</code>就可以到达环起点</p><p>因为相遇点为<code>m</code>，<code>k</code>为环长度的倍数，所以只需要再走<code>k-m</code>步就可以到底环起点</p><p>所以当两个指针相遇时，重新定义一个指针从头出发，与慢指针再次相遇的地方就是环起点</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   slow, fast := head, head</span><br><span class="line">   <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">      slow = slow.Next</span><br><span class="line">      fast = fast.Next.Next</span><br><span class="line">      <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">         p := head</span><br><span class="line">         <span class="keyword">for</span> p != slow &#123;</span><br><span class="line">            p = p.Next</span><br><span class="line">            slow = slow.Next</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> p</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83-删除排序链表中的重复元素"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3><p><img src="https://cdn.inkdp.cn/img/20220913081016.png" alt="image-20220913081016554"></p><h4 id="解题思路：">解题思路：</h4><div class="note no-icon info simple"><p>定义快慢指针，快指针<code>fast</code>在前面探路，<code>slow</code>跟在后面，找到一个不重复的元素时，将<code>slow</code>指向<code>fast</code>，完成元素的删除</p><p>此题与26思路一样，不同的是将数组的操作变成了链表</p></div><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   slow, fast := head, head</span><br><span class="line">   <span class="keyword">for</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> slow.Val != fast.Val &#123;</span><br><span class="line">         <span class="comment">// nums[slow] = nums[fast]</span></span><br><span class="line">         slow.Next = fast</span><br><span class="line">         <span class="comment">// slow ++</span></span><br><span class="line">         slow = slow.Next</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// fast ++</span></span><br><span class="line">      fast = fast.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 断开与后面重复元素的链接</span></span><br><span class="line">   slow.Next = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接：">参考链接：</h3><ul><li><a href="https://labuladong.github.io/algo/1/4/">双指针技巧秒杀七道链表题目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写高质量SQL的30条建议</title>
      <link href="skill/back-end/62506.html"/>
      <url>skill/back-end/62506.html</url>
      
        <content type="html"><![CDATA[<div class="note orange icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>由于版本原因，部分建议可能已无效，请实际测试后使用</p></div><h3 id="1-查询sql尽量不要使用select-而是select具体字段">1、查询SQL尽量不要使用select *，而是select具体字段</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>只取需要的字段，节省资源、减少网络开销</li><li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成<a href="https://zhuanlan.zhihu.com/p/401198674">回表查询</a></li></ul><h3 id="2-如果知道查询结果只有一条或者只要最大-最小一条记录-建议用limit-1">2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;InkDP&#x27;</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;InkDP&#x27;</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li><li>当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</li></ul><h3 id="3-应尽量避免在where子句中使用or来连接条件">3、应尽量避免在where子句中使用or来连接条件</h3><p>反例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;InkDP&#x27;</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;InkDP&#x27;</span>; <span class="comment">-- 使用union all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;InkDP&#x27;</span> <span class="comment">-- 分开两条sql写</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>使用or可能会使索引失效，从而全表扫描。</li></ul><blockquote><p>对于or+没有索引的<code>name</code>这种情况，假设它走了<code>id</code>的索引，但是走到<code>name</code>查询条件时，它还得全表扫描，也就是需要三步过程：<code>全表扫描+索引扫描+合并</code>如果它一开始就走全表扫描，直接一遍扫描就完事。<a href="https://cloud.tencent.com/product/cdb?from=10680">mysql</a>是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。</p></blockquote><h3 id="4-优化limit分页">4、优化limit分页</h3><p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name，age <span class="keyword">from</span> employee limit <span class="number">10000</span>，<span class="number">10</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> name <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">10000</span> limit <span class="number">10</span>; <span class="comment">-- 方案一：返回上次查询的最大记录(偏移量)</span></span><br><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> name <span class="keyword">order</span> <span class="keyword">by</span> id  limit <span class="number">10000</span>，<span class="number">10</span>; <span class="comment">-- 方案二：order by + 索引</span></span><br><span class="line"><span class="comment">-- 方案三：在业务允许的情况下限制页数</span></span><br></pre></td></tr></table></figure><p>理由:</p><ul><li>当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，而是先把查询出所有符合条件的数据再根据偏移量+要取的条数，把前面偏移量这一段的数据抛弃掉再返回的。</li><li>如果使用优化方案一，返回上次最大查询记录（偏移量），这样可以跳过偏移量，效率提升不少。</li><li>方案二使用order by+索引，也是可以提高查询效率的。</li><li>方案三的话，建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</li></ul><h3 id="5-优化你的like语句">5、优化你的like语句</h3><p>日常开发中，如果用到模糊关键字查询，很容易想到like，但是like很可能让你的索引失效。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%time&#x27;</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id，name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;time%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li><p>把<code>%</code>放前面是不会使用索引的(由于版本的原因，5.6是不会使用索引的，8.0会使用，但是由于mysql的性能优化器觉得直接扫描会更快，所以没使用到)</p><ul><li><p>8.0：</p><p><img src="https://cdn.inkdp.cn/img/20220729081240.png" alt="image-20220729081240244"></p></li><li><p>5.6：</p><p><img src="https://cdn.inkdp.cn/img/20220731174559.png" alt="image-20220731174559874"></p></li></ul></li><li><p>把<code>%</code>放关键字后面，还是会走索引的</p><p><img src="https://cdn.inkdp.cn/img/20220729081339.png" alt="image-20220729081339405"></p></li><li><p>综上所述，在<code>mysql5.6</code>的版本，两种方式无异，但是在<code>8.0</code>的版本上，使用第二种明显效率更高</p></li></ul><h3 id="6-使用where条件限定要查询的数据-避免返回多余的行">6、使用where条件限定要查询的数据，避免返回多余的行</h3><p>假设业务场景是这样：查询某个用户是否是会员</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> is_vip <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 之后在通过业务去判断查询结果里面有无指定用户</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">and</span> is_vip <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 直接查看是否有结果即可</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。</li></ul><h3 id="7-尽量避免在索引列上使用mysql的内置函数">7、尽量避免在索引列上使用mysql的内置函数</h3><p>业务需求：查询最近七天内登陆过的用户(假设login_time加了索引)</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id, login_time <span class="keyword">from</span> login_user <span class="keyword">where</span> Date_ADD(login_time, <span class="type">Interval</span> <span class="number">7</span> <span class="keyword">DAY</span>) <span class="operator">&gt;=</span> now();</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id, login_time <span class="keyword">from</span> loginuser <span class="keyword">where</span>  loginTime <span class="operator">&gt;=</span> Date_ADD(NOW(), <span class="type">INTERVAL</span> <span class="operator">-</span> <span class="number">7</span> <span class="keyword">DAY</span>);</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li><p>索引列上使用mysql的内置函数，索引失效</p><p><img src="https://cdn.inkdp.cn/img/20220729084656.png" alt="image-20220729084656162"></p></li><li><p>如果索引列不加内置函数，索引还是会走的</p><p><img src="https://cdn.inkdp.cn/img/20220729084743.png" alt="image-20220729084743323"></p></li></ul><h3 id="8-应尽量避免在where子句中对字段进行表达式操作-这将导致系统放弃使用索引而进行全表扫">8、应尽量避免在where子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">-</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li><p>虽然<code>id</code>是主键索引，但是因为对它进行运算，索引直接迷路了。。。</p><p><img src="https://cdn.inkdp.cn/img/20220729104822.png" alt="image-20220729104822176"></p></li></ul><h3 id="9-inner-join-left-join-right-join-优先使用inner-join-如果是left-join-左边表结果尽量小">9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</h3><ul><li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul><p>都满足SQL需求的前提下，推荐优先使用Inner join（内连接），如果要使用left join，左边表数据结果尽量小，如果有条件的尽量放到左边处理。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tab1 t1 <span class="keyword">left</span> <span class="keyword">join</span> tab2 t2  <span class="keyword">on</span> t1.size <span class="operator">=</span> t2.size <span class="keyword">where</span> t1.id <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>正例：（子查询性能优化也是个大问题）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tab1 <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">2</span>) t1 <span class="keyword">left</span> <span class="keyword">join</span> tab2 t2 <span class="keyword">on</span> t1.size <span class="operator">=</span> t2.size;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>如果inner join是等值连接，或许返回的行数比较少，所以性能相对会好一点。</li><li>同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。</li></ul><h3 id="10-应尽量避免在where子句中使用-或-操作符-否则会扫描整个索引-5-6可以命中索引">10、应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则会扫描整个索引(5.6可以命中索引)</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&lt;&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 可以考虑分开两条sql写</span></span><br><span class="line"><span class="keyword">select</span> id, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">18</span>;</span><br><span class="line"><span class="keyword">select</span> id, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li><p>使用!=和&lt;&gt;会导致扫描所有索引(5.6可以命中索引)</p><ul><li><p>5.6：</p><p><img src="https://cdn.inkdp.cn/img/20220731175351.png" alt="image-20220731175351610"></p></li><li><p>8.0：</p><p><img src="https://cdn.inkdp.cn/img/20220729143037.png" alt="image-20220729143037407"></p></li></ul></li></ul><h3 id="11-使用联合索引时-注意索引列的顺序-一般遵循最左匹配原则">11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</h3><p>表结构：（有一个联合索引idx_user_id_age，user_id在前，age在后）</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220729145327.png" alt="image-20220729145327065"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">18</span>; <span class="comment">-- 符合最左匹配原则</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 符合最左匹配原则</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220729145544.png" alt="image-20220729145544327"></p><p><img src="https://cdn.inkdp.cn/img/20220729145602.png" alt="image-20220729145602097"></p><p>理由：</p><ul><li>当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</li><li>联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。</li></ul><h3 id="12-对查询进行优化-应考虑在where及order-by涉及的列上建立索引-尽量避免全表扫描">12、对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> address <span class="operator">=</span><span class="string">&#x27;重庆&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> age ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220730174155.png" alt="image-20220730174154876"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> index idx_address_age (address, age); <span class="comment">-- 添加索引</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220730180723.png" alt="image-20220730180723417"></p><p>13、如果插入数据过多，考虑批量插入。</p><p>反例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for &#123; -- 业务代码中存在循环插入</span><br><span class="line"> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">user</span>, age) <span class="keyword">values</span> (&quot;user&quot;, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (name, age) <span class="keyword">values</span> (&quot;InkDP1&quot;, <span class="number">18</span>),(&quot;HQL&quot;, <span class="number">19</span>)....</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>批量插入性能好，更加省时间</li></ul><blockquote><p>打个比喻:假如你需要搬一万块砖到楼顶,你有一个电梯,电梯一次可以放适量的砖（最多放500）,你可以选择一次运送一块砖,也可以一次运送500块砖,你觉得哪个时间消耗大?</p></blockquote><h3 id="14-在适当的时候-使用覆盖索引">14、在适当的时候，使用覆盖索引。</h3><p>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="keyword">like</span> <span class="string">&#x27;%1&#x27;</span> <span class="comment">-- like模糊查血，不走索引了</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220731175901.png" alt="image-20220731175901535"></p><p>正例：</p><p><img src="https://cdn.inkdp.cn/img/20220731180147.png" alt="image-20220731180147538"></p><h3 id="15-慎用distinct关键字">15、慎用distinct关键字</h3><p>distinct 关键字一般用来过滤重复记录，以返回不重复的记录。在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>正例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name form <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>带distinct的语句cpu时间和占用时间都高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较、过滤的过程会占用系统资源，cpu时间。</li></ul><h3 id="16-删除冗余和重复索引">16、删除冗余和重复索引</h3><p>反例:</p><p><img src="https://cdn.inkdp.cn/img/20220731180958.png" alt="image-20220731180958402"></p><p>正例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除索引idx_user_id，因为组合索引(A, B)相当于创建了索引(A)和索引(A, B)</span><br></pre></td></tr></table></figure><p>理由：</p><p>重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能</p><h3 id="17-如果数据量较大-优化你的修改-删除语句">17、如果数据量较大，优化你的修改/删除语句。</h3><p>避免同时修改或删除过多数据，因为会造成cpu利用率过高，从而影响别人对数据库的访问。</p><p>反例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一次删除10万或者100万+</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">100000</span>;</span><br><span class="line"><span class="comment">-- 或者采用单一循环操作，效率低，</span></span><br><span class="line">for &#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> xxx；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制</p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">500</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">500</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">1000</span>； <span class="comment">-- 分批进行删除,如每次500</span></span><br></pre></td></tr></table></figure><p>复制</p><p>理由：</p><ul><li>一次性删除太多数据，可能会有lock wait timeout exceed的错误，所以建议分批操作。</li></ul><h3 id="18-where子句中考虑使用默认值代替null">18、where子句中考虑使用默认值代替null</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li><p>并不是说使用了<code>is null</code> 或者<code> is not null</code> 就会不走索引了，这个跟mysql版本以及查询成本都有关(5.6不走索引)。</p><blockquote><p>如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件 <code>！=，&gt;isnull，isnotnull</code>经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃索引的。</p></blockquote></li><li><p>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点</p></li></ul><h3 id="19-不要有超过5个以上的表连接">19、不要有超过5个以上的表连接</h3><ul><li>连表越多，编译的时间和开销也就越大。</li><li>把连接表拆开成较小的几个执行，可读性更高。</li><li>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li></ul><h3 id="20-exist-in的合理利用">20、exist&amp;in的合理利用</h3><p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> deptId <span class="keyword">in</span> (<span class="keyword">select</span> deptId <span class="keyword">from</span> B);</span><br></pre></td></tr></table></figure><p>这样写等价于：</p><blockquote><p>先查询部门表B</p><p>select deptId from B</p><p>再由部门deptId，查询A的员工</p><p>select * from A where A.deptId = B.deptId</p></blockquote><p>可以抽象成这样的一个循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(b); j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[i].Id == b[j].Id &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, a[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> A.deptId <span class="operator">=</span> B.deptId);</span><br></pre></td></tr></table></figure><p>因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。</p><p>那么，这样写就等价于：</p><blockquote><p>select * from A,先从A表做循环</p><p>select * from B where A.deptId = B.deptId,再从B表做循环.</p></blockquote><p>同理抽成一个循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(b); i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(a); j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a[i].depotId == b[j].depotId &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, a[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。</p><p>因此，我们要选择最外层循环小的，也就是，如果<strong>B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exist</strong>。</p><p>PS：使用连表会不会更好，不好的话为什么？</p><h3 id="21-尽量用union-all替换-union">21、尽量用union all替换 union</h3><p>如果检索结果中不会有重复的记录，推荐union all 替换 union。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">union</span>  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> userid <span class="operator">=</span> <span class="number">1</span> <span class="keyword">union</span> allselect <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>如果使用union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。如果已知检索结果没有重复记录，使用union all 代替union，这样会提高效率。</li></ul><h3 id="22-索引不宜太多-一般5个以内">22、索引不宜太多，一般5个以内。</h3><ul><li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li><li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li><li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li></ul><h3 id="23-尽量使用数字型字段-若只含数值信息的字段尽量不要设计为字符型">23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`king_id` <span class="type">varchar</span>（<span class="number">20</span>） <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;守护者Id&#x27;</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`king_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;守护者Id&#x27;</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。</li></ul><h3 id="24-索引不适合建在有大量重复数据的字段上-如性别这类型数据库字段">24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</h3><p>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p><h3 id="25-尽量避免向客户端返回过多数据量">25、尽量避免向客户端返回过多数据量。</h3><p>假设业务需求是，用户请求查看自己最近一年观看过的直播数据。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> living_info <span class="keyword">where</span> watch_id <span class="operator">=</span> user_id <span class="keyword">and</span> watch_time <span class="operator">&gt;=</span> Date_sub(now(),<span class="type">Interval</span> <span class="number">1</span> Y)  <span class="comment">-- 一次性查询所有数据回来</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> LivingInfo <span class="keyword">where</span> watchId <span class="operator">=</span> useId <span class="keyword">and</span> watchTime <span class="operator">&gt;=</span> Date_sub(now(),<span class="type">Interval</span> <span class="number">1</span> Y) limit <span class="keyword">offset</span>，pageSize <span class="comment">-- //分页查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> LivingInfo <span class="keyword">where</span> watchId <span class="operator">=</span> useId <span class="keyword">and</span> watchTime <span class="operator">&gt;=</span> Date_sub(now(),<span class="type">Interval</span> <span class="number">1</span> Y) limit <span class="number">200</span>; <span class="comment">-- 如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，</span></span><br></pre></td></tr></table></figure><h3 id="26-当在sql语句中连接多个表时-请使用表的别名-并把别名前缀于每一列上-这样语义更加清晰">26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> XXXXXX_A innerjoin XXXXXX_B <span class="keyword">on</span> XXXXXX_A.deptId <span class="operator">=</span> XXXXXX_B.deptId;</span><br></pre></td></tr></table></figure><p>正例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  A.name, B.deptName <span class="keyword">from</span> XXXXXX_A A innerjoin XXXXXX_B B <span class="keyword">on</span> A.deptId <span class="operator">=</span> B.deptId;</span><br></pre></td></tr></table></figure><h3 id="27-尽可能使用varchar-nvarchar-代替-char-nchar">27、尽可能使用varchar/nvarchar 代替 char/nchar。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`deptName` <span class="type">char</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`deptName` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span></span><br></pre></td></tr></table></figure><p>理由：</p><ul><li>因为首先变长字段存储空间小，可以节省存储空间。</li><li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li></ul><h3 id="28-为了提高group-by-语句的效率-可以在执行到该语句前-把不需要的记录过滤掉">28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> job，avg（salary） <span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> job <span class="keyword">having</span> job <span class="operator">=</span> <span class="string">&#x27;president&#x27;</span> <span class="keyword">or</span> job <span class="operator">=</span> <span class="string">&#x27;managent&#x27;</span></span><br></pre></td></tr></table></figure><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> job，avg（salary） <span class="keyword">from</span> employee <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;president&#x27;</span> <span class="keyword">or</span> job <span class="operator">=</span> <span class="string">&#x27;managent&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> job；</span><br></pre></td></tr></table></figure><h3 id="29-如果字段类型是字符串-where时一定用引号括起来-否则索引失效">29、如果字段类型是字符串，where时一定用引号括起来，否则索引失效</h3><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220731195859.png" alt="image-20220731195859391"></p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20220731195913.png" alt="image-20220731195913670"></p><p>理由：</p><ul><li>为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较。</li></ul><h3 id="30-使用explain-分析你sql的计划">30、使用explain 分析你SQL的计划</h3><p>日常开发写SQL的时候，尽量养成一个习惯吧。用explain分析一下你写的SQL，尤其是走不走索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">10086</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务详解极其使用方式</title>
      <link href="skill/back-end/13451.html"/>
      <url>skill/back-end/13451.html</url>
      
        <content type="html"><![CDATA[<h3 id="事务是什么">事务是什么</h3><p>事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><h4 id="事务的acid属性">事务的ACID属性</h4><ul><li>原子性(Atomicity): 事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。</li><li>一致性(Consistency): 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的</li><li>隔离性(Isolation): 一个事务的执行不能被其他事务干扰。由并发事务所作的修改必须与任何其他并发事务所作的修改隔离。事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是第二个事务修改它之后的状态，事务不会识别中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。</li><li>持久性(Durability): 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li></ul><h4 id="事务的4个隔离级别">事务的4个隔离级别</h4><h5 id="事务并发可能出现的情况">事务并发可能出现的情况</h5><h6 id="脏读">脏读</h6><blockquote><p>一个事务读到了另外一个事务未提交的内容</p></blockquote><p><img src="https://cdn.inkdp.cn/img/20220622225320.svg" alt="脏读示意图"></p><p>会话B开启一个事务，把<code>id=1</code>的<code>name</code>为<code>小米12</code>修改成<code>苹果13</code>，此时另外一个会话A也开启一个事务，读取<code>id=1</code>的<code>name</code>，此时的查询结果为<code>苹果13</code>，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现</p><h6 id="不可重复读">不可重复读</h6><blockquote><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）</p></blockquote><p><img src="https://cdn.inkdp.cn/img/20220622230451.svg" alt=""></p><p>会话A开启一个事务，查询<code>id=1</code>的结果，此时查询的结果<code>name</code>为<code>小米12</code>。接着会话B把<code>id=1</code>的<code>name</code>修改为<code>苹果13</code>（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询<code>id=1</code>的结果，读取的结果<code>name</code>为<code>苹果13</code>。会话B再此修改<code>id=1</code>的<code>name</code>为<code>洛基亚</code>，会话A的事务再次查询<code>id=1</code>，结果<code>name</code>的值为<code>洛基亚</code>，这种现象就是不可重复读。</p><h6 id="幻读">幻读</h6><blockquote><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）</p></blockquote><p><img src="https://cdn.inkdp.cn/img/20220622230957.svg" alt="幻读示意图"></p><p>会话A开启一个事务，查询<code>id&gt;0</code>的记录，此时会查到<code>name=小米12</code>的记录。接着会话B插入一条<code>name=苹果13</code>的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（<code>id&gt;0</code>）再一次查询，此时会出现两条记录（<code>name</code>为<code>小米12</code>和<code>苹果13</code>的记录），这种现象就是幻读。</p><h5 id="事务隔离级别">事务隔离级别</h5><blockquote><p>数据库事务的隔离级别有4个，读未提交、读已提交、可重复读、可串行读</p><p>隔离级别比较：读未提交&lt;读已提交&lt;可重复读&lt;可串行读</p><p>隔离级别对性能的影响比较：读未提交&lt;读已提交&lt;可重复读&lt;可串行读</p><p>有次可以看出，隔离级别越高，所需要消耗的性能越大，为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认为此</p></blockquote><h6 id="读未提交">读未提交</h6><blockquote><p>事务A可以读取到事务B修改过但未提交的数据。</p><p>可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。</p></blockquote><p><img src="https://cdn.inkdp.cn/img/20220622233256.svg" alt="读未提交隔离级别"></p><h6 id="读已提交">读已提交</h6><blockquote><p>事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。</p><p>读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别</p></blockquote><p><img src="https://cdn.inkdp.cn/img/20220622233556.svg" alt="读已提交隔离级别"></p><h6 id="可重复读">可重复读</h6><blockquote><p>事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取事务B修改的数据</p><p>可重复读解决了脏读和不可重复读问题，但可能发送幻读</p></blockquote><p><img src="https://cdn.inkdp.cn/img/20220622233621.svg" alt="可重复读隔离级别"></p><h6 id="可串行读">可串行读</h6><blockquote><p>各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读写锁）</p></blockquote><p><img src="https://cdn.inkdp.cn/img/20220623182212.svg" alt="可串行读隔离级别(读读操作不会阻塞)"></p><p><img src="https://cdn.inkdp.cn/img/20220622235046.svg" alt="可串行读隔离级别(读写操作阻塞)"></p><p><img src="https://cdn.inkdp.cn/img/20220622235107.svg" alt="可串行读隔离级别(写读操作阻塞)"></p><p><img src="https://cdn.inkdp.cn/img/20220622235126.svg" alt="可串行读隔离级别(写写操作阻塞)"></p><p>隔离级别比较：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">脏读</th><th style="text-align:center">不接重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:left">读未提交</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:left">读已提交</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:left">可重复读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:left">串行读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="mysql中事务的实际操作">MySQL中事务的实际操作</h3><p>创建一个测试用的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table tb_demo</span><br><span class="line">(</span><br><span class="line">    id     int         not null,</span><br><span class="line">    name   varchar(20) not null,</span><br><span class="line">    amount int         not null,</span><br><span class="line">    constraint tb_demo_pk</span><br><span class="line">        primary key (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="mysql原生">MySQL原生</h4><h5 id="事务正常提交：">事务正常提交：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin; # 开始事务</span><br><span class="line">insert into tb_demo value (1, &quot;InkDP&quot;, 999);</span><br><span class="line">insert into tb_demo value (2, &quot;LFP&quot;, 999);</span><br><span class="line">commit; # 提交</span><br><span class="line">select * from tb_demo;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>amount</th></tr></thead><tbody><tr><td>1</td><td>InkDP</td><td>999</td></tr><tr><td>2</td><td>LPF</td><td>999</td></tr></tbody></table><p>开始事务后正确的插入了两条数据，然后提交，最后查询可以看到两条数据是正常插入了的</p><p>ps: 如果此时有一条数据插入失败会怎样？</p><h5 id="事务回滚：">事务回滚：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin; # 开始事务</span><br><span class="line">insert into tb_demo value (3, &quot;HDF&quot;, 999);</span><br><span class="line">rollback; # 回滚</span><br><span class="line">select * from tb_demo;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>amount</th></tr></thead><tbody><tr><td>1</td><td>InkDP</td><td>999</td></tr><tr><td>2</td><td>LPF</td><td>999</td></tr></tbody></table><p>开始事务后插入一条数据，然后回滚，最后可以看到表记录里是没有刚刚插入的数据的。</p><h4 id="使用gorm操作事务">使用Gorm操作事务</h4><h5 id="会话事务">会话事务</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transaction</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">   err := db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">      <span class="comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span></span><br><span class="line">      <span class="keyword">if</span> err := tx.Create(&amp;Demo&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;InkDP&quot;</span>, Amount: <span class="number">999</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="comment">// 返回任何错误都会回滚事务</span></span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err := tx.Create(&amp;Demo&#123;Id: <span class="number">2</span>, Name: <span class="string">&quot;LPF&quot;</span>, Amount: <span class="number">999</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回 nil 提交事务</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;)</span><br><span class="line">   log.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="手动事务-swig-6">手动事务<mark class="hl-label red">(不建议使用)</mark> </h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transaction</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line"><span class="comment">// 开始事务</span></span><br><span class="line">tx := db.Begin()</span><br><span class="line">result := tx.Model(&amp;Demo&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">1</span>).UpdateColumn(<span class="string">&quot;amount&quot;</span>, gorm.Expr(<span class="string">&quot;amount - ?&quot;</span>, <span class="number">500</span>))</span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> || result.RowsAffected == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 事务回滚</span></span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">result = tx.Model(&amp;Demo&#123;&#125;).Where(<span class="string">&quot;id = ?&quot;</span>, <span class="number">5</span>).UpdateColumn(<span class="string">&quot;amount&quot;</span>, gorm.Expr(<span class="string">&quot;amount + ?&quot;</span>, <span class="number">500</span>))</span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> || result.RowsAffected == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 事务回滚</span></span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning simple"><p>手动事务的时候一定要检查最终是否有调用<code>Rollback</code>或者<code>Commit</code>，否则它会一直占用这个连接，直到程序退出。</p></div><h4 id="kratos中使用gorm完成事务">Kratos中使用Gorm完成事务</h4><p>参考在 <a href="https://learnku.com/articles/65506">在 Go-Kratos 框架中优雅的使用 GORM 完成事务</a></p><p>主要的思路就是将<code>gorm</code>事务会话添加到上下文中</p><h3 id="进阶">进阶</h3><ul><li><p>隔离级别与事务的实现原理</p></li><li><p>分布式事务</p></li><li><p>NoSql的事务</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="skill/back-end/10048.html"/>
      <url>skill/back-end/10048.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序与基础结构分离开来，从而可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础结构。通过利用 Docker 的快速发布、测试和部署代码的方法，可以显著减少编写代码和在生产环境中运行代码之间的延迟。</p><h4 id="docker是什么？">docker是什么？</h4><ul><li>Docker 是一个应用打包、分发、部署的工具</li><li>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，</li><li>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</li></ul><p>官方解释：</p><p>Docker提供一个能力来打包和运行应用，在一个被称为容器的松散的孤立环境中。这种隔离和安全机制可以使你同时在一个主机上运行很多的容器。容器是轻量级，因为它们不需要额外的应用管理负载，直接在主机的内核当中运行。意味着可以在给定的硬件当中运行更多的容器（比虚拟机成本要低很多）。<strong>甚至可以在虚拟机当中运行docker</strong>！</p><p>提供了一个工具和平台来管理你的容器的生命周期:</p><ul><li>使用容器开发应用及支持的组件</li><li>容器称为了一个单元用于发布和测试你的应用</li><li>准备发布的时候，作为一个容器或合理安排的服务，无论是产品环境还是云环境，都会是一致的</li></ul><h4 id="跟普通虚拟机的对比">跟普通虚拟机的对比</h4><table><thead><tr><th>特性</th><th style="text-align:left">普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td style="text-align:left">通常只能在桌面级系统运行，例如 Windows/Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td style="text-align:left">性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td style="text-align:left">需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>兼容性</td><td style="text-align:left">兼容性不高，不同系统差异大</td><td>兼容性好，不同系统都一样部署方式</td></tr></tbody></table><h4 id="可以用docker来做什么？">可以用docker来做什么？</h4><ol><li><p>快速，一致发布应用</p><p>docker通过允许开发者在标准的环境使用本地容器提供应用和服务，来简单化开发生命周期。容器对于不断地集成（continuous integration）、发布（continuous delivery）（CI/CD）工作流是非常重要的！</p></li><li><p>响应式部署</p><p>docker基于容器的平台具有具有高度的可移植性的工作负载。docker 容器可以运行在开发者的本地笔记本、在数据中心的物理机或虚拟机当中、云环境或者混合环境等等。</p><p>docker的可移植性和轻量级的特征可以使之很轻易地在真实环境当中，根据商业需要，动态地管理工作负载，按比例增加或减少应用服务 。</p></li><li><p>运行更多的负载在相同的硬件中</p><p>docker是一个轻量并且快速。相对于应用管理的虚拟机设备，提供了一个可见、成本低廉的选择，所以你可以更加充分地运行本的计算 能力以达到商业布标。docker更喜欢高密度环境用于小型、中型部署，这样可以用更少地资源做更多的事。</p></li><li><p>快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK</p></li><li><p>多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0</p></li></ol><h4 id="重要概念：-font-color-red-镜像-容器-font-仓库">重要概念：<font color="red">镜像、容器</font>、仓库</h4><ul><li><p>镜像</p><p>一个镜像就是一个只读模板，指示创建容器 。大多数情况下，一个镜像会基于另一个镜像以及一些额外的自定义选项。比如，你可以构建一个基于ubuntu镜像，但是安装apache网站服务器和应用，能够像配置的一样运行起来。</p><p>你可以创建自己的镜像或者可以仅仅使用那些已经被其它人创建发布的镜像。为了创建你自己的镜像，你需要创建一个dockerfile，使用相同的语法来定义和步骤来创建镜像并运行。</p></li><li><p>容器</p><p>一个容器就是就是一个镜像的实例，你可以通过Docker API或命令行创建、启动、停止、移动或者删除。一个容器可以连接多个网络或者基于当前的状态创造更多的镜像。</p><p>默认情况下，容器会与其它容器进行隔离，可以控制容器的网络、存储或其他底层系统。容器由镜像定义像其它配置选项一样</p></li><li><p>仓库</p><p>仓库类似Git的远程仓库，集中存放镜像文件。</p></li></ul><p>三者的关系：</p><p><img src="https://cdn.inkdp.cn/img/20220602082051.png" alt="img"></p><h4 id="docker的好处">Docker的好处</h4><ol><li><p>模块化</p><p>Docker 容器化方法非常注重在不停止整个应用的情况下，单独截取部分应用进行更新或修复的能力。除了这种基于微服务的方法，您还可以采用与<a href="https://baike.baidu.com/item/SOA/2140650">面向服务的架构（SOA）</a>类似的使用方法，在多个应用间共享进程。</p></li><li><p>层和镜像版本控制</p><p>每个 Docker 镜像文件都包含多个层。这些层组合在一起，构成单个镜像。每当镜像发生改变时，就会创建一个新的镜像层。用户每次发出命令（例如 <em>run</em> 或 <em>copy</em>）时，都会创建一个新的镜像层。</p><p>Docker 重复使用这些层来构建新容器，借此帮助加快流程构建。镜像之间会共享中间变化，从而进一步提升速度、<a href="http://developers.redhat.com/blog/2016/03/09/more-about-docker-images-size/">规模</a>以及效率。版本控制是镜像层本身自带的能力。每次发生新的更改时，您大都会获得一个内置的更改日志，实现对容器镜像的全盘管控。</p></li><li><p>回滚</p><p>回滚也许是层最值得一提的功能。每个镜像都拥有多个层。举例而言，如果您不喜欢迭代后的镜像版本，完全可以通过回滚，返回之前的版本。这一功能还支持敏捷开发方法，帮助<a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd">持续实施集成和部署（CI/CD）</a>，使其在工具层面成为一种现实。</p></li><li><p>快速部署</p><p>启动和运行新硬件、实施部署并投入使用，这在过去一般需要数天时间。投入的心力和成本往往也让人不堪重负。基于 Docker 的容器可将部署时间缩短到几秒。通过为每个进程构建容器，您可以快速将这些类似进程应用到新的应用程序中。而且，由于无需启动操作系统即可添加或移动容器，因此大幅缩短了部署时间。除此之外，得益于这种部署速度，您可以轻松无虞、经济高效地创建和销毁容器创建的数据。</p><p>因此，Docker 技术是一种更加精细、可控、基于微服务的技术，可为企业提供更高的效率价值。</p></li></ol><h4 id="docker的缺点">Docker的缺点</h4><p>Docker 本身非常适合用于管理单个容器。但随着您开始使用越来越多的容器和容器化应用，并把它们划分成数百个部分，很可能会导致管理和编排变得非常困难。最终，您需要后退一步，对容器实施分组，以便跨所有容器提供网络、安全、遥测等服务。于是，k8s 应运而生。</p><h3 id="使用docker安装软件">使用Docker安装软件</h3><h4 id="传统安装软件缺点">传统安装软件缺点</h4><ul><li>安装麻烦，可能有各种依赖，需要提前安装各种东西。比如：ElasticSearch，ElK</li><li>部分软件并不能在所有系统完美运行，各种兼容问题，甚至无法安装。例如在Windows上安装最新redis</li><li>软件多版本之间不能共存</li><li>不同系统安装方式不一样</li><li>安装一堆软件，占用系统内存，拖慢电脑运行速度</li></ul><h4 id="docker安装的优点">Docker安装的优点</h4><ul><li>一个命令就可以安装好，快速方便</li><li>有大量的镜像，可直接使用</li><li>没有系统兼容问题，Linux 专享软件也照样跑</li><li>支持软件多版本共存</li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul><h4 id="例：使用docker安装redis">例：使用Docker安装Redis</h4><p><code>docker run -d -p 6379:6379 --name redis redis</code></p><p>轻松搞定</p><p><img src="https://cdn.inkdp.cn/img/20220531084506.png" alt="image-20220531084506717"></p><h3 id="docker常见命令">Docker常见命令</h3><p><img src="https://cdn.inkdp.cn/img/20220602080651.svg" alt="Docker常用命令"></p><h4 id="服务">服务</h4><ul><li><p>查看docker版本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></li><li><p>查看docker简要信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></li><li><p>启动docker(linux)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>关闭docker(linux)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure></li><li><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li><li><p>重启docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li><li><p>关闭docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker stop</span><br></pre></td></tr></table></figure></li></ul><h4 id="镜像">镜像</h4><p>镜像仓库中存储这大量官方镜像，可以从仓库直接获取镜像并运行，比如<a href="https://hub.docker.com/search?q=&amp;type=">Docker Hub</a>，拉取慢可以更换镜像源以提速，以腾讯加速源为例，编辑<code>/etc/docker/daemon.json</code>配置文件，添加一下内容即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">       <span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取镜像">获取镜像</h5><ul><li><p>搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名</span><br></pre></td></tr></table></figure></li><li><p>获取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [OPTIONS] 镜像名称[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>OPTIONS:</p><ul><li><code>--all-tags,-a</code>  下载存储库中所有标记的镜像</li><li><code>--disable-content-trust</code>  跳过镜像验证，默认为<code>true</code></li><li><code>--platform</code> 如果服务器支持多平台，则设置平台</li><li><code>--quiet,-q</code> 取消详情输出</li></ul><table><thead><tr><th><code>--all-tags</code>,<code>-a</code></th><th></th><th>下载存储库中的所有标记图像</th></tr></thead><tbody><tr><td><code>--disable-content-trust</code></td><td><code>true</code></td><td>跳过图像验证</td></tr><tr><td><code>--platform</code></td><td></td><td>如果服务器支持多平台，则设置平台</td></tr><tr><td><code>--quiet</code>,<code>-q</code></td><td></td><td>抑制详细输出</td></tr></tbody></table></li></ul><h5 id="镜像管理">镜像管理</h5><ul><li><p>列出镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  docker images</span><br><span class="line">  docker image ls</span><br><span class="line"></span><br><span class="line">- 删除镜像</span><br><span class="line"></span><br><span class="line">  ```shell</span><br><span class="line">  docker rmi &lt;镜像Id|镜像名称&gt; [&lt;镜像Id|镜像名称&gt;,...]</span><br></pre></td></tr></table></figure></li><li><p>导出镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docekr save</span><br></pre></td></tr></table></figure></li><li><p>导入镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load</span><br></pre></td></tr></table></figure></li></ul><h5 id="dockerfile构建镜像">Dockerfile构建镜像</h5><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><p><strong>Dockerfile常见指令：</strong></p><ul><li>FORM：指定基础镜像</li><li>RUN：执行命令</li><li>WORKDIR：指定工作目录</li><li>COPY：复制文件</li><li>ADD：更高级的复制文件</li><li>CMD：容器启动命令</li><li>ENV：设置环境变量</li><li>EXPOST：声明端口</li><li>VOLUME：挂载目录</li></ul><p>其他指令还有：ENTRYPOINT、ARG、USER、HEALTHCHECK、LABEL…，详见<a href="https://docs.docker.com/engine/reference/builder/#environment-replacement">Environment replacement</a></p><p>Dockerfiles示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>.<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    CGO_ENABLED=<span class="number">0</span> \</span><br><span class="line">    GOOS=linux \</span><br><span class="line">    GOARCH=amd64</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /build</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go build -ldflags <span class="string">&quot;-s -w&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /build</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /build ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> ./demo</span></span><br></pre></td></tr></table></figure><p><strong>镜像构建</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS：</p><ul><li>**–build-arg=[] :**设置镜像创建时的变量；</li><li>**–cpu-shares :**设置 cpu 使用权重；</li><li>**–cpu-period :**限制 CPU CFS周期；</li><li>**–cpu-quota :**限制 CPU CFS配额；</li><li>**–cpuset-cpus :**指定使用的CPU id；</li><li>**–cpuset-mems :**指定使用的内存 id；</li><li>**–disable-content-trust :**忽略校验，默认开启；</li><li>**-f :**指定要使用的Dockerfile路径；</li><li>**–force-rm :**设置镜像过程中删除中间容器；</li><li>**–isolation :**使用容器隔离技术；</li><li>**–label=[] :**设置镜像使用的元数据；</li><li>**-m :**设置内存最大值；</li><li>**–memory-swap :**设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；</li><li>**–no-cache :**创建镜像的过程不使用缓存；</li><li>**–pull :**尝试去更新镜像的新版本；</li><li>**–quiet, -q :**安静模式，成功后只输出镜像 ID；</li><li>**–rm :**设置镜像成功后删除中间容器；</li><li>**–shm-size :**设置/dev/shm的大小，默认值是64M；</li><li>**–ulimit :**Ulimit配置。</li><li>**–squash :**将 Dockerfile 中所有的操作压缩为一层。</li><li><strong>–tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>–network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><p><strong>镜像运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h4 id="容器">容器</h4><h5 id="容器操作">容器操作</h5><ul><li><p>启动容器：启动容器有两种方式：一是基于镜像新建容器，二是启动终止状态的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建并启动</span></span><br><span class="line">docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动已终止容器</span></span><br><span class="line">docker start &lt;容器ID|容器名&gt;</span><br></pre></td></tr></table></figure><p><code>docker run</code>命令详见：<a href="https://docs.docker.com/engine/reference/run/#general-form">Docker run reference</a></p></li><li><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有容器(运行中和已停止)</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器ID|容器名称&gt;</span><br></pre></td></tr></table></figure></li><li><p>重启容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器ID|容器名称&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除容器</p><p>删除的容器必须是已停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器ID|容器名称&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="进入容器">进入容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec [OPTIONS] &lt;容器ID|容器名&gt; 命令 [ARG...]</span><br></pre></td></tr></table></figure><p>使用<code>docker exec</code>命令需要容器在运行中，OPTIONS参数详见：<a href="https://docs.docker.com/engine/reference/commandline/exec/#options">OPTIONS</a></p><h5 id="导入和导出">导入和导出</h5><ul><li><p>导出容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export &lt;容器ID|容器名称&gt;</span><br></pre></td></tr></table></figure></li><li><p>导入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import &lt;路径&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="其他">其他</h5><ul><li><p>查看日志:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [OPTIONS] &lt;容器ID|容器名&gt;</span><br></pre></td></tr></table></figure><p>OPTIONS参数列表:</p><ul><li><strong>–details :</strong> 显示日志详情</li><li><strong>–follow, –f :</strong> 日志滚动输出</li><li>**–since : **显示某个开始时间的所有日志</li><li><strong>–tail, -t :</strong> 从日志末尾显示的行数</li><li>**–timestamps, -t : **显示时间戳</li><li>**–until : **显示某个时间内的所有日志</li></ul></li><li><p>复制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从主机复制到容器</span></span><br><span class="line">docker cp 主机路径 &lt;容器ID|容器名称&gt;:容器类内路径 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器复制到主机</span></span><br><span class="line">docker cp &lt;容器ID|容器名称&gt;:容器类内路径 主机路径</span><br></pre></td></tr></table></figure></li></ul><h3 id="docker-compose">Docker Compose</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>docker compose使用的3个步骤：</p><ul><li>使用<code>Dockerfile</code>定义应用程序环境</li><li>使用<code>docker-compose.yaml</code>定义构成应用程序的服务，这样它们在隔离环境中一起运行</li><li>最后，执行<code>docker-compose up</code>命令来启动并运行整个应用程序</li></ul><p><code>docker-compose.yaml</code>示例配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">demo-web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.2.5</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/dockerData/redis/conf/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/dockerData/redis/data:/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">demo-web-redis</span></span><br></pre></td></tr></table></figure><p>运行<code>docker-compose up</code>即可启动应用程序，如果需要后台运行可以使用<code>docker-compose up -d</code></p><h4 id="配置指令参考：">配置指令参考：</h4><ul><li>version: 指定本<code>yaml</code>依从的<code>compose</code>哪个版本制定的</li><li>services：运行的服务列表</li><li>build：指定为构建镜像上下文路径，或者作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args：<ul><li>context：上下文路径。</li><li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li><li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li><li>labels：设置构建镜像的标签。</li><li>target：多层构建，可以指定构建哪一层。</li></ul></li><li>volumes：文件挂载文件、目录映射</li><li>image：所使用的镜像名</li><li>links：对应容器ip映射到容器内，上文所示中的应用程序就可以使用<code>redis:6379</code>访问redis</li><li>container_name：容器名称</li><li>ports：端口映射,把docker内部的端口暴露出来</li><li>restart：重启操作[no|always|on-failure|unless-stoppen]</li><li>env_file：环境变量文件</li><li>environment：环境变量</li><li>external_links：链接其他的容器服务</li><li>depends_on：由于启动顺序是随机的，如果有依赖关系时添加</li><li>….</li></ul><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.docker.com%2Fcompose%2Fcompose-file%2F%23environment">docker-compose 参数 官方文档</a></p><h4 id="docker-compose命令">docker compose命令</h4><table><thead><tr><th>命令</th><th>详情</th></tr></thead><tbody><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_build/">docker compose build</a></td><td>构建或重建服务</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_convert/">docker compose convert</a></td><td>格式化配置文件</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_cp/">docker compose cp</a></td><td>在服务容器和本地文件系统之间复制文件/文件夹</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_create/">docker compose create</a></td><td>为服务创建容器</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_down/">docker compose down</a></td><td>停止并移除容器、网络</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_events/">docker compose events</a></td><td>从容器接收实时事件</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_exec/">docker compose exec</a></td><td>在正在运行的容器中执行命令</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_images/">docker compose images</a></td><td>列出所创建的容器使用的镜像</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_kill/">docker compose kill</a></td><td>强制停止容器</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_logs/">docker compose logs</a></td><td>插入容器日志</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_ls/">docker compose ls</a></td><td>列出正在运行的compose项目</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_pause/">docker compose pause</a></td><td>暂停服务</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_port/">docker compose port</a></td><td>打印端口绑定的公共端口</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_ps/">docker compose ps</a></td><td>容器列表</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_pull/">docker compose pull</a></td><td>拉取服务镜像</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_push/">docker compose push</a></td><td>推送服务镜像</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_restart/">docker compose restart</a></td><td>重新启动容器</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_rm/">docker compose rm</a></td><td>移除已停止的服务容器</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_run/">docker compose run</a></td><td>对服务运行一次性命令</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_start/">docker compose start</a></td><td>启动服务</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_stop/">docker compose stop</a></td><td>停止服务</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_top/">docker compose top</a></td><td>显示正在运行的服务进程</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_unpause/">docker compose unpause</a></td><td>停止服务</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_up/">docker compose up</a></td><td>创建和启动容器</td></tr><tr><td><a href="https://docs.docker.com/engine/reference/commandline/compose_version/">docker compose version</a></td><td>显示 Docker Compose 版本信息</td></tr></tbody></table><h3 id="进阶">进阶</h3><ul><li>kubernetes学习笔记：学习中</li><li>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次主键查询乱序</title>
      <link href="skill/back-end/25282.html"/>
      <url>skill/back-end/25282.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>今天日常开发中，一条简单的不能再简单的查询，却莫名出现了主键乱序的情况，虽然加了<code>order by</code>之后完美解决，但是还是想究其原因。</p><h3 id="复现一下">复现一下</h3><p>表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tb_test&#96;  (</span><br><span class="line">  &#96;id&#96; int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;room_id&#96; int NOT NULL,</span><br><span class="line">  &#96;user_id&#96; int NOT NULL,</span><br><span class="line">  &#96;amount&#96; decimal(10, 2) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  INDEX &#96;tb_test_room_id_user_id_index&#96;(&#96;room_id&#96;, &#96;user_id&#96;) USING BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据(<mark class="hl-label green">多插入几条数据，确保使用索引比全表扫描快，这样才会使用到索引</mark> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (1, 1, 1, 99.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (2, 1, 4, 80.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (3, 1, 2, 28.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (4, 2, 2, 77.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (5, 2, 1, 66.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (6, 2, 5, 98.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (7, 3, 1, 55.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (8, 3, 3, 98.00);</span><br><span class="line">INSERT INTO &#96;tb_test&#96; (&#96;id&#96;, &#96;room_id&#96;, &#96;user_id&#96;, &#96;amount&#96;) VALUES (9, 3, 2, 66.00);</span><br></pre></td></tr></table></figure><p>大概就构成了这样一个表</p><table><thead><tr><th>id</th><th>room_id</th><th>user_id</th><th>amount</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>99.00</td></tr><tr><td>2</td><td>1</td><td>4</td><td>80.00</td></tr><tr><td>3</td><td>1</td><td>2</td><td>28.00</td></tr><tr><td>4</td><td>2</td><td>2</td><td>77.00</td></tr><tr><td>5</td><td>2</td><td>1</td><td>66.00</td></tr><tr><td>6</td><td>2</td><td>5</td><td>98.00</td></tr><tr><td>7</td><td>3</td><td>1</td><td>55.00</td></tr><tr><td>8</td><td>3</td><td>3</td><td>98.00</td></tr><tr><td>9</td><td>3</td><td>2</td><td>66.00</td></tr></tbody></table><p>执行SQL查询<code>room_id</code>为1的记录<code>SELECT * FROM tb_test where room_id = 1</code>，根据猜想，查询出来的记录应该为：</p><table><thead><tr><th>id</th><th>room_id</th><th>user_id</th><th>amount</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>99.00</td></tr><tr><td>2</td><td>1</td><td>4</td><td>80.00</td></tr><tr><td>3</td><td>1</td><td>2</td><td>28.00</td></tr></tbody></table><p>然而实际上是：</p><table><thead><tr><th>id</th><th>room_id</th><th>user_id</th><th>amount</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>99.00</td></tr><tr><td>3</td><td>1</td><td>2</td><td>28.00</td></tr><tr><td>2</td><td>1</td><td>4</td><td>80.00</td></tr></tbody></table><p>可以看出，查询的时候主键乱序了，查询的结果是根据<code>user_id</code>排序的，而非安装原来的主键排序</p><h3 id="猜想">猜想</h3><p><code>tb_test</code>以<code>room_id</code>和<code>user_id</code>建立了索引，查询的时候使用了<code>room_id = 1</code>的查询条件，复合索引的最左匹配原则，所以使用了索引<code>tb_test_room_id_user_id_index</code>进行查询。</p><h3 id="证明">证明</h3><p>使用<code>EXPLAIN</code> 命令分析一下上述SQL：<code>EXPLAIN  SELECT * FROM tb_test where room_id = 1</code></p><p><img src="https://cdn.inkdp.cn/img/20220601010601.png" alt="image-20220601010601200"></p><p>根据结果可知，确实使用了索引<code>tb_test_room_id_user_id_index</code>，而索引中，默认使用<code>room_id</code>和<code>user_id</code>进行排序，所以就有了主键乱序的情况。</p><h3 id="解决">解决</h3><p>如文章开头所讲，添加<code>order by</code>即可，在所有你期望有顺序的查询中，都应该加上<code>order by</code>来进行排序，以避免上述情况。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go结构体组合排序</title>
      <link href="skill/back-end/14370.html"/>
      <url>skill/back-end/14370.html</url>
      
        <content type="html"><![CDATA[<p>  排序是开发中不可避免的，go的标准库<a href="https://pkg.go.dev/sort">sort</a>提供了这一功能，主要针对<code>[]int</code>，<code>[]float64</code>，<code>[]string</code>、以及其他自定义切片的排序。对于前三个切片基本没有可说的，而对于用户自定义切片，就需要我们自己去实现它的排序了，实现<code>Interface</code>接口再调用<code>sort.Sort()</code></p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewInt []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NewInt)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NewInt)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n[i] &lt; n[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NewInt)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   n[i], n[j] = n[j], n[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   n := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;</span><br><span class="line">   sort.Sort(NewInt(n))</span><br><span class="line">   fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写虽然规范，但是略微繁琐，大多时候我更希望简单一点，使用<code>sort.Slice</code>可以简化上述代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">  &#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按年龄降序排序</span></span><br><span class="line">  sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &gt; people[j].Age</span><br><span class="line">  &#125;)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Sort by age:&quot;</span>, people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的好处是简化了许多内容，但是不易于后期维护。</p><p>  上述方式实现了一个对结构体单字段的排序，核心在于自定义函数<code>Lees()</code>，思考一下，我们能否实现一个基于多字段的排序呢，类似于mysql的<code>order by</code>。当然是可以的，实现起来也很简单，当第一个排序索引相同时对第二个排序索引进行排序即可，示例如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  people := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">  &#125;&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Gopher&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Vera&quot;</span>, <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 按年龄降序排序,年龄相同的按姓名</span></span><br><span class="line">  sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> people[i].Age == people[j].Age &#123;</span><br><span class="line">      <span class="keyword">return</span> people[i].Name &lt; people[j].Name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> people[i].Age &gt; people[j].Age</span><br><span class="line">  &#125;)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Sort by age and name:&quot;</span>, people)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《实现领域驱动设计》阅读笔记一图流</title>
      <link href="reading/39342.html"/>
      <url>reading/39342.html</url>
      
        <content type="html"><![CDATA[<p>第一次用思维导图的方式记录一本书的阅读笔记，感觉还是不错的</p><p><img src="https://cdn.inkdp.cn/img/20220415114905.svg" alt="实现领域驱动设计"></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年终总结</title>
      <link href="/2021.html"/>
      <url>/2021.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="41add14282b6877ec0d24df8639f99bb83556a5ebd4fafbaf0f9feba146b0302">b9cc9643baf4dcc59b37da2f24103eaccefe58073ae15acb17a69c6037edc4686470b4bafa04e564bf9dc1aed95843f1fd983148fcdf6a86f206fefedae917809a05cca621454f43eafc65035cffcabbac53454d1db7886e1f83f5f2092d547ea97cbb16cc68f117cc16b5bb1aad14868bbac0356d7f9d02b2c13d8b9cf058abf1053134f4bbc407b4cf8775f31ed376cb9404a248fc0e2f6888cd42a2326df8bcb01035b373cecffa210f38ef8b13a1aa95deec8f1ac0e77e4c052e65cc2b5cac5d5b1c8b0a760d73b02c5089e01ed788cebc97e429166adf183c48398d34c90b14499f464a0e7dad68773637bdaf676287b1fd91f530aaa56fc4640374f9804dbabbf318683068f3f17f46f522b97fcdaaadfd42e10af3da0998e5e74cd4ca453f7a8197de44375b2b1b08f4ba0f0eada89e0ce630902ff4b40118989e6c858a66c8d317056b426deebcc1a363c0c5e5c6c80bd4dc5086e2f7d4c2d41feb38325e21dac939b7dda394bb4bed5de52c62b71294b1f2332b2ea3a3644ece9d8969286b614876e829c4a382facd513d37a3f29294c5d6dff5beb91d8c6a837da3d915ab6d65f1478c74ebf63aa93ca59ec542208222b56782a86c3111c27734fc7387833c2b936346930ac0e66ca7247350abc6136f8ce945bdee0a455a62ab7449e4175582fe3ba6b51010407420aee60a8019d9988841831da354cc61752c3ef3e14a9b8208d1d3589b4876724927b6387ad87a705e3590da4ed567bfee5d8cf340a3977f5a454d9d4d940552be41ebfe14bcb95d25aec7a366cc59b4612120b7510813d77128f6ff9c7edff4bb951f05ce5162302cac429150ac266607ca51a013d4a10f55c13f5a387b611f91128bf11565c4085aba88ad2e55ace86846750414831d68175a98f5ffe7f8c5d6cde330f0b3f72a33ee05d363a71ff6aeb45502aadcca54e8621ebba852d18e02635b460c73953a4e117de470093e2b7bd84d951a1d00007396e3a009ae1b000daaafb2368e19ff4c618f8cd780ba72df56bba0d32982c89ddfbef9eeaf52462ab54e312dacba1e3602c35f6b88a81a16539f5752171e0f0af7c7a52b69459e928fd3d911b52d29f8e57a8efbc0092ff2ed55a6ea16e2f6b3227ff0fbb166e285ddfca2d2683d82112c7da8e513bc97bf2746f03d7864a330d933f6b163e6d09c7a3909935722abf0fdc1630e961c651ad65928e58ff91485cd6dadece8cde0435b8db883c63ff6242db9d0a68cc85549fd50e32ffb7dfece379e9dc13ed7c1f216f42b033c5bd3c359bba806afc5c16f55a43ba0672b14247ea29fa8c005e4a6a8acdddd98a654a4763473a7dbfd9f00e07696470bada7602c18fee9d3fe51a8180034ec80d9db64fdc618b8850f200f2df4233e8b017f65206350da38c35646b6c50d9e80cb2033bbeba363d9531e58b9fcab43613d1682c92889607ae373526d27e87c4a85d548f1e187f25e89999ebc8400289b328dcafa903744d5738a69f29128d86dcde0ee96e8d19d2ae963d1e53c7212b0b40076d123307a39d7d458be5c76b4c69676592fbb049daaf821637297a74b88ce50b20bbbff1cef405eac47f8215f91300e03754cfa04a8b9758251e67e9e60af06c2f0fdf7efd11784171a7c5b7f14446b551382d3a611c299288c00b41b63b67b49cf76f8727d792cbb3909e9298f47a404d083a254c788789db96fa8ee715143e1d33604a6072a27f34d674c6aff30d8651bbcb2d90f57036af8b228f9df00b1e11e01685cfd01b62d90c812942763209df49c9262e7ded229f96a37c7a1ff0f5ad8c9ca82090fd7807c828d2092c820a0cbe16837f473e075ba239302f54a5acf065eeedbb9e2fb79b3672c95da0e4e7b13df989ff7a16f0143a7d338d38fd2efbb9d041492c3924c51844c46572e0fb1e6124b13018362237faab68afb764547554fc998e645103e41a9751aad5582cfd635a283ddb5b1c86bb983f548cc661cb6f3d7595f99443412a284246186d9b08d32d13a189d9d78ebf5a1f0a3e7618f3f80967af8567a6d2a1e36e77264c9ecf29ef1a0f7f318a14f3b5a72b1e7263bb96d8c8b717ab560eccf2aedb7fc05ebf2eb4c8675fe100ed5880ec8ff9ff5c90140144655b3991be6d2739885e2764a60e45e1c8361ed72f1d39f7b7e9c8e93f269f5b2b6b5a22772e023baec51f46bff30a017c6dee0b6962e0ac13cc372144e2d2507a19c6d1fcfe0869820b91d4e28d4cf21277a44fd95a4efad42afbee32e9f1d4bceb3e8375ac343a5e453576dfd3b81034e44cbdbbe4a1158017a49f46e5fa9dbc95e4aa1155a22dc245004baf8d8a7e424f642caad8c222059e0590ca57b3a06e99414f1dfbbbb64d8ac0044a05959e2a713d88cd5c60217a2d4c7ebb2b10015293124f8189cac411d961d9e6ba2ecc2aee8d52eab753a52b1ce1c7666d203e7279754419e39d8cf6b796fb66d4d19c171e1fca96e634637aafb0375fc27bd3cd04c77a1088c3d916f453cec32d577bedf272713c2994805074675cdaaba7baa557fa233d51aa191086aa94cd1f0b10ab18fd7254924f8d11f95d565ab63c556ee661edcc40c51a24d8a4f5f6961e333ff44aa8c7df0bfd2cd50dab988e11098a92db6cc1455e0573fe8041d2e8f97990a18517e3a676149e33080e24d33e5a459705d7b5df97b122ab2f6275ca43937dfb3a9807e049f304a1f11a623a5a8b06e3eb59f9396bcfe3df30b6b8bfeeefc31b7e141cfefa1a0fcf2ba683d9a3c0e019746d2e4a2b9eea4680df97652695b48b3dd9566ce8f6c0c1468742405c53d47eaae9614bb5c7398d041dc3757b892f9695a89cab60527d09c335ede1a34485545146756df661e883ae9f3cd8a6da5d70af45c90cab47836b4a59eed9110457eb86ac5a2774aa532f33e3c50e9d417eca0417196f5cb076368dd75740a074402a8c17c962f0f75eb698e4128147c8e66a7cca65d1bb23bbe53f9d54e01cc1e7cf7507a6fe607a5d52f4c39363828c3918f41ce6a25fa11acdd1bd5f4a32c7757646e317d232fe695dc9571c6a2ab4fa1ee04eb776aef5d853b6d4413c382edff600d04557fb4ad2fbbbe490c474b91ac0a1dcefcd8c225d1cc18b7f4eb91b5c0ddf1f4cdf0b59096476c9bf2bf0c3494b18b5aa85659a50e730bb8fecc4dd6fda9ed007aec4bc317988a69cdcf64435b3ca2989306a9ac382cd516cbd538a7e5ecfcb495df79b02f46e53a212efb51f0539842e369f88c64780be71a3e8d86cfb5658677b553d87d1cf2d6a2d22c96af36752b7b1322298d98db60faffc59ebc67b5dc32510e1f998e6e7fbb25852886a8fceaf7ab74bdab2490db5d33fccac1f0a17ad5147dbca5209a6a504db0d9e0f50acf87146da7d0cf90ea991d306a317bed8404f65c450c67a28d810e1797ea04464c2d1a85100f15ffaf867c8e712af61a45f97fee56608af50bdead988c9a77a9ddac5d562ba3d6e8aba27ccea69f6113364440a5ee58bc7806922d81f9d771e06bc6b241d5874ac0838a4e544ab0f4c478b0ef1ce7a6729744491cc094cfc0491b33cf7eb9ccc9a12e9a4f276f5a3860f33779d32e1307c364b81c4f4a55c05a29b0ee6ddc10c0fa11b54fe2d1112f65e182bdebfef5e0017b912a2543cf6a9d97b68c4ecfac74e01faef6c39182bb44189d9704df163e4f2df5bac5ab391bca482307d3b9591798c54dc253a659d2fd6dde2fcaf6cf77fe5b3f185693840cf5bda5fb00bb0f636e0a9c96325c34c412ec95dc51502350ddae590a1b5dd8103fcdb96a14957a60e413d3528a7ff30adef002f8c9aefa68125d2be60bc347e2024b2fcc43c9f912a056452657d375bd7974d052d9c9c2121912a272cf31aacb805ddcef9d34d30368876b59442c907f4745ea1734aaf5d258d9e41e37dbcf535b87bb1fe835c5eeb021ee977127a6d13142ff8386daee83a1ffdd1f5e967171582294bb97118efeb6b303badaaf04054eef36b903ac63e5a0d443675e3b653ae655eb13f742fb900b831760f4f7ba201b2fd61aa3c40ca9732146a6e8acb547dc0433ffd1e56491e4f075b31e173a67d750fe64e7ab04f7c078c0612b7b16c28f0734910f18c41c282d10220ff2c732509d39f5c4b14a263d0fb521ccee7f53c97e8ec3655188c1d0c797b16cd4947b3f506b6f1aede944b324179fdfebee195aa8c7dcc785b0ef433d87a8ea5581d7b101238d257490ebf43de973206c227ec40b2863794bd7277d4eeb603bc613bc89c899159bda2ac0b798090601d308ffdc2b32c92680b58c93b11dda8074ac41545ccd4ff83315dadc276c19c005de6dbe521129a8e88cff1b428351ed31456ee99adbdb26ccee0538d77e10960319a63eeae8ed158f74605c6c96bdb7f5e8420c67017cecbf75d47dd1a41aedd2df122d42df69bfdacb25f970bd567c1dfba101df5430359e94e9bcd2de860689390ca999552b2117bfcd59843f0feab9212acfe2980cabd3565139e9b993f2499f6886bfcb75be29371f223ae9efd1a030b59ecc86de89cf9a1f4ad08533e5c54f0a26ce5ff2af3f92418fd09b96c4ceb921b44543a4b2c896bd921fdb9593f60ebbc3daa97b18721b555f061c5d5f22406f25e016d992eeba4c901d1b666099682d6aed600d82594698768de7d0eb673cca7c660e3cfff3280dce6f44318726d95619f9151a678e450b5daa46cd7a1a329a4ad76fd4c36bfd9ef33e1ce8a8ecdef15e4be75de8d11fe715d86b915b9b72fd2ead6a6bc929f0b90c05d3251af5e13dd7ae8f7f0023d61133d9fc3899132f9560e38d3fea8699ffff551e396b78fd0807c2b71d09833fc01a6d1d778ff6606a414ada11783b4093f4802677e2f55acca3fbdaace907ab0ef25f47bcfe320523c81e1307c5825441a0334c20d5ada1908a7ac030fc8e037ca9dfe42bd88e217da30a8cea054a5905699d7d03242d83232770f98f4290ab9ae4495835af033371520f75b8ccb5b62bfa10ea1b4bd077048a20be5cc4ea540c8f0e124f576548c306796f0d5b2a703891337354c3e14d58a70123a26afdbd2f14d96a4465cf4de8d0cf7895d264ad12990d2e75d99f622deb22a5894086dfc546ca402643fe512b531ada90019570cde0715301104c33a54672afb728280c08ff7c8eab0a2b0887b28d2a9d3bbffd885c365f82fd06570d63fa1c53130aa787c1ff3ee1cb00c2c042475037896cff9bf98f89485374a9ff712e298289187d27717b2e3208bfe57845c9cb18a32c9b07ead5093cea696f15f8f8b6db89ed3851fe3e4c0f2a16375720ceb799943356b020a463b683419aaefcb7e8f2005d58bcdcc7c7a399ad0e17f5382b9659dcc286a65c83b3fe6d8ef037e30ac30b253921d19904952da9877a73c6c4c1bb8b37e8bf16955fec36a8d8faba4d9ff336e9235d5293e525a20e7c1c78661a2c6084e6271e90cd7d07350b4e28c5a48de0d87487b0af68874270f09cda0730d3a540a1ccc9299e3dbb654de4cef811704521dc3ee79f8b3af89e0f010babb717f089cec0179773f671455f4063954addd57ca8756b58b34258bfc7cbf5ce61e3a687e113cae0ee4fdf8427c824bcca3614c3ddfdeb9950e1f2b82a453f63ad76220548ab24aa39bf464a258b5160b54de94cd8378e0970123f0cbfdbb0480fa52a61a945d6637ff3dc3607aa9b9b9e0d2e348fa7cab8bb9c91e102ec6d8dfed136db5248c540b07da138aed966d26f7100162ade40be37aaf7125391692120e363b12f1978da9dc6388108184d67f4ecdf46ac488c4369f9354e3ea1bdc491c4e31d3d974f9abc1e42096fd745ec8ed706d902faebc7a702e8dda69d034f4ddc35d8d1972cee6773ff1683148efb920e622dc4e2284da29b63ca73df6079e045d5e0088c2aeec8ef32f3a4152817a2d543348481e8499c9932d7bb0be67d79d076b0536e134c5fb371ec724f742de8767ecc4e39130c6ad0e9a9511b9b2977bb9112304ceb055a8fc2e7907d82feb10176f84eb52ed8dfc90228dac114522ed6addbdc5871be55cb81edf42c939032837d8e0ca8303a645d52fa05d2cbed6940f01c481687ba46fb4c00ca3f320977a42c533cb14e78e3acb19920179f4d73df1d10a5dd308e13c8a5b1a8ea11fd807ef7e7e2848607edd3b0acb6a812f1016616b8fea4cf055e32f3648c87fef630af56402a70d95cb94d74d9f4f27740e027e7e1bd0e01e4a4e0edbac8765debeb3c4b7200776b2b5386b134cc88de8313f5ae73fed1444873aaf30692bc0612537009bd7a6c5d5c203f4ee65f6b78154bc9f65c7415e5852919540369e9008fa45fbe1c8c3ce5226bf72fe62532859d3795e39e0e84f8af43a4b04c34d74ee9dc9537d3ecec13038627131fb16c6a1c357b1ece3d5410729b08d3a6b67d1f0126ff7e32af9fb5e19cdb621e8a68adcb0d4455a58003d0321f88eb44683ab7577bf233521865b1f35260c1c7ecbbb7eae979094066439babcdddf15d53bdc16e05b30a57899297ac666c75b0d2be0ba06acc298a1badd3dfa4923ecd51a70c36252e28add0199bfaf3fa8435b17afc239366cf3ba2a5653ed13c71307b4bad7a610ad640ea5bd280fbaeb97eb77983c87523fef8c54fbe6ec4841cab51090087e49dbdc1b72117ac2dcda357cf2da3a24a58d80e04c5f8be2177517e099ab570da6ef811078d8cd64dfcdda2e42f4375f9eece644a8f8be7019d64ae5224d957f0377c5e89724b369ec381a11931be4db3402a377a6bea111b106d9e5b3fb42b024a5ae18b386d8c74d8a0cb5434209c23877199092f112a49d4ff47f6afd65a7f1be1b8feb80a01ea2a7ce893843db421d8580b0d4b60e894a7105aeb7e7d602b3c1ef19906579243127241d26e13eaf30ab64a38077540943bce89b362c500a94700b1aa73a4f6c86ce8942f310946e0d2dfe59b3e558fcfe5d4778679e55df14cdb2d4f13dfa82c97dd12bfc992941d0f7d875c62ef6a57197751768b4a11f0888c0ef25b0ff0953307ddd90e35f58c92de76c776e44d6ec8a555c6684a5824b1bd78e15583aa414a656d2f8dbde691c90524ba28ab7a6b2e165a6e903888f0881a1bc9474dcf5169de146aca7477eef73eaf64d9d8ca55cf735e34394157ac926a643c5a01748aeec5ff4976ab7d2d8586988e02e7515eaffc45e9a45908cf687e4d55957779e808b6e9c08b63465a16bff7cdbaf81672eae1cabf939291166d86500b7b0c175c6eb9257170e1cb87a89ead1c9f1fd3574ca0a0f2cb4ad93b7c79a8c261b4c14b5907391dc1dac9b1a665ab257ec58c0b67d2217686a8917150c3f465ad3f33b0e9463aeb6a43720fa6a442efdd16cf0f7c53e04652f3326e6cdfe190cc37446090928f4f7ccaf79137622f7129fb3e14f91d6f370540afbe1a92281191f7b62ccf92779a58cda9cd1d668432898c9b130b1edf7eeddb5f6a314d9d93827aea47bec7623169fc6b32bd13b0da2fc59192a8558218721508a1901e14db259026ba2d290f670321344144ff31ef3ac98e2d7a4734526984fba3d05f7102660074f6ee4c4c9f1a4617a9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次MySQL查询优化</title>
      <link href="skill/back-end/12472.html"/>
      <url>skill/back-end/12472.html</url>
      
        <content type="html"><![CDATA[<h3 id="起因：">起因：</h3><p>  快下班的时候被同事A叫住，说是某个连表查询导致整个程序卡住，连Debug都停止了，让我帮忙瞅瞅，本着乐于助人的精神，我爽快的答应了。</p><h3 id="排查：">排查：</h3><p>大致代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCustomerInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    db.Select(<span class="string">&quot;.......&quot;</span>)</span><br><span class="line">db.Joins(<span class="string">&quot;LEFT JOIN customer_info ON customer_info.customer_id = customer.id&quot;</span>)</span><br><span class="line">db.Joins(<span class="string">&quot;LEFT JOIN customer_group ON  customer_group.id = customer.group_id &quot;</span>)</span><br><span class="line">db.Joins(<span class="string">&quot;LEFT JOIN vest_customer_relation ON vest_customer_relation.customer_id = customer.id&quot;</span>) <span class="comment">// 新加的代码</span></span><br><span class="line">    ......</span><br><span class="line">    err = db.Debug()Order(<span class="string">&quot;customer.id DESC&quot;</span>).Limit(limit).Offset(offset).Find(&amp;customers).Error</span><br><span class="line">    <span class="keyword">return</span> customers, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  因为同事A的描述是加了新的连表导致程序直接卡住，再加上打断点调试时都是走到最后一步卡住，倒也没有考虑可能是SQL的问题，甚至觉得是Gorm里面什么奇奇怪怪的错误导致的(原因大概是因为<code>Gorm</code>的<code>Debug()</code>没有触发，后续猜想应该是需要语句执行完毕才会打印出对应的SQL)。</p><p>  因为上诉排查无果，也猜想到可能是因为慢SQL的原因，所以随即手写SQL测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;customer&#96;</span><br><span class="line">LEFT JOIN customer_info ON customer_info.customer_id &#x3D; customer.id</span><br><span class="line">LEFT JOIN customer_group ON customer_group.id &#x3D; customer.group_id</span><br><span class="line">LEFT JOIN vest_customer_relation ON vest_customer_relation.customer_id &#x3D; customer.id</span><br><span class="line">WHERE</span><br><span class="line">&#96;customer&#96;.&#96;deleted_at&#96; IS NULL</span><br><span class="line">ORDER BY</span><br><span class="line">customer.id DESC</span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure><p>然后，很久过去了……。这是一个慢SQL确认无疑，不过另我好奇的是不过多<code>join</code>了一个表而已，为何会这么夸张，让我祭出大杀器<code>EXPLAIN</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM &#96;customer&#96;</span><br><span class="line">LEFT JOIN customer_info ON customer_info.customer_id &#x3D; customer.id</span><br><span class="line">LEFT JOIN customer_group ON customer_group.id &#x3D; customer.group_id</span><br><span class="line">LEFT JOIN vest_customer_relation ON vest_customer_relation.customer_id &#x3D; customer.id</span><br><span class="line">WHERE</span><br><span class="line">&#96;customer&#96;.&#96;deleted_at&#96; IS NULL</span><br><span class="line">ORDER BY</span><br><span class="line">customer.id DESC</span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20211208215724.png" alt="image-20211208215724805"></p><p>从上图不难看出对于表<code>customer</code>与<code>vest_customer_relation</code>为全表扫描，<code>customer</code>倒是理所应当，但是对表<code>vest_customer_relation</code>也全表扫描就属实有点离谱了，因为Mysql默认连接方式为<a href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF">笛卡尔积</a>，所以上诉SQL运行时扫描的数据为<code>33437 * 2 * 1 * 64686</code>，大概<mark class="hl-label red">40亿</mark> 的样子，而且据我所知，同事A的业务要写完还需要连接一个表，无论为未写上去的表被扫描的数量是多少，后续的增长都是以<mark class="hl-label red">40亿</mark> 为单位，这都是一个非常可怕的数量。</p><h3 id="解决：">解决：</h3><p>  仔细观察<code>EXPLAIN</code>的结果得知，表<code>vest_customer_relation</code>是没有索引的，所以每次连接表的时候都会去全表扫描，这才导致了一次查询扫描了<mark class="hl-label red">40亿</mark> 条数据，为表<code>vest_customer_relation</code>加上索引即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;gva&#96;.&#96;vest_customer_relation&#96; </span><br><span class="line">ADD INDEX &#96;vest_customer_relation_customer_id_index&#96;(&#96;customer_id&#96;) USING BTREE;</span><br></pre></td></tr></table></figure><p>此时执行上文SQL查看效果：</p><p><img src="https://cdn.inkdp.cn/img/20211208223117.png" alt="image-20211208223117625"></p><p>可以明显看到，新建的索引精准命中，表<code>vest_customer_relation</code>只扫描了一行，总扫描条数也就降到了<mark class="hl-label green">3W</mark> 左右，达到了理想的状态。</p><h3 id="思考：">思考：</h3><p>  到了这里，问题已经得到了解决，但却不是最优的解决方案，由于用户数据增加的缘故，数据量还会继续增加，如果以后每次遇到类似的问题都通过索引来解决的话，显然不是最佳方案，索引滥用也会导致各种问题。业务问题业务解决，我们应该避免更多笛卡尔积的产生，将SQL拆分，通过业务代码将数据组装才是最佳的解决方案，简单拆分上诉SQL得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM &#96;customer&#96;</span><br><span class="line">LEFT JOIN customer_info ON customer_info.customer_id &#x3D; customer.id</span><br><span class="line">LEFT JOIN customer_group ON customer_group.id &#x3D; customer.group_id</span><br><span class="line">WHERE</span><br><span class="line">&#96;customer&#96;.&#96;deleted_at&#96; IS NULL</span><br><span class="line">ORDER BY</span><br><span class="line">customer.id DESC</span><br><span class="line">LIMIT 10;</span><br><span class="line">EXPLAIN SELECT * FROM &#96;vest_customer_relation&#96; WHERE customer_id in (3,4,5,6,7,8,9,10,11,12)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/20211208224854.png" alt="image-20211208224854719"></p><p><img src="https://cdn.inkdp.cn/img/20211208224910.png" alt="image-20211208224910207"></p><p>因为提前删除了索引，所以两段SQL分别扫描了<mark class="hl-label green">3W</mark> 和<mark class="hl-label green">6W</mark> 而已，加起来也不过<mark class="hl-label green">10W</mark> ，后续在加上索引，完全在可接受的范围之类，后续通过索引之类的优化可以达到更佳。取消所有连表，最后扫描的行数应该为40行，这才是最佳解决方案。</p><h3 id="后记：">后记：</h3><p>  从SQL语句不难看出，此需求为一个分页查询，那么上诉解决方案仍不是最佳解决方案，卖个关子，可以小小的思考下。</p><div class="hide-block"><button type="button" class="hide-button" style="background-color: bg;color: color">解决方案    </button><div class="hide-content"><p><a href="https://www.inkdp.cn/articles/2020/10/21/1603213579436.html">MySQL分页查询优化</a></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动编译proto文件</title>
      <link href="skill/back-end/49446.html"/>
      <url>skill/back-end/49446.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>你是否和我一样厌烦了无休止的<code>protobuf</code>编译，是否对<code>protoc</code>的命令深恶痛绝，如果有，那请继续看下去。初接触<code>protobuf</code>的我，对他的各种编译命令深恶痛绝，生涩难记。</p><p>在同事的帮助下，弄了个编译proto的库：<a href="https://github.com/gooohlan/proto_build">proto_build</a>，每次改完<code>proto</code>文件，直接执行就完事，再也不用去输入各种乱七八糟的命令，简直爽到飞起。</p><h3 id="使用goland实现自动编译">使用Goland实现自动编译</h3><p><strong>Jetbrains</strong>全家桶提供了<code>file watcher</code>的功能，可以实现对文件的监听，文件发生更改时可以执行某些操作，这与我们开发的程序结合，即可解放双手，实现自动编译。</p><p><img src="https://cdn.inkdp.cn/img/20210927211122.png" alt="image-20210927211122811"></p><p>下载<a href="https://github.com/gooohlan/proto_build/releases">proto_build程序包</a>，或下载<a href="(https://github.com/gooohlan/proto_build)">源码</a>后编译，打开<strong>Jetbrains</strong>家的<code>ide</code>，这里以<code>Goland</code>为例：</p><p><code>Preferences</code> → <code>Tools</code> → <code>File Watcher</code></p><p><img src="https://cdn.inkdp.cn/img/20210927211053.png" alt="image-20210927211053278"></p><p>新建<code>File Watcher</code>：点击 <code>+</code> → <code>&lt;custom&gt;</code></p><p><img src="https://cdn.inkdp.cn/img/20210927211252.png" alt="image-20210927211252517"></p><p>选择监听文件类型<code>Protocol Buffer</code>，文件监听范围(根据自己实际需求选择，这里我选择当前项目)，选择上面下载或自行编译的运行程序，工作目录选择当前项目所在目录即可。</p><p><img src="https://cdn.inkdp.cn/img/20210927212113.png" alt="image-20210927212113805"></p><p><img src="https://cdn.inkdp.cn/img/20210927212208.png" alt="image-20210927212208720"></p><p>编辑<code>proto</code>文件，查看是否自动编译生成对应<code>.go</code>文件</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发查找切片</title>
      <link href="skill/back-end/118.html"/>
      <url>skill/back-end/118.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目">题目</h3><blockquote><p>假设有一个超长的切片，切片的元素类型为int，切片中的元素为乱序排列。限时5秒，使用多个goroutine查找切片中是否存在给定值，在找到目标值或者超时后立刻结束所有goroutine的执行。</p><p>比如切片为：[23, 32, 78, 43, 76, 65, 345, 762, …… 915, 86]，查找的目标值为345，如果切片中存在目标值程序输出:&quot;Found it!&quot;并且立即取消仍在执行查找任务的<code>goroutine</code>。如果在超时时间未找到目标值程序输出:“Timeout! Not Found”，同时立即取消仍在执行查找任务的<code>goroutine</code>。</p></blockquote><h3 id="思路">思路</h3><p>思路参考：<a href="https://mp.weixin.qq.com/s/GhC2WDw3VHP91DrrFVCnag">上周并发题的解题思路以及介绍Go语言调度器</a></p><h3 id="代码">代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">targetNum := <span class="number">898982</span></span><br><span class="line">total := <span class="number">2000000000</span></span><br><span class="line">s := GetRandomSlice(total, <span class="number">200000000</span>, targetNum)</span><br><span class="line">t := time.Now()</span><br><span class="line">manager := NewManager(<span class="number">250000000</span>)</span><br><span class="line">manager.Search(s, targetNum)</span><br><span class="line">fmt.Println(manager.Result())</span><br><span class="line">fmt.Printf(<span class="string">&quot;find the number of %d, time conumin %v\n&quot;</span>, total, time.Since(t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRandomSlice</span><span class="params">(sliceLen <span class="keyword">int</span>, randNum <span class="keyword">int</span>, targetNum <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, sliceLen)</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sliceLen; i++ &#123;</span><br><span class="line">randNum := rand.Intn(randNum)</span><br><span class="line">tmp[i] = randNum</span><br><span class="line"><span class="keyword">if</span> randNum == targetNum &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;randNum is &quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">s         []<span class="keyword">int</span></span><br><span class="line">targetNum <span class="keyword">int</span></span><br><span class="line">chunkSize <span class="keyword">int</span></span><br><span class="line">chunkNum  <span class="keyword">int</span></span><br><span class="line">once      sync.Once</span><br><span class="line">ctx       context.Context</span><br><span class="line">cancel    <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">result    <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(chunkSize <span class="keyword">int</span>)</span> *<span class="title">Manager</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">return</span> &amp;Manager&#123;</span><br><span class="line">chunkSize: chunkSize,</span><br><span class="line">once:      sync.Once&#123;&#125;,</span><br><span class="line">ctx:       ctx,</span><br><span class="line">cancel:    cancel,</span><br><span class="line">result:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Search</span><span class="params">(s []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m.s = s</span><br><span class="line">m.targetNum = target</span><br><span class="line">Chunk(<span class="built_in">len</span>(s), m.chunkSize, m.Worker)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chunk</span><span class="params">(total, chunkSize <span class="keyword">int</span>, f <span class="keyword">func</span>(part, startIndex, endIndex <span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> total%chunkSize == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; total/chunkSize; i++ &#123;</span><br><span class="line">e := (i + <span class="number">1</span>) * chunkSize</span><br><span class="line">f(i+<span class="number">1</span>, i*chunkSize, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= total/chunkSize; i++ &#123;</span><br><span class="line">e := (i + <span class="number">1</span>) * chunkSize</span><br><span class="line"><span class="keyword">if</span> i == (total / chunkSize) &#123;</span><br><span class="line">e = i*chunkSize + total%chunkSize</span><br><span class="line">&#125;</span><br><span class="line">f(i+<span class="number">1</span>, i*chunkSize, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Worker</span><span class="params">(part, startIndex, endIndex <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m.chunkNum++</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> m.s[startIndex:endIndex] &#123;</span><br><span class="line"><span class="keyword">if</span> v == m.targetNum &#123;</span><br><span class="line">m.result &lt;- fmt.Sprintf(<span class="string">&quot;Found! At index %d\n&quot;</span>, (part<span class="number">-1</span>)*m.chunkSize+i)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m.result &lt;- <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Result</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * time.Duration(<span class="number">10</span>)):</span><br><span class="line">once.Do(m.cancel)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Timeout! Not Found&quot;</span></span><br><span class="line"><span class="keyword">case</span> res := &lt;-m.result:</span><br><span class="line"><span class="keyword">if</span> res != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">once.Do(m.cancel)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">num++</span><br><span class="line"><span class="keyword">if</span> num == m.chunkNum &#123;</span><br><span class="line">once.Do(m.cancel)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;All Task Done,Not Found!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考">参考</h3><ul><li><a href="https://mp.weixin.qq.com/s/GhC2WDw3VHP91DrrFVCnag">https://mp.weixin.qq.com/s/GhC2WDw3VHP91DrrFVCnag</a></li><li><a href="https://github.com/cuteLittleDevil/-">https://github.com/cuteLittleDevil/-</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-递归</title>
      <link href="skill/algorithm/64723.html"/>
      <url>skill/algorithm/64723.html</url>
      
        <content type="html"><![CDATA[<p>递归算是简单而又常见的算法，但是大多时候我们也只是能看懂他，而想要掌握他还是需要一定的技巧</p><h3 id="递归的三大要素">递归的三大要素</h3><h4 id="第一要素：函数实现功能">第一要素：函数实现功能</h4><p>对于一个函数，最先清楚的应该它说要实现的功能，也就是它要干什么，这个完全由函数定义者决定，所以，我们不应该最先思考里面代码怎么写，而是应该先思考，你这个函数用来写什么。递归也是一个函数，所以需要遵循这个规则。</p><p>例如，我们定义一个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求1～n的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能就是求1～n的和，到此，我们完成了函数的定义，也明确它实现的功能。</p><h4 id="第二要素：寻找递归结束条件">第二要素：寻找递归结束条件</h4><p>递归就是在函数内部不断的调用这个函数本身，因此我们必须找出递归结束条件，否则，这个函数就会一直执行下去，成为一个死循环。找到结束条件，递归结束，并返回结果。根据这个结束条件，我们是可以直接知道函数的结果的。比如上面的例子，当<code>n = 0</code>时，你可以明确知道<code>sum(n)</code>的结果是什么，此时，<code>sum(0) = 0</code>。将第二要素添加到代码中，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求1～n的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细思考，发现<code>n = 1</code>时，也可以直接得到结果，所以我们将他们合并，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求1～n的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归条件的定义必须要足够严谨，否则就会出现漏算或者多算的情况。</p><h3 id="第三要素：找出函数的等价关系式">第三要素：找出函数的等价关系式</h3><p>第三元素是需要不断缩小参数的范围，缩小后，可以通过一些辅助变量或操作使得原函数的结果不变。</p><p>上面的例子中，<code>sum(n)</code>范围比较大的时候，我们可以让<code>sum(n) = n+sum(n-1)</code>，这样范围就从<code>n</code>变成了<code>n-1</code>，以此类推，最终范围会缩小至我们第二要素的递归结束条件，并且原函数的结果不会变。</p><p>我们最终需要找到一个与原函数等价的关系式即可，<code>sum(n)</code>的等价关系式为<code>n + sum(n-1)</code>，即<code>sum(n) = n + sum(n-1)</code></p><blockquote><p>这个等价关系式的寻找，是整个递归中最难也是最重要的一部分，暂时不懂没有关系，多找一些递归相关的题，多练习熟悉之后自然就手到擒来了</p></blockquote><p>找出了等价关系，将它添加到函数中完善函数，完整函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求1～n的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n + sum(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此递归三要素就全部写到函数中了，这个求和函数也完成了，每次做递归时试着将这三要素找出来，你就会觉得递归变得很简单。</p><p>还是不懂没关系，下面我们结合案例讲解一些题目。</p><h3 id="案例">案例</h3><h4 id="leetcode-509-斐波拉切数">LeetCode 509.斐波拉切数</h4><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><blockquote><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</p></blockquote><p>给你 n ，请计算 F(n) 。</p><p>结合上面的说讲的，是从三大要素入手</p><h5 id="第一要素：定义函数">第一要素：定义函数</h5><p>定义函数完成该功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波拉契数列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二要素：结束条件">第二要素：结束条件</h5><p>通过观察可得，当<code>n = 1</code>或<code>n = 2</code>时，我们可以轻易知道结果<code>fib(1) = fib(2) = 1</code>，所以递归结束条件可以为<code>n &lt;=2 </code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波拉契数列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三要素：等价关系式">第三要素：等价关系式</h5><p>题目中已经给出了等价关系<code>f(n) = f(n-1)+f(n-2) </code>。大多时候我们都是需要自己去寻找等下关系式，这也是最难的一个环节，因为题目中直接给出关系式的原因，所以直接写到函数中即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单吧，一道非常简单且经典的求斐波拉契数列就完成了。</p><h4 id="兔子跳台阶">兔子跳台阶</h4><blockquote><p>一只兔子一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><h5 id="第一要素：定义函数">第一要素：定义函数</h5><p>定义函数完成该功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兔子跳台阶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二要素：结束条件">第二要素：结束条件</h5><p>第二要素要找到可以最直观知道结果的<code>jump(n)</code>，当台阶数为1时我们可以很直观的知道，小兔子只有1种跳法；当台阶数为2时，小兔子也只有两种，再往上就不符合最直观的逻辑了，所以我们得出结束条件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兔子跳台阶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三要素：等价关系式">第三要素：等价关系式</h5><p>每次跳可跳一个或两个台阶，所以每次跳的时候又两种跳法：</p><ul><li>此次我跳了1个台阶，那么还剩下<code>n-1</code>个台阶没跳，所以剩下的台阶有<code>jump(n-1)</code>种跳法</li><li>此次我跳了2个台阶，那么还剩下<code>n-2</code>个台阶没跳，所以剩下的台阶有<code>jump(n-2)</code>种跳法</li></ul><p>所以兔子的全部跳法为两种跳法之和，<code>jump(n) = jump(n-1)+jump(n-2)</code>，熟悉吗，其实这就是一个斐波拉契数列。至此，等价关系式也就出来了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兔子跳台阶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> jump(n<span class="number">-1</span>) + jump(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单吧，下面来一个稍微复杂一点的</p><h4 id="汉诺塔">汉诺塔</h4><p>从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数</p><p><img src="https://cdn.inkdp.cn/img/20210915232257.jpg" alt="img"></p><h5 id="第一要素：定义函数">第一要素：定义函数</h5><p>定义函数完成该功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉洛塔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hanota</span><span class="params">(n <span class="keyword">int</span>, A, B, C <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个函数来打印移动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印移动情况</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(n <span class="keyword">int</span>, original, target <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   m++</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第%d次移动， 把%d号盘子从%s移动到%s\n&quot;</span>, m, n, original, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二要素：结束条件">第二要素：结束条件</h5><p>当我们只有一个圆盘的时候，直接把圆盘从A移到C即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉洛塔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hanota</span><span class="params">(n <span class="keyword">int</span>, A, B, C <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">      move(n, A, C)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三要素：等价关系式</p><p>假设我们只有两个圆盘时，正确的移动步骤应该是：</p><ol><li>将第一个圆盘，从A移到B</li><li>将第二个圆盘，从A移动C</li><li>将第一个圆盘，从B移到C</li></ol><p>此时回到我们有N个圆盘的时候，我们将<code>[1, n-1]</code>个圆盘看作一个圆盘，这样我们就可以以两个圆盘的移动方式对待：</p><ol><li>将<code>[1, n-1]</code>圆盘，从A移到B</li><li>将第n个圆盘，从A移动C</li><li>将<code>[1, n-1]</code>圆盘，从B移到C</li></ol><p>此时等价关系式就出现了，<code>hanota(n-1, A, C, B)</code>与<code>hanota(n-1, B, A, C)</code>；不同于斐波拉契数列，他的关系式不需要返回，且有两个，但是大同小异，只是稍加变化而已。写进函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 汉洛塔</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hanota</span><span class="params">(n <span class="keyword">int</span>, A, B, C <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">      move(n, A, C)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// [1，n-1] 从A移到B</span></span><br><span class="line">   hanota(n<span class="number">-1</span>, A, C, B)</span><br><span class="line">   <span class="comment">// n 从A移到C</span></span><br><span class="line">   move(n, A, C)</span><br><span class="line">   <span class="comment">// [1，n-1] 从B移到C</span></span><br><span class="line">   hanota(n<span class="number">-1</span>, B, A, C)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三道题更前两道似乎不太一样，没有求和，也没有返回，但这确实也是递归，多假练习加以熟悉即可。</p><h3 id="递归优化">递归优化</h3><p>因为递归是不断的去通过子函数实现最终的功能，如果不进行子函数的优化，就会导致重复计算，我们以上述斐波拉契数列为例</p><p><img src="https://cdn.inkdp.cn/img/20210915230414.png" alt="image-20210915230414278"></p><p>求<code>f(8)</code>的过程，从上图可知，出现了3次<code>f(5)</code>，4次<code>f(4)</code>。。。。当n越大，里面出现的重复计算也就越多，优化还是很有必要的。</p><p>将这些可能重复的计算值存储起来，如果已经计算过直接返回即可，就无需重复计算，以此节省很多空间，优化后代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波拉契数列</span></span><br><span class="line"><span class="keyword">var</span> mapFib = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> v,ok := mapFib[n]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> v</span><br><span class="line">   &#125;</span><br><span class="line">   mapFib[n] = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">   <span class="keyword">return</span> mapFib[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021书单分享</title>
      <link href="reading/65135.html"/>
      <url>reading/65135.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-白说">1.《白说》</h3><p>整本书通过整理白岩松老师多个场合的演讲而来，涵盖多个领域，时政、教育、改革、音乐、阅读、人生；书中说表述的大道理，于20出头的我来说，过于高深，大多都是智商盲区，以至于几乎无法消化，虽生涩难懂，但却能从字里行间收获一种宁静，引人深思，同时从文中也能感觉到白岩松的博学。也许多年后重读此书会有更深感悟。</p><blockquote><p>幸福可以无限接近，无法彻底到达</p></blockquote><p>推荐指数：⭐⭐⭐</p><h3 id="2-沉默的巡游">2.《沉默的巡游》</h3><p>买这本书完全是因为作者与书的大名，也是第一次看推理小说。内容上环环相扣，顺叙、倒叙、插叙相结合，叙述视角多而不乱，情节安排详略得当，脉络清晰，推理严密；以并木食堂的营业场景开篇，也以之结尾，首尾呼应，结构完整，跟随主角的思路去发现破绽，并通过各种破绽并细细推敲过去的真相的过程，让人直呼过瘾，这大概就是推理小说的魅力所在。</p><blockquote><p>这是一个悲伤的故事，却会给你一整年的温暖</p></blockquote><p>推荐指数：⭐⭐⭐⭐⭐</p><h3 id="3-局外人">3.《局外人》</h3><p>从小被灌输的概念就是以孝为本，完全无法理解书中主人公的做法。母亲死于养老院中，他去奔丧，送葬，但无动于衷，毫无眼泪和悲伤，在旁人看来不能理解，并最终成为他在法庭上的罪证。以及与女友结婚，和邻居一起对付阿拉伯人，并最终失手打死其中一个，最后被逮捕并处决为死刑。他似乎获得真的如同一个局外人，细想之下，这大概就是极致理智。</p><blockquote><p>为了把一切都做得完善，为了使我感到不那么孤独，我还希望处决我的那一天有很多人来，希望他们对我报之以仇恨的喊叫声。</p></blockquote><p>推荐指数：⭐⭐⭐⭐⭐</p><h3 id="4-穷爸爸富爸爸">4.《穷爸爸富爸爸》</h3><p>穷爸爸的思维：遇到钱的问题就逃避，看不起、看不上、不关心，当然也得不到；富爸爸思维：遇到钱的问题努力解决问题，赞美、享受金钱，并且实践大量赚钱的方法。整本书更多的是希望能建立一个理财的思想，给人感触最深的是要去实践，**富爸爸真正强大的部分：我知道我要成为什么人，然后不断暗示自己，并坚定地走下去。合上书后就买了基金，狂跌后现在都还没涨回来。</p><p>推荐指数：⭐⭐⭐</p><h3 id="5-平凡的世界">5.《平凡的世界》</h3><p>书中为我们描述了一个平凡而伟大的世界，书中的几位主人公各有各的悲惨生活，却又有着各自的感情线，其中对孙少平与田晓霞的爱情有种莫名的期待，因为孙少安与田润叶的悲剧让我更期待这对情侣在一起，而这种种期待最终在今天化为泡影，在洪水中为了救一个小姑娘，田晓霞去世了，久久不能从书中的悲伤中走出来。文章直到最后也没有令人所谓的反转，所有人都朝着自己认识的方向平凡而不平庸的生活着。</p><blockquote><p>少平，你要记得，你与其他人不一样，你是一个有另外世界的人，你的心不应该只在这，而是在远方，那个充满光的地方</p></blockquote><p>推荐指数：⭐⭐⭐⭐⭐</p><h3 id="6-不要让未来的你-讨厌现在的自己">6.《不要让未来的你，讨厌现在的自己》</h3><p>特立独行的猫代表作，在这个鸡汤盛行的时代，书里面的一个个小故事，给人讲了一个又一个小道理，给人一种不一样的鸡汤的味道，细细品味，也能得出不一样的体验，但最后，我们还是需要自己去执行，看再多大道理，读再多心灵鸡汤，不如看似微小，实际上却 坚实而有力的一步，只有去执行，一切才有意义。</p><blockquote><p>你今天偷的懒，会成为日后的坑。你现在所做的一切，注定了未来的可能。</p></blockquote><p>推荐指数：⭐⭐⭐⭐</p><h3 id="7-放学后">7.《放学后》</h3><p>主人公是一个女子高中的数学教师，当本身却并不喜欢这个工作，只不过是为了养家糊口，顺其自然才当上了教师。因为不管学生的事情，也不接触学生，所以被人冠以“机器”的外号，虽然这样，他内心却也有着让人不易察觉的温柔。可谁也想不到这样一个人的生命会收到威胁，多次出现的意外不得不让人联想到暗杀。本以为事情会朝着这条路线继续发展下去，结果学校却发生了密室杀人案，然后开始了以一系列推理破案的过程，其中出现了经典日本高中生推理能力超过警察的桥段。警方介入调查，主人公却并未告知暗杀一事，随着时间推移，命案淡出视野，凶手再一次在众目睽睽之下杀了本该是主人公扮演的小丑，结合之前的暗杀，所有人都认为主人公才是真正的目标。警察开始对主人公进行保护，他也在千丝万缕中找到了最意想不到的真凶。最后没将真凶公之于众也凸显出人物性格，最后被妻子情夫捅伤失去意识前还想着不能让妻子成为杀人犯，纠结，优柔寡断，冷漠，关心，种种矛盾组成了主人公的性格，也断送了他的生命。</p><p>合上书的那一刻，在思考为何主人公的妻子要杀他，其实也不难猜测，主人的冷漠不作为，以及打掉孩子早已埋下仇恨的种子。我看的版本有所缺失，省去的正是杀人动机的地方，倒是与我猜测的有些出入。</p><blockquote><p>但我不能死，死在这里也留不下什么，只会让裕美子成为杀人犯。我倒在柏油路上，专心等待着有人路过。我还能等。</p></blockquote><p>推荐指数：⭐⭐⭐⭐⭐</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-数组系列6</title>
      <link href="skill/algorithm/55343.html"/>
      <url>skill/algorithm/55343.html</url>
      
        <content type="html"><![CDATA[<h3 id="674-最长连续递增序列">674. 最长连续递增序列</h3><p>给定一个未经排序的整数数组，找到最长且<strong> 连续递增的子序列</strong>，并返回该序列的长度。</p><p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l < r</code>）确定，如果对于每个 <code>l <= i < r</code>，都有 <code>nums[i] < nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p><p> </p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong>nums = [1,3,5,4,7]<br><strong>输出：</strong>3<br><strong>解释：</strong>最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>nums = [2,2,2,2,2]<br><strong>输出：</strong>1<br><strong>解释：</strong>最长连续递增序列是 [2], 长度为1。</p></blockquote><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>因为求的是递增序列，所以当前元素小于等于上一个元素时，表示上一个递增子序列结束，我们更新下一个子序列开始位置，并求出此时最大子序列，依此循环即可</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLengthOfLCIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> ans, start <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      <span class="keyword">if</span> k &gt; <span class="number">0</span> &amp;&amp; v &lt;= nums[k<span class="number">-1</span>] &#123;</span><br><span class="line">         start = k</span><br><span class="line">      &#125;</span><br><span class="line">      ans = max(ans, k-start +<span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">      <span class="keyword">return</span> b</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="682-棒球比赛">682. 棒球比赛</h3><p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p><p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p><ol><li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li><li><code>"+"</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li><li><code>"D"</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li><li><code>"C"</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li></ol><p>请你返回记录中所有得分的总和。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong>ops = [“5”,“2”,“C”,“D”,&quot;+&quot;]<br><strong>输出：</strong>30<br><strong>解释：</strong><br>“5” - 记录加 5 ，记录现在是 [5]<br>“2” - 记录加 2 ，记录现在是 [5, 2]<br>“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5].<br>“D” - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].<br>“+” - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].<br>所有得分的总和 5 + 10 + 15 = 30</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>ops = [“5”,&quot;-2&quot;,“4”,“C”,“D”,“9”,&quot;+&quot;,&quot;+&quot;]<br><strong>输出：</strong>27<br><strong>解释：</strong><br>“5” - 记录加 5 ，记录现在是 [5]<br>“-2” - 记录加 -2 ，记录现在是 [5, -2]<br>“4” - 记录加 4 ，记录现在是 [5, -2, 4]<br>“C” - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]<br>“D” - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]<br>“9” - 记录加 9 ，记录现在是 [5, -2, -4, 9]<br>“+” - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]<br>“+” - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]<br>所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong>ops = [“1”]<br><strong>输出：</strong>1</p></blockquote><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>题目比较简单，因为数据都是合法的，所以不需要额外验证数据，直接用数组模拟栈处理即可</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calPoints</span><span class="params">(ops []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> stack []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line"><span class="keyword">switch</span> op &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">stack = <span class="built_in">append</span>(stack, stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]+stack[<span class="built_in">len</span>(stack)<span class="number">-2</span>])</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">stack = <span class="built_in">append</span>(stack, stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">score, _ := strconv.Atoi(op)</span><br><span class="line">stack = <span class="built_in">append</span>(stack, score)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> stack &#123;</span><br><span class="line">count += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="694-数组的度">694.  数组的度</h3><p>给定一个非空且只包含非负数的整数数组&nbsp;<code>nums</code>，数组的 <strong>度</strong> 的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是在 <code>nums</code> 中找到与&nbsp;<code>nums</code>&nbsp;拥有相同大小的度的最短连续子数组，返回其长度。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong>nums = [1,2,2,3,1]<br><strong>输出：</strong>2<br><strong>解释：</strong><br>输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。<br>连续子数组里面拥有相同度的有如下所示：<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>nums = [1,2,2,3,1,4,2]<br><strong>输出：</strong>6<br><strong>解释：</strong><br>数组的度是 3 ，因为元素 2 重复出现 3 次。<br>所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。</p></blockquote><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>通过哈希记录当前数值出现的次数与首次出现和最后一次出现，取出最多出现次数的值，用最后一次出现减去第一次出现的即可得出度</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">   cnt, l, r <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findShortestSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> ans, maxCnt <span class="keyword">int</span></span><br><span class="line">   mp := <span class="keyword">map</span>[<span class="keyword">int</span>]entry&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      <span class="keyword">if</span> e, ok := mp[v]; ok &#123;</span><br><span class="line">         e.cnt++</span><br><span class="line">         e.r = i</span><br><span class="line">         mp[v] = e</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         mp[v] = entry&#123;<span class="number">1</span>, i, i&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, e := <span class="keyword">range</span> mp &#123;</span><br><span class="line">      <span class="keyword">if</span> e.cnt &gt; maxCnt &#123;</span><br><span class="line">         maxCnt, ans = e.cnt, e.r-e.l+<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> e.cnt == maxCnt &#123;</span><br><span class="line">         ans = min(ans, e.r-e.l+<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="704-二分查找">704. 二分查找</h3><p>给定一个&nbsp;<code>n</code>&nbsp;个元素有序的（升序）整型数组&nbsp;<code>nums</code> 和一个目标值&nbsp;<code>target</code> &nbsp;，写一个函数搜索&nbsp;<code>nums</code>&nbsp;中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p></p><blockquote><p><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9<br><strong>输出:</strong> 4<br><strong>解释:</strong> 9 出现在 <code>nums</code> 中并且下标为 4</p></blockquote><p><strong>示例&nbsp;2:</strong></p>> <strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2<strong>输出:</strong> -1<strong>解释:</strong> 2 不存在 <code>nums</code> 中因此返回 -1<h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>略</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">   <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">      mid := (r-l)/<span class="number">2</span> + l</span><br><span class="line">      num := nums[mid]</span><br><span class="line">      <span class="keyword">if</span> num == target &#123;</span><br><span class="line">         <span class="keyword">return</span> mid</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> target &lt; num &#123;</span><br><span class="line">         r = mid - <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         l = mid + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="705-设计哈希集合">705. 设计哈希集合</h3><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 <code>MyHashSet</code> 类：</p><ul><li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li><li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li><li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul>&nbsp;<p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong><br>[“MyHashSet”, “add”, “add”, “contains”, “contains”, “add”, “contains”, “remove”, “contains”]<br>[[], [1], [2], [1], [3], [2], [2], [2], [2]]<br><strong>输出：</strong><br>[null, null, null, true, false, null, true, null, false]</p><p><strong>解释：</strong><br>MyHashSet myHashSet = new MyHashSet();<br>myHashSet.add(1);      // set = [1]<br>myHashSet.add(2);      // set = [1, 2]<br>myHashSet.contains(1); // 返回 True<br>myHashSet.contains(3); // 返回 False ，（未找到）<br>myHashSet.add(2);      // set = [1, 2]<br>myHashSet.contains(2); // 返回 True<br>myHashSet.remove(2);   // set = [1]<br>myHashSet.contains(2); // 返回 False ，（已移除）</p></blockquote><p></p><div class="tabs" id="705"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#705-1">顺序存储</button></li><li class="tab"><button type="button" data-href="#705-2">链式存储</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="705-1"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>利用数组存储，直接对数组进行插入，查找，删除</p></div><h4 id="示例代码">示例代码</h4><p>略</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="705-2"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>**HashSet是在时间和空间上做权衡的例子：**如果不考虑空间问题，直接使用顺序存储的方式，用一个超大的数组报错，每个Key都有单独的位置。插入和查找都会比较费时间。</p><p>为了平衡时间和空间的平衡，<strong>HashSet</strong>是基于数组实现的，通过hsah方法求键Key在数组中的位置，当hash后的位置存在冲突的时候，在解决冲突。设计合适的 hash 函数，一般都是对分桶数取模<code>%</code>，为了避免冲突，尽量采用质数取模</p><p><img src="https://cdn.inkdp.cn/img/20220324154253.jpg" alt="c9bbf70f3f0c446ed294e087d8565348.jpg"></p></div><h4 id="示例代码">示例代码</h4><p>使用了golang自带的双向链表，这样不用每次都从头开始遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">   data []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base = <span class="number">997</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyHashSet</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> MyHashSet&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashSet)</span> <span class="title">hash</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> key % base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashSet)</span> <span class="title">Add</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> !this.Contains(key) &#123;</span><br><span class="line">      h := this.hash(key)</span><br><span class="line">      this.data[h].PushBack(key)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashSet)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   h := this.hash(key)</span><br><span class="line">   <span class="keyword">for</span> e := this.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">      <span class="keyword">if</span> e.Value.(<span class="keyword">int</span>) == key &#123;</span><br><span class="line">         this.data[h].Remove(e)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashSet)</span> <span class="title">Contains</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   h := this.hash(key)</span><br><span class="line">   <span class="keyword">for</span> e := this.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">      <span class="keyword">if</span> e.Value.(<span class="keyword">int</span>) == key &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="706-设计哈希集合">706. 设计哈希集合</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 <code>MyHashMap</code> 类：</p><ul>   <li><code>MyHashMap()</code> 用空映射初始化对象</li>   <li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>   <li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>   <li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li></ul><p>&nbsp;</p><p><strong>示例：</strong></p><blockquote><p><strong>输入</strong>：<br>[“MyHashMap”, “put”, “put”, “get”, “get”, “put”, “get”, “remove”, “get”]<br>[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]<br><strong>输出</strong>：<br>[null, null, null, 1, -1, null, 1, null, -1]</p><p><strong>解释</strong>：<br>MyHashMap myHashMap = new MyHashMap();<br>myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]<br>myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]<br>myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]<br>myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]<br>myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）<br>myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]<br>myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]<br>myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</p></blockquote><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>与上题几乎一致，唯一的区别在于我们存储的不是<code>key</code>本身，而是 <code>(key,value)</code> 对。除此之外，代码基本是类似的。</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">   key, value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base = <span class="number">997</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyHashMap <span class="keyword">struct</span> &#123;</span><br><span class="line">   data []list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructors</span><span class="params">()</span> <span class="title">MyHashMap</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> MyHashMap&#123;<span class="built_in">make</span>([]list.List, base)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hash</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> key % base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">int</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   h := hash(key)</span><br><span class="line">   <span class="keyword">for</span> e := this.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">      <span class="keyword">if</span> v := e.Value.(entry); v.key == key &#123;</span><br><span class="line">         e.Value = entry&#123;key, value&#125;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   this.data[h].PushBack(entry&#123;key, value&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   h := hash(key)</span><br><span class="line">   <span class="keyword">for</span> e := this.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">      <span class="keyword">if</span> v := e.Value.(entry); v.key == key &#123;</span><br><span class="line">         <span class="keyword">return</span> v.value</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span> <span class="title">Remove</span><span class="params">(key <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   h := hash(key)</span><br><span class="line">   <span class="keyword">for</span> e := this.data[h].Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">      <span class="keyword">if</span> v := e.Value.(entry); v.key == key &#123;</span><br><span class="line">         this.data[h].Remove(e)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go发现网络活跃主机</title>
      <link href="skill/back-end/27211.html"/>
      <url>skill/back-end/27211.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>  最近实际开发中突然遇到一个比较有意思的需求，大体内容是我需要从前端给我的一堆主机IP中拿出其中处于活跃状态的主机，说简单的就是能<code>ping</code>通的主机，乍一看不难，就想着去网上copy一份解决方案，但是乱七八糟一堆却没有实际解决问题的，大多是通过调用ping命令来实现，或者就是携带端口扫描的，这些都与我目前想实现的方式相背，所以都不能采用。</p><h3 id="思考🤔">思考🤔</h3><p>不调用主机ping命令的情况下，自己去实现一个ping，基于这个思路，继续寻找解决方案，这才倒是有了，但都是通过ICMP协议，启动时需要sudo权限，这又与我所需要的相背，我需要的是不依赖于ICMP也可以Ping的方案。</p><h3 id="正文">正文</h3><p>本文主角：<a href="https://github.com/go-ping/ping">go-ping</a>，它可以通过 UDP 发送一个“非特权”ping，与我的实际需求完全一致</p><p><img src="https://cdn.inkdp.cn/img/20210829172002.png" alt="image-20210829172002459"></p><p>看一个官方示例的ping程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pinger, err := ping.NewPinger(<span class="string">&quot;www.google.com&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for Ctrl-C.</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(c, os.Interrupt)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _ = <span class="keyword">range</span> c &#123;</span><br><span class="line">pinger.Stop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">pinger.OnRecv = <span class="function"><span class="keyword">func</span><span class="params">(pkt *ping.Packet)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d bytes from %s: icmp_seq=%d time=%v\n&quot;</span>,</span><br><span class="line">pkt.Nbytes, pkt.IPAddr, pkt.Seq, pkt.Rtt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pinger.OnDuplicateRecv = <span class="function"><span class="keyword">func</span><span class="params">(pkt *ping.Packet)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d bytes from %s: icmp_seq=%d time=%v ttl=%v (DUP!)\n&quot;</span>,</span><br><span class="line">pkt.Nbytes, pkt.IPAddr, pkt.Seq, pkt.Rtt, pkt.Ttl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pinger.OnFinish = <span class="function"><span class="keyword">func</span><span class="params">(stats *ping.Statistics)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n--- %s ping statistics ---\n&quot;</span>, stats.Addr)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d packets transmitted, %d packets received, %v%% packet loss\n&quot;</span>,</span><br><span class="line">stats.PacketsSent, stats.PacketsRecv, stats.PacketLoss)</span><br><span class="line">fmt.Printf(<span class="string">&quot;round-trip min/avg/max/stddev = %v/%v/%v/%v\n&quot;</span>,</span><br><span class="line">stats.MinRtt, stats.AvgRtt, stats.MaxRtt, stats.StdDevRtt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;PING %s (%s):\n&quot;</span>, pinger.Addr(), pinger.IPAddr())</span><br><span class="line">err = pinger.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际运行效果:</p><blockquote><p>PING <a href="http://www.baidu.com">www.baidu.com</a> (14.215.177.38):<br>24 bytes from 14.215.177.38: icmp_seq=0 time=29.801ms<br>24 bytes from 14.215.177.38: icmp_seq=1 time=37.256ms<br>24 bytes from 14.215.177.38: icmp_seq=2 time=36.844ms<br>24 bytes from 14.215.177.38: icmp_seq=3 time=36.24ms<br>24 bytes from 14.215.177.38: icmp_seq=4 time=30.73ms<br>24 bytes from 14.215.177.38: icmp_seq=5 time=36.381ms<br>24 bytes from 14.215.177.38: icmp_seq=6 time=36.173ms<br>24 bytes from 14.215.177.38: icmp_seq=7 time=29.764ms<br>24 bytes from 14.215.177.38: icmp_seq=8 time=29.755ms<br>24 bytes from 14.215.177.38: icmp_seq=9 time=29.676ms<br>24 bytes from 14.215.177.38: icmp_seq=10 time=29.63ms<br>24 bytes from 14.215.177.38: icmp_seq=11 time=36.294ms<br>24 bytes from 14.215.177.38: icmp_seq=12 time=36.003ms</p><p>— <a href="http://www.baidu.com">www.baidu.com</a> ping statistics —<br>13 packets transmitted, 13 packets received, 0% packet loss<br>round-trip min/avg/max/stddev = 29.63ms/33.426693ms/37.256ms/3.295477ms</p></blockquote><p>他通过发送和接收到的包来计算丢失率，在<code>pinger.OnFinish</code>时即可得到结果，但是我们实际运用的时候却不能去手动关闭这个<code>ping</code>程序来得到结果，通过阅读源码发现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pinger <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Interval is the wait time between each packet send. Default is 1s.</span></span><br><span class="line">Interval time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// Timeout specifies a timeout before ping exits, regardless of how many</span></span><br><span class="line"><span class="comment">// packets have been received.</span></span><br><span class="line">Timeout time.Duration</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了等待时间与超时时间，就可以通过超时而结束，在<code>pinger.OnFinish</code>中查看是否有收到包，以此判断主机是否处于活跃状态</p><h3 id="最终代码">最终代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PingIP</span><span class="params">(ip <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   pinger, err := ping.NewPinger(ip)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">   pinger.Interval = <span class="number">1</span> * time.Millisecond <span class="comment">// 发送间隔</span></span><br><span class="line">   pinger.Timeout = <span class="number">5</span> * time.Millisecond <span class="comment">// 超时时间</span></span><br><span class="line">   pinger.OnFinish = <span class="function"><span class="keyword">func</span><span class="params">(stats *ping.Statistics)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> stats.PacketsRecv != <span class="number">0</span> &#123;</span><br><span class="line">         b = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   err = pinger.Run()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过与具体业务的整合，即可得出一个发现活跃服务器</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-数组系列5</title>
      <link href="skill/algorithm/55663.html"/>
      <url>skill/algorithm/55663.html</url>
      
        <content type="html"><![CDATA[<h3 id="115-最小栈">115. 最小栈</h3><p>设计一个支持<code>push</code> ，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><blockquote><p><strong>输入：</strong><br>[“MinStack”,“push”,“push”,“push”,“getMin”,“pop”,“top”,“getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p><strong>输出：</strong><br>[null,null,null,null,-3,null,0,-2]</p><p><strong>解释：</strong><br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   --&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      --&gt; 返回 0.<br>minStack.getMin();   --&gt; 返回 -2.</p></blockquote><p><strong>提示：</strong></p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>因为要输入栈中最小值，所以我们额外定义一个辅助栈，用于入栈时记录当前数此时栈中最小值，出栈时一起出即可。</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">      <span class="keyword">return</span> b</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">   stack    []<span class="keyword">int</span></span><br><span class="line">   minStack []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">      stack:    []<span class="keyword">int</span>&#123;&#125;,</span><br><span class="line">      minStack: []<span class="keyword">int</span>&#123;math.MaxInt64&#125;,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   this.stack = <span class="built_in">append</span>(this.stack, val)</span><br><span class="line">   this.minStack = <span class="built_in">append</span>(this.minStack, min(val, this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">   this.minStack = this.minStack[:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="594-最长和谐子序列">594. 最长和谐子序列</h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 1</strong> 。</p><p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [1,3,2,2,5,2,3,7]<br>输出：5<br>解释：最长的和谐子序列是 [3,2,2,2,3]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [1,2,3,4]<br>输出：2</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [1,1,1,1]<br>输出：0</p></blockquote><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>扫描数组，将扫描到元素<code>x</code>时，将<code>x</code>存入哈希表，然后获取哈希表中<code>x-1,x,x+1</code>出现的次数<code>a,b,c</code>，此时<code>a+b</code>与<code>b+c</code>分别为<code>x-1,x</code>与<code>x, x+1</code>组成的和谐子序列长度，我们取出其中最大的一个即为最长和谐子序列的长度。</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLHS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   mapList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      mapList[num] ++</span><br><span class="line">      <span class="keyword">if</span> _, ok := mapList[num<span class="number">-1</span>]; ok &amp;&amp; res &lt; (mapList[num<span class="number">-1</span>] + mapList[num])&#123;</span><br><span class="line">         res = mapList[num<span class="number">-1</span>] + mapList[num]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> _, ok := mapList[num+<span class="number">1</span>]; ok &amp;&amp; res &lt; (mapList[num+<span class="number">1</span>] + mapList[num])&#123;</span><br><span class="line">         res = mapList[num+<span class="number">1</span>] + mapList[num]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="202-快乐数">202. 快乐数</h3><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</p></li><li><p>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</p></li><li><p>如果 可以变为  1，那么这个数就是快乐数。</p></li></ul><p>如果 n 是快乐数就返回 true ；不是，则返回 false 。</p><p><strong>示例 1：</strong></p><blockquote><p>**输入：**19<br>**输出：**true<br><strong>解释：</strong><br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>**输入：**n = 2<br>**输出：**false</p></blockquote><div class="tabs" id="202"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#202-1">哈希</button></li><li class="tab"><button type="button" data-href="#202-2">快慢指针</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="202-1"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>对数进行列举发现数总共会出现3种情况：</p><ol><li>最终会得到 11。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大</li></ol><p>第三种情况是最复杂，继续变大我们无法处理，经过实际测试我们发现：</p><table><thead><tr><th>位数</th><th>最大数</th><th>下一步得到的数</th></tr></thead><tbody><tr><td>1</td><td>9</td><td>81</td></tr><tr><td>2</td><td>99</td><td>162</td></tr><tr><td>3</td><td>999</td><td>243</td></tr><tr><td>4</td><td>9999</td><td>324</td></tr><tr><td>13</td><td>9999999999999</td><td>1053</td></tr></tbody></table><p>经过上表可得，3位数最大可得243，因为4位数和4位数以上的数字最后都会降到3位，这意味着这个数要么在243中循环，要么变成1。由此可将算法分为两个部分：</p><ol><li>计算n的下一位数</li><li>判断该数结果是否出现过，存在过这表示进入循环，不是快乐数</li></ol></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">   <span class="keyword">for</span> ; n != <span class="number">1</span> &amp;&amp; !m[n]; n, m[n] = step(n), <span class="literal">true</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   sum := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">      sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">      n /= <span class="number">10</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="202-2"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>哈希解法中的反复调用<code>step</code>函数可以看作一个链表中的<code>getNext</code>，由此我们得到一个隐形链表，虽然我们没有实际的链表节点和指针，但数据还是形成了一个链表数据结构。</p><p>由哈希初分析解法可知，最终结果只有两种，得到1和无限循环。循环在链表中既表示为闭环。采用快慢指针去遍历链表，慢指针每次前进一步，快指针前进两步，如果快指针会追上慢指针，则此链表闭环(不是快乐数)，快指针循环到链表尾部(得到1)，着不闭环(快乐数)</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappyList</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   slow, fast := n, step(n)</span><br><span class="line">   <span class="keyword">for</span> ;fast != <span class="number">1</span> &amp;&amp; slow != fast; &#123;</span><br><span class="line">      slow = step(slow)</span><br><span class="line">      fast = step(step(fast))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="598-范围求和-ii">598. 范围求和 II</h3><p>给定一个初始元素全部为&nbsp;<strong>0</strong>，大小为 m*n 的矩阵&nbsp;<strong>M&nbsp;</strong>以及在&nbsp;<strong>M&nbsp;</strong>上的一系列更新操作。</p><p>操作用二维数组表示，其中的每个操作用一个含有两个<strong>正整数&nbsp;a</strong> 和 <strong>b</strong> 的数组表示，含义是将所有符合&nbsp;<strong>0 &lt;= i &lt; a</strong> 以及 <strong>0 &lt;= j &lt; b</strong> 的元素&nbsp;<strong>M[i][j]&nbsp;</strong>的值都<strong>增加 1</strong>。</p><p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong></p><blockquote><p>m = 3, n = 3<br>operations = [[2,2],[3,3]]<br><strong>输出:</strong> 4<br><strong>解释:</strong><br>初始状态, M =<br>[[0, 0, 0],<br>[0, 0, 0],<br>[0, 0, 0]]</p><p>执行完操作 [2,2] 后, M =<br>[[1, 1, 0],<br>[1, 1, 0],<br>[0, 0, 0]]</p><p>执行完操作 [3,3] 后, M =<br>[[2, 2, 1],<br>[2, 2, 1],<br>[1, 1, 1]]</p><p>M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。</p></blockquote><p><strong>注意:</strong></p><ol>   <li>m 和 n 的范围是&nbsp;[1,40000]。</li>   <li>a 的范围是 [1,m]，b 的范围是 [1,n]。</li>   <li>操作数目不超过 10000。</li></ol><div class="tabs" id="598"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#598-1">暴力法</button></li><li class="tab"><button type="button" data-href="#598-2">重叠区域</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="598-1"><h4 id="解题思路">解题思路</h4><div class="note info simple no-icon simple"><p>由于所有的变化都是从<code>[0,0]</code>开始，所以[0,0]肯定是最大的，循环求出所有与其相等的即可。<mark class="hl-label red">注意：Leetcode提交时会提示内存不足</mark></p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxCount</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>, ops [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   arr := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">      arr[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; op[<span class="number">0</span>]; i++ &#123;</span><br><span class="line">         <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; op[<span class="number">1</span>]; j++ &#123;</span><br><span class="line">            arr[i][j]++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   max := arr[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> _, ints := <span class="keyword">range</span> arr &#123;</span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> ints &#123;</span><br><span class="line">         <span class="keyword">if</span> v == max &#123;</span><br><span class="line">            count ++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="598-2"><h4 id="解题思路">解题思路</h4><div class="note info simple no-icon simple"><p>由题意可知，每次增加都是从左上角开始，到<code>[i,j]</code>，重叠的范围为ops中最小的<code>(x,y)</code>，有了范围，最大的元素数目就为<code>x*y</code></p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxCount</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>, ops [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line">      <span class="keyword">if</span> m &gt; op[<span class="number">0</span>] &#123;</span><br><span class="line">         m = op[<span class="number">0</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> n &gt; op[<span class="number">1</span>] &#123;</span><br><span class="line">         n = op[<span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> m*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="599-两个列表的最小索引总和">599. 两个列表的最小索引总和</h3><p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用<strong>最少的索引和</strong>找出他们<strong>共同喜爱的餐厅</strong>。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong></p><p>[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]<br>[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]<br><strong>输出:</strong> [&quot;Shogun&quot;]<br><strong>解释:</strong> 他们唯一共同喜爱的餐厅是“Shogun”。<br></pre></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong></p><p>[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]<br>[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]<br><strong>输出:</strong> [&quot;Shogun&quot;]<br><strong>解释:</strong> 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</p></blockquote><h4 id="解体思路">解体思路</h4><div class="note no-icon simple info simple"><p>利用哈希表，遍历<code>list1</code>，以餐厅名称为<code>key</code>，下标为<code>value</code>，存入map，再遍历第二个数组，map中存在表示为同时喜欢餐厅，此时将两个下标相加即可得到索引，如果和比之前记录的最小值要小，那么清空返回结果列表，并将此结果添加进去，如果相等则追加</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRestaurant</span><span class="params">(list1 []<span class="keyword">string</span>, list2 []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      res      = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">      mapList  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">      minIndex = math.MaxInt32</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">for</span> i, s := <span class="keyword">range</span> list1 &#123;</span><br><span class="line">      mapList[s] = i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i, s := <span class="keyword">range</span> list2 &#123;</span><br><span class="line">      <span class="keyword">if</span> v, ok := mapList[s]; ok &#123;</span><br><span class="line">         sum := v + i</span><br><span class="line">         <span class="keyword">if</span> sum == minIndex &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, s)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> sum &lt; minIndex &#123;</span><br><span class="line">            minIndex = sum</span><br><span class="line">            res = []<span class="keyword">string</span>&#123;s&#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="645-错误的集合">645. 错误的集合</h3><p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 <strong>丢失了一个数字</strong> 并且 <strong>有一个数字重复</strong> 。</p><p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</p><p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong>nums = [1,2,2,4]<br><strong>输出：</strong>[2,3]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>nums = [1,1]<br><strong>输出：</strong>[1,2]</p></blockquote><div class="tabs" id="645"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#645-1">排序</button></li><li class="tab"><button type="button" data-href="#645-2">哈希</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="645-1"><h4 id="解题思路">解题思路</h4><div class="note no-icon simple info simple"><p>先排序，比较每对相邻的元素，即可找到错误的集合。如果相邻的两个元素相等，则该元素为重复的数字；丢失的数字分为两种情况：</p><ul><li>如果丢失的数字大于 11且小于 n，两个数的差等于 2，他们之间的数即为丢失的数字；</li><li>如果丢失的数字是 1 或 n，则需要额外处理。</li></ul><p>由于要寻找丢失的数字，所以我们需要记录上一个数字，用来计算两个数字的差，如果丢失的是1，将上一个数字记录为0即可。如果最后一个数字不是n，那么丢失的就是n</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRestaurant</span><span class="params">(list1 []<span class="keyword">string</span>, list2 []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      res      = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">      mapList  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">      minIndex = math.MaxInt32</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">for</span> i, s := <span class="keyword">range</span> list1 &#123;</span><br><span class="line">      mapList[s] = i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i, s := <span class="keyword">range</span> list2 &#123;</span><br><span class="line">      <span class="keyword">if</span> v, ok := mapList[s]; ok &#123;</span><br><span class="line">         sum := v + i</span><br><span class="line">         <span class="keyword">if</span> sum == minIndex &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, s)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> sum &lt; minIndex &#123;</span><br><span class="line">            minIndex = sum</span><br><span class="line">            res = []<span class="keyword">string</span>&#123;s&#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="645-2"><h4 id="解题思路">解题思路</h4><div class="note no-icon simple info simple"><p>遍历数组，用哈希表记录数字出现的次数，再遍历1到n，出现2次的就是重复的，出现0次的就是丢失的</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findErrorNums</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">   m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      m[num] ++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> v := m[i]; v == <span class="number">2</span> &#123;</span><br><span class="line">         res[<span class="number">0</span>] = i</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">         res[<span class="number">1</span>] = i</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-数组系列4</title>
      <link href="skill/algorithm/6574.html"/>
      <url>skill/algorithm/6574.html</url>
      
        <content type="html"><![CDATA[<h3 id="463-岛屿的周长">463. 岛屿的周长</h3><p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。</p><p>网格中的格子<strong>水平和垂直</strong>方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.inkdp.cn/img/20210722195626.png" alt="img"></p><blockquote><p><strong>输入</strong>：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]<br><strong>输出</strong>：16<br><strong>解释</strong>：它的周长是上面图片中的 16 个黄色的边</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入</strong>：grid = [[1]]<br><strong>输出</strong>：4</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入</strong>：grid = [[1,0]]<br><strong>输出</strong>：4</p></blockquote><div class="tabs" id="463"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#463-1">公式法</button></li><li class="tab"><button type="button" data-href="#463-2">DFS</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="463-1"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>通过观察不难看出每个格子都有4条边，而两个格子相邻时会去掉两条边，所以周长应该为 <code>4*格子数量 - 2*响铃的边</code>；由于格子相邻是互相的，所以寻找相邻的格子时只寻找右下方的即可</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">islandPerimeter</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count, edge <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(grid[i]); j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         count++</span><br><span class="line">         <span class="keyword">if</span> j+<span class="number">1</span> &lt; <span class="built_in">len</span>(grid[i]) &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="number">1</span> &#123;</span><br><span class="line">            edge++</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> i+<span class="number">1</span> &lt; <span class="built_in">len</span>(grid) &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="number">1</span> &#123;</span><br><span class="line">            edge++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">4</span>*count - <span class="number">2</span>*edge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="463-2"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>因为总共就一个岛屿，所以我们从遇到的第一块土地开始，基于他递归上下左右4个点：从土地到土地不会产生周长，从土地到海洋会产生周长，从土地到边界会参数周长，将这些周长相加即可。</p><p>在上述过程中，递归会导致重复，造成重复计算，将遍历过得土地做一个特殊标记，区别于1和0表示已经访问过了。</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">islandPerimeter</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(grid[i]); j++ &#123;</span><br><span class="line">         <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(grid, i, j)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="keyword">int</span>, x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> x &lt; <span class="number">0</span> || x &gt;= <span class="built_in">len</span>(grid) || y &lt; <span class="number">0</span> || y &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> grid[x][y] == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> grid[x][y] == <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">   grid[x][y] = <span class="number">2</span></span><br><span class="line">   <span class="keyword">return</span> dfs(grid, x<span class="number">-1</span>, y) + dfs(grid, x+<span class="number">1</span>, y) + dfs(grid, x, y<span class="number">-1</span>) + dfs(grid, x, y+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="495-提莫攻击">495. 提莫攻击</h3><p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。</p><p>你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入</strong>: [1,4], 2<br><strong>输出</strong>: 4<br><strong>原因</strong>: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。<br>第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。<br>所以最终输出 4 秒。</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入</strong>: [1,2], 2<br><strong>输出</strong>: 3<br><strong>原因</strong>: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。<br>但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。<br>由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。<br>所以最终输出 3 。</p></blockquote><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>先考虑两个相邻攻击时间节点<code>timeSeries[i]</code>和<code>timeSeries[i-1]</code>的差，如果大于攻击持续时间<code>duration</code>，则第<code>i-1</code>次攻击持续</p><p><code>duration</code>，反之则持续<code>timeSeries[i] - timeSeries[i-1]</code>，最后一次攻击始终会持续<code>duration</code>，将它们相加即可</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPoisonedDuration</span><span class="params">(timeSeries []<span class="keyword">int</span>, duration <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(timeSeries) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(timeSeries); i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> timeSeries[i]-timeSeries[i<span class="number">-1</span>] &lt; duration &#123;</span><br><span class="line">         total += timeSeries[i] - timeSeries[i<span class="number">-1</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         total += duration</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> total + duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素-i">496. 下一个更大元素 I</h3><p>给你两个<strong>没有重复元素</strong>的数组<code>nums1</code>和<code>nums2</code> ，其中<code>nums1</code>是<code>nums2</code>的子集。</p><p>请你找出<code>nums1</code>中每个元素在<code>nums2</code>中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p><strong>示例 1</strong> :</p><blockquote><p><strong>输入</strong>: nums1 = [4,1,2], nums2 = [1,3,4,2].<br><strong>输出</strong>: [-1,3,-1]<br><strong>解释</strong>:<br>对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。<br>对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。<br>对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p></blockquote><p><strong>示例 2</strong>:</p><blockquote><p><strong>输入</strong>: nums1 = [2,4], nums2 = [1,2,3,4].<br><strong>输出</strong>: [3,-1]<br><strong>解释</strong>:<br>对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li><li><code>nums1</code>和<code>nums2</code>中所有整数 互不相同</li><li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li></ul><p><strong>进阶</strong>：你可以设计一个时间复杂度为<code>O(nums1.length + nums2.length)</code>的解决方案吗？</p><div class="tabs" id="496"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#496-1">暴力法</button></li><li class="tab"><button type="button" data-href="#496-2">单调栈</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="496-1"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>循环<code>nums1</code>，在<code>nums2</code>中查找它的位置，并想有遍历寻找第一个比它大的元素</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums1))</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums1); i++ &#123;</span><br><span class="line">      j := <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> ;j&lt;<span class="built_in">len</span>(nums2) &amp;&amp; nums1[i] != nums2[j]; &#123;</span><br><span class="line">         j++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> ;j&lt;<span class="built_in">len</span>(nums2); j ++ &#123;</span><br><span class="line">         <span class="keyword">if</span> nums1[i]&lt; nums2[j] &#123;</span><br><span class="line">            res[i] = nums2[j]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> j == <span class="built_in">len</span>(nums2)&#123;</span><br><span class="line">         res[i] = <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="496-2"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>由于<code>nums1</code>是<code>nums2</code>的子集，整体思路就是求出<code>nums2</code>中每个元素对应的下一个更大元素，存在map中，其中<code>key</code>为<code>nums2</code>中的元素值，<code>value</code>为下一个更大元素。</p><p>正序遍历数组<code>nums2</code>，对于当前考察元素<code>nums2[i]</code>来说：</p><ul><li>如果栈为空，将<code>nums[i]</code>入栈，继续向后遍历，看是否有大于<code>nums[i]</code>的</li><li>如果栈不为空且其值大于栈顶元素，由于正序遍历所以当前元素<code>nums[i]</code>是栈顶元素的下一个更大元素。所以栈顶元素出栈作为<code>key</code>，<code>nums[i]</code>作为<code>value</code>存入map。对于出栈后的新栈，继续上诉操作，知道<code>nums[i]</code>不再大于栈顶元素或者栈为空时入栈。</li></ul><p>数组遍历完后，查看栈是否为空，不为空时栈类元素为没有更大的元素，值为<code>-1</code></p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>  &#123;</span><br><span class="line">   stack := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">   mapList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> &#123;</span><br><span class="line">         stack = <span class="built_in">append</span>(stack, v)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      i := <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(stack); i++ &#123;</span><br><span class="line">         <span class="keyword">if</span> v &gt; stack[i] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> j := i; j &lt; <span class="built_in">len</span>(stack); j++ &#123;</span><br><span class="line">         mapList[stack[j]] = v</span><br><span class="line">      &#125;</span><br><span class="line">      stack = stack[:i]</span><br><span class="line">      stack = <span class="built_in">append</span>(stack, v)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _,v := <span class="keyword">range</span> stack &#123;</span><br><span class="line">      mapList[v] = <span class="number">-1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">      nums1[k] = mapList[v]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> nums1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="500-键盘行">500. 键盘行</h3><p>给你一个字符串数组 words ，只返回可以使用在<strong>美式键盘</strong>同一行的字母打印出来的单词。键盘如下图所示。</p><p><strong>美式键盘</strong>中：</p><ul><li>第一行由字符<code>&quot;qwertyuiop&quot;</code>组成。</li><li>第二行由字符`“asdfghjkl” 组成。</li><li>第三行由字符<code>&quot;zxcvbnm&quot;</code>组成。</li></ul><p><img src="https://cdn.inkdp.cn/img/20210726193833.png" alt="American keyboard"></p><p><strong>示例 1</strong>：</p><blockquote><p>**输入：**words = [“Hello”,“Alaska”,“Dad”,“Peace”]<br><strong>输出：</strong>[“Alaska”,“Dad”]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>**输入：**words = [“omk”]<br><strong>输出：</strong>[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>**输入：**words = [“adsdf”,“sfd”]<br><strong>输出：</strong>[“adsdf”,“sfd”]</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 20</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code>由英文字母（小写和大写字母）组成</li></ul><div class="tabs" id="500"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#500-1">哈希</button></li><li class="tab"><button type="button" data-href="#500-2">标准库</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="500-1"><h4 id="解题思路">解题思路</h4><div class="note no-icon simple info simple"><p>以键盘字母为<code>key</code>，所在行数为<code>value</code>存入map。遍历words中每一个单词的字母，是否在同一行</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWords</span><span class="params">(words []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      res []<span class="keyword">string</span></span><br><span class="line">      keyboard <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span></span><br><span class="line">   )</span><br><span class="line">   keyboard = <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">      <span class="string">&#x27;q&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;u&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">&#x27;z&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;v&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">      b := <span class="literal">true</span></span><br><span class="line">      lowercase := strings.ToLower(word)</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(lowercase); i++ &#123;</span><br><span class="line">         <span class="keyword">if</span> keyboard[lowercase[i<span class="number">-1</span>]] != keyboard[lowercase[i]] &#123;</span><br><span class="line">            b = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> b &#123;</span><br><span class="line">         res = <span class="built_in">append</span>(res, word)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="500-2"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>利用<code>strings</code>库提供的<code>ContainsAny</code>函数，判断输入的单词是否出现在键盘的某一行中，如果一个单词在多行中出现则表示不符合标准</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWords2</span><span class="params">(words []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">   line1 := <span class="string">&quot;qwertyuiopQWERTYUIOP&quot;</span></span><br><span class="line">   line2 := <span class="string">&quot;asdfghjklASDFGHJKL&quot;</span></span><br><span class="line">   line3 := <span class="string">&quot;zxcvbnmZXCVBNM&quot;</span></span><br><span class="line">   <span class="keyword">var</span> res []<span class="keyword">string</span></span><br><span class="line">   <span class="keyword">for</span> _, word := <span class="keyword">range</span> words&#123;</span><br><span class="line">      b1 := strings.ContainsAny(word, line1)</span><br><span class="line">      b2 := strings.ContainsAny(word, line2)</span><br><span class="line">      b3 := strings.ContainsAny(word, line3)</span><br><span class="line">      <span class="keyword">if</span> (b1 &amp;&amp; !b2 &amp;&amp; !b3) || (!b1 &amp;&amp; b2 &amp;&amp; !b3) || (!b1 &amp;&amp; !b2 &amp;&amp; b3)&#123;</span><br><span class="line">         res = <span class="built_in">append</span>(res, word)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="506-相对名次">506. 相对名次</h3><p>给出<strong>N</strong>名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（“Gold Medal”, “Silver Medal”, “Bronze Medal”）。</p><p>(注：分数越高的选手，排名越靠前。)</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [5, 4, 3, 2, 1]<br><strong>输出:</strong>  [“Gold Medal”, “Silver Medal”, “Bronze Medal”, “4”, “5”]<br><strong>解释:</strong>  前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” (“Gold Medal”, “Silver Medal” and “Bronze Medal”).<br>余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。</p></blockquote><p><strong>提示:</strong></p><ol><li>N是一个正整数并且不会超过 10000。</li><li>所有运动员的成绩都不相同。</li></ol><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><ol><li>将原位置存入Hash</li><li>排序</li><li>循环排序后的数组，从map中出去原位置作为下标加入返回数组中</li></ol></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRelativeRanks</span><span class="params">(score []<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">   mapList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(score))</span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> score &#123;</span><br><span class="line">      mapList[v] = k</span><br><span class="line">   &#125;</span><br><span class="line">   sort.Ints(score)</span><br><span class="line">   res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(score))</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(score); i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(score)-i == <span class="number">1</span> &#123;</span><br><span class="line">         res[mapList[score[i]]] = <span class="string">&quot;Gold Medal&quot;</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(score)-i == <span class="number">2</span> &#123;</span><br><span class="line">         res[mapList[score[i]]] = <span class="string">&quot;Silver Medal&quot;</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(score)-i == <span class="number">3</span> &#123;</span><br><span class="line">         res[mapList[score[i]]] = <span class="string">&quot;Bronze Medal&quot;</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      res[mapList[score[i]]] = strconv.Itoa(<span class="built_in">len</span>(score) - i)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="575-分糖果">575. 分糖果</h3><p>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果<strong>平均</strong>分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> candies = [1,1,2,2,3,3]<br><strong>输出:</strong> 3<br><strong>解析:</strong> 一共有三种种类的糖果，每一种都有两个。<br>最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</p></blockquote><p><strong>示例 2 :</strong></p><blockquote><p><strong>输入:</strong> candies = [1,1,2,3]<br><strong>输出:</strong> 2<br><strong>解析:</strong> 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。</p></blockquote><p><strong>注意:</strong></p><ol><li>数组的长度为[2, 10,000]，并且确定为偶数。</li><li>数组中数字的大小在范围[-100,000, 100,000]内。</li></ol><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>因为是平均分配，所以妹妹糖果的情况为：</p><ul><li>最多：所有糖果数量的一半(此时糖果种类大于等于糖果总数的一半)</li><li>最少：1种(所有糖果为一类)</li></ul><p>所以妹妹获得糖果种类为：<code>min(总数的一半,糖果种类)</code></p></div><h4 id="示例代码：排序">示例代码：排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distributeCandies</span><span class="params">(candyType []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   sort.Ints(candyType)</span><br><span class="line">   count := <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(candyType) &amp;&amp; count &lt; <span class="built_in">len</span>(candyType)/<span class="number">2</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> candyType[i] != candyType[i<span class="number">-1</span>] &#123;</span><br><span class="line">         count++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例代码：map">示例代码：Map</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distributeCandies</span><span class="params">(candyType []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   mapList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;, <span class="number">0</span> )</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> candyType &#123;</span><br><span class="line">      mapList[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(mapList) &lt; <span class="built_in">len</span>(candyType)/<span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">len</span>(mapList)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(candyType)/<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-数组系列3</title>
      <link href="skill/algorithm/56303.html"/>
      <url>skill/algorithm/56303.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="204-计数质数">204. 计数质数</h3><p><img src="https://cdn.inkdp.cn/img/20210713143946.png" alt="image-20210713143946282"></p><div class="tabs" id="204"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#204-1">枚举</button></li><li class="tab"><button type="button" data-href="#204-2">埃氏筛</button></li><li class="tab"><button type="button" data-href="#204-3">埃氏筛</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="204-1"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>根据质数定义可知，除了1和它本身意外不再有其他因数的自然数。对于每一个<code>x</code>，我们可以枚举<code>[2, x-1]</code>中的每个数<code>y</code>，判断<code>y</code>是否是<code>x</code>的因数。如果<code>y</code>是<code>x</code>的因数，那么<code>y</code>永远在<code>[2, √x]</code>范围内</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countPrimes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> isPrime(i) &#123;</span><br><span class="line">         count++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPrime</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">2</span>; i*i &lt;= x; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> x%i == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="204-2"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95">厄拉多塞筛法</a>的定义不再详细解释，大致的意思是：如果<code>x</code>是质数，那么<code>2x</code>，<code>3x</code>，<code>4x</code>….一定不是质数。定义一个数组<code>isPrime</code>表示是否为质数，如果<code>isPrime[i]</code>是质数，就将<code>i</code>的倍数全部标记为非质数。</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countPrimes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">   isPrime := <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      isPrime[i] = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> isPrime[i] &#123;</span><br><span class="line">         count++</span><br><span class="line">         <span class="keyword">for</span> j := i * <span class="number">2</span>; j &lt; n; j += i &#123;</span><br><span class="line">            isPrime[j] = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="204-3"><!-- tab 线性筛 --><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>思路来自于埃氏筛，我们将已知的质数存放与一个数组中，遍历数组取出质数<code>x</code>，我们不再标记<code>x</code>的倍数，而是标记质数集合每一项与当前<code>i</code>乘积，切当<code>i</code>为质数倍数时结束当前标记，避免了重复标记</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countPrimes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   primes := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">   isPrime := <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      isPrime[i] = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> isPrime[i] &#123;</span><br><span class="line">         primes = <span class="built_in">append</span>(primes, i)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> _, prime := <span class="keyword">range</span> primes &#123;</span><br><span class="line">         <span class="keyword">if</span> i*prime &gt;= n &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         isPrime[i*prime] = <span class="literal">false</span></span><br><span class="line">         <span class="keyword">if</span> i%prime == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="303-区域和检索-数组不可变">303. 区域和检索 - 数组不可变</h3><p><img src="https://cdn.inkdp.cn/img/20210713165305.png" alt="image-20210713165305675"></p><div class="tabs" id="303"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#303-1">直接计算</button></li><li class="tab"><button type="button" data-href="#303-2">前缀和</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="303-1"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>将原数组存放在NumArray中，在SumRange中求<code>i</code>到<code>j</code>的和即可</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">   sums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">NumArray</span></span> &#123;</span><br><span class="line">   sums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">   <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      sums[i] = v</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> NumArray&#123;sums: sums&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span> <span class="title">SumRange</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">      count += this.sums[i]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="303-2"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>假设数组<code>nums</code>的长度为<code>n</code>，创建长度为<code>n+1</code>的数组<code>sums</code>，对于<code>0 ≤ i &lt; n</code>都有<code>sums[i+1] = sums[i] + nums[i]</code>，<code>sums[i]</code>表示了<code>nums</code>从下标<code>0</code>到<code>i-1</code>的前缀和，因为前缀和数组<code>sums</code>的长度为<code>n+1</code>的缘故，不需要对<code>i = 0</code>进行额外处理，所以：<code>sumRange(i,j)=sums[j+1]−sums[i]</code></p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">   sums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">NumArray</span></span> &#123;</span><br><span class="line">   sums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      sums[i+<span class="number">1</span>] = sums[i] + num <span class="comment">// sum[i+1]存储nums[i]的前缀和</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> NumArray&#123;sums: sums&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span> <span class="title">SumRange</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> this.sums[right+<span class="number">1</span>] - this.sums[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="349-两个数组的交集">349. 两个数组的交集</h3><p><img src="https://cdn.inkdp.cn/img/20210714143501.png" alt="image-20210713173412962"></p><div class="tabs" id="349"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#349-1">Map</button></li><li class="tab"><button type="button" data-href="#349-2">排序加双指针</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="349-1"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>创建<code>key</code>为<code>int</code>，<code>value</code>为<code>bool</code>的map，遍历<code>nums1</code>，将数值的元素为<code>key</code>值为<code>true</code>存入map，循环<code>nums2</code>，判断map中是否存在，存在则表示此数在两数组中同事存在，为了避免重复添加，将值改为<code>flase</code>，判断是改为map中存在切值为<code>true</code>。</p><p>处于节省空间考虑，建立map数组时应尽量使用较小的数组</p></div><h4 id="实例代码">实例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2)&#123; <span class="comment">// 遍历较小的数组生成map</span></span><br><span class="line">      intersection(nums2, nums1)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> intersection []<span class="keyword">int</span></span><br><span class="line">   mapList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">      mapList[v] = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">      <span class="keyword">if</span> _, ok := mapList[v]; ok &amp;&amp; mapList[v] &#123;</span><br><span class="line">         intersection = <span class="built_in">append</span>(intersection, v)</span><br><span class="line">         mapList[v] = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> intersection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="349-2"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>先对两个数组排序，然后双指针循环两个数组，判断指针指向的数是否相等，若相等，则指针后移，交集中不存在则添加值交集数组中，指针所在数不相等则判断两数的大小，较小的数指针后移</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> intersection []<span class="keyword">int</span></span><br><span class="line">   sort.Ints(nums1)</span><br><span class="line">   sort.Ints(nums2)</span><br><span class="line">   <span class="keyword">for</span> i,j := <span class="number">0</span>,<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums1) &amp;&amp; j &lt;<span class="built_in">len</span>(nums2); &#123;</span><br><span class="line">      <span class="keyword">if</span> nums1[i] == nums2[j] &#123;</span><br><span class="line">         <span class="keyword">if</span> intersection == <span class="literal">nil</span> || intersection[<span class="built_in">len</span>(intersection)<span class="number">-1</span>] != nums1[i] &#123;</span><br><span class="line">            intersection = <span class="built_in">append</span>(intersection, nums1[i])</span><br><span class="line">         &#125;</span><br><span class="line">         i++</span><br><span class="line">         j++</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums1[i] &gt; nums2[j]&#123;</span><br><span class="line">         j++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         i++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> intersection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="350-两个数的交集-ii">350. 两个数的交集 II</h3><p><img src="https://cdn.inkdp.cn/img/20210714111828.png" alt="image-20210714111828350"></p><div class="tabs" id="350"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#350-1">Map</button></li><li class="tab"><button type="button" data-href="#350-2">排序+双指针</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="350-1"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>基于349的map思路，将map的值由bool换成int，循环第一个数组时，记录出现的值的次数，循环第二个数组时判断是否存在且剩余个数大于1则添加为交集</p></div><h4 id="实例代码">实例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &gt; <span class="built_in">len</span>(nums2) &#123; <span class="comment">// 遍历较小的数组生成map</span></span><br><span class="line">      intersect(nums2, nums1)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> intersection []<span class="keyword">int</span></span><br><span class="line">   mapList := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">      mapList[v] ++</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">      <span class="keyword">if</span> _, ok := mapList[v]; ok &amp;&amp; mapList[v] &gt; <span class="number">0</span> &#123;</span><br><span class="line">         intersection = <span class="built_in">append</span>(intersection, v)</span><br><span class="line">         mapList[v] --</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> intersection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="350-2"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>因为不需要去重，所以对于两个排好序的数组，直接遍历即可，遇到相同的就添加，不相同时较小的后移</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> intersection []<span class="keyword">int</span></span><br><span class="line">   sort.Ints(nums1)</span><br><span class="line">   sort.Ints(nums2)</span><br><span class="line">   <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums1) &amp;&amp; j &lt; <span class="built_in">len</span>(nums2); &#123;</span><br><span class="line">      <span class="keyword">if</span> nums1[i] == nums2[j] &#123;</span><br><span class="line">         intersection = <span class="built_in">append</span>(intersection, nums1[i])</span><br><span class="line">         i++</span><br><span class="line">         j++</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i] &gt; nums2[j] &#123;</span><br><span class="line">         j++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         i++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> intersection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="453-最小操作次数使数组元素相同">453. 最小操作次数使数组元素相同</h3><p><img src="https://cdn.inkdp.cn/img/20210714150911.png" alt="image-20210714150911830"></p><div class="tabs" id="453"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#453-1">排序</button></li><li class="tab"><button type="button" data-href="#453-2">排序优化</button></li><li class="tab"><button type="button" data-href="#453-3">动态规划</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="453-1"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>先看示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3] &#x3D;&gt; [2,3,3] &#x3D;&gt; [3,4,3] &#x3D;&gt; [4,4,4]  3</span><br><span class="line">[1,3,5] &#x3D;&gt; [2,4,5] &#x3D;&gt; [3,5,5] &#x3D;&gt; [4,5,6] &#x3D;&gt; [5,7,5] &#x3D;&gt; [6,7,6] &#x3D;&gt; [7,7,7]  6</span><br><span class="line">[1,2,5] &#x3D;&gt; [2,3,5] &#x3D;&gt; [3,4,5] &#x3D;&gt; [4,5,5] &#x3D;&gt; [5,6,5] &#x3D;&gt; [6,6,6] 5</span><br><span class="line">[1,2,3,4] &#x3D;&gt; [2,3,4,4] &#x3D;&gt; [3,4,5,4] &#x3D;&gt; [4,5,6,4] &#x3D;&gt; [5,6,6,5] &#x3D;&gt; [6,6,7,6] &#x3D;&gt; [7,7,7,7]  6</span><br></pre></td></tr></table></figure><p>根据以上示例可知，假设数组是有序，每一位加上与最小位相差的数既得到最终的次数以<code>[1,2,5]</code>为例，第一位和第二位加<code>4</code>后可得<code>[5,6,5]</code>，排序可得<code>[5,5,6]</code>，重复上述步骤加<code>1</code>，得到<code>[6,6,6]</code>，共操作5次</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMoves</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   sort.Ints(nums)</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">      count += nums[i] - nums[<span class="number">0</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="453-2"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>基于排序的思路我们不难发现最终操作次数为数组中所有数组与最小值差的和，也即是数组的和减去N个最小值</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMoves</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   count, min := <span class="number">0</span>, math.MaxInt32</span><br><span class="line">   <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      count += num</span><br><span class="line">      <span class="keyword">if</span> min &gt; num &#123;</span><br><span class="line">         min = num</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count - <span class="built_in">len</span>(nums)*min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="453-3"><h4 id="解题思路">解题思路</h4><div class="note no-icon info simple"><p>假设数组时有序的，数组长度为3，那么要是三个数相等，可以分两步做</p><ul><li>先使前两个数相等，则需要移动次数为<code>nums[1]-nums[0]</code>记为<code>moves</code>。注意：<mark class="hl-label green">此时第三个数以静发生了变化，增大了<code>moves</code>，<code>新arr[2]=原arr[2]+moves</code></mark></li><li>此时前两个数已经相等，相等的数可以看做一个数，此时则需要让后两个数相等，让<code>num[1]</code>等于<code>新num[2]</code>，则需要移动<code>新nums[2] - nums[1] = 原nums[2] + moves - nums[1]</code>记为<code>diff2</code>，最终结果为<code>moves = moves + newmoves</code></li></ul><p>当数组长度大于3时，依照上面方式递推即可</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMoves</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   sort.Ints(nums)</span><br><span class="line">   <span class="keyword">var</span> moves <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">      diff := moves + nums[i]- nums[i<span class="number">-1</span>]</span><br><span class="line">      nums[i] += moves <span class="comment">// 这里比较难理解,此时相加的实际上是完成上一次操作中的改变nums[2]</span></span><br><span class="line">      moves += diff</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> moves</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="455-分发饼干">455. 分发饼干</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子<code>i</code>，都有一个胃口值<code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干<code>j</code>，都有一个尺寸<code>s[j]</code> 。如果<code>s[j] &gt;= g[i]</code>，我们可以将这个饼干<code>j</code>分配给孩子<code>i</code>，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入</strong>: g = [1,2,3], s = [1,1]<br><strong>输出</strong>: 1<br><strong>解释</strong>:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入</strong>: g = [1,2], s = [1,2,3]<br><strong>输出</strong>: 2<br><strong>解释</strong>:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><h4 id="解题思路">解题思路</h4><div class="note no-icon simple info simple"><p>直接将两个两个数组排序，然后双指针的方式向后移，当满足<code>g[i] &lt;= s[j]</code>的时候，将饼干<code>j</code>分配给孩子<code>i</code>，<code>i</code>和<code>j</code>同时后移为下一个孩子分配饼干；不满足时<code>j</code>后移知道满足</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="keyword">int</span>, s []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   sort.Ints(g)</span><br><span class="line">   sort.Ints(s)</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span>    i,j := <span class="number">0</span>,<span class="number">0</span>; i&lt;<span class="built_in">len</span>(g) &amp;&amp; j &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">      <span class="keyword">if</span> g[i] &lt;= s[j] &#123; <span class="comment">// 满足即分配</span></span><br><span class="line">         count ++</span><br><span class="line">         i++</span><br><span class="line">         j++</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">// 寻找符合孩子胃口的饼干</span></span><br><span class="line">         j ++</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为你的Api加上Swagger</title>
      <link href="skill/back-end/21173.html"/>
      <url>skill/back-end/21173.html</url>
      
        <content type="html"><![CDATA[<p>  一个好的API项目，文档是必不可少的，一份标准的API文档给前后端的沟通带来很多便利。手写，那自然是不可能的。<code>Swagger</code>可通过注释的方式实现接口文档，而且生成的接口文档可直接进行请求已完成测试。</p><h1 id="安装swagger">安装Swagger</h1><ul><li><p>go get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;swaggo&#x2F;swag&#x2F;cmd&#x2F;swag</span><br></pre></td></tr></table></figure><p>因为swagger需要全局使用，请确保 <code>$GOPATH/bin</code> 加入<code>$PATH</code>，或将可执行文件移动到<code>$GOBIN</code>下</p></li><li><p>验证是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ swag -v</span><br><span class="line">swag version v1.7.0</span><br></pre></td></tr></table></figure></li></ul><h1 id="gin-swagger">gin-swagger</h1><p>项目地址:<a href="https://github.com/swaggo/gin-swagger">https://github.com/swaggo/gin-swagger</a></p><h2 id="引入包">引入包</h2><p>在路由所在文件引入以下包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   swaggerFiles <span class="string">&quot;github.com/swaggo/files&quot;</span></span><br><span class="line">   ginSwagger <span class="string">&quot;github.com/swaggo/gin-swagger&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="编写api描述">编写API描述</h2><p>在<code>main.go</code>函数前添加项目描述文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @title Swagger 生成文档测试</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @description 这是一个Swagger文档生成测试</span></span><br><span class="line"><span class="comment">// @host localhost:8088</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://github.com/swaggo/swag/blob/master/README_zh-CN.md#%E5%A6%82%E4%BD%95%E4%B8%8Egin%E9%9B%86%E6%88%90">官方示例</a>，书写对应所需内容</p><h2 id="编写api注释">编写API注释</h2><p>先看看官方的示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Summary Show a account</span></span><br><span class="line"><span class="comment">// @Description get string by ID</span></span><br><span class="line"><span class="comment">// @ID get-string-by-int</span></span><br><span class="line"><span class="comment">// @Accept  json</span></span><br><span class="line"><span class="comment">// @Produce  json</span></span><br><span class="line"><span class="comment">// @Param id path int true &quot;Account ID&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; model.Account</span></span><br><span class="line"><span class="comment">// @Header 200 &#123;string&#125; Token &quot;qwerty&quot;</span></span><br><span class="line"><span class="comment">// @Failure 400,404 &#123;object&#125; httputil.HTTPError</span></span><br><span class="line"><span class="comment">// @Failure 500 &#123;object&#125; httputil.HTTPError</span></span><br><span class="line"><span class="comment">// @Failure default &#123;object&#125; httputil.DefaultError</span></span><br><span class="line"><span class="comment">// @Router /accounts/&#123;id&#125; [get]</span></span><br></pre></td></tr></table></figure><p>参照<code>Swagger</code>的注解规范以及实际情况编写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Summary 获取标签</span></span><br><span class="line"><span class="comment">// @Description 通过id获取标签</span></span><br><span class="line"><span class="comment">// @ID get-string-by-int</span></span><br><span class="line"><span class="comment">// @Accept  json</span></span><br><span class="line"><span class="comment">// @Produce  json</span></span><br><span class="line"><span class="comment">// @Param id query int true &quot;标签id&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; TagData</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;object&#125; HTTPError</span></span><br><span class="line"><span class="comment">// @Router /tag [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tag)</span> <span class="title">Get</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Summary 添加标签</span></span><br><span class="line"><span class="comment">// @Description 添加标签</span></span><br><span class="line"><span class="comment">// @Accept  json</span></span><br><span class="line"><span class="comment">// @Produce  json</span></span><br><span class="line"><span class="comment">// @Param account body TagData true &quot;标签内容&quot;</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;object&#125; HTTPOk</span></span><br><span class="line"><span class="comment">// @Failure 400 &#123;object&#125; HTTPError</span></span><br><span class="line"><span class="comment">// @Router /tag [POST]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tag)</span> <span class="title">Add</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成">生成</h2><p>到你的项目文件下执行生成命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">❯ swag init</span><br><span class="line">2021/03/31 23:38:59 Generate swagger docs....</span><br><span class="line">2021/03/31 23:38:59 Generate general API Info, search dir:./</span><br><span class="line">2021/03/31 23:38:59 Generating controller.TagData</span><br><span class="line">2021/03/31 23:38:59 Generating controller.HTTPError</span><br><span class="line">2021/03/31 23:38:59 Generating controller.HTTPOk</span><br><span class="line">2021/03/31 23:38:59 create docs.go at docs/docs.go</span><br><span class="line">2021/03/31 23:38:59 create swagger.json at docs/swagger.json</span><br><span class="line">2021/03/31 23:38:59 create swagger.yaml at docs/swagger.yaml</span><br></pre></td></tr></table></figure><p>执行成功后会在项目根目录生成文件<code>docs</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docs&#x2F;</span><br><span class="line">├────   docs.go</span><br><span class="line">├────   swagger.json</span><br><span class="line">└────   swagger.yaml</span><br></pre></td></tr></table></figure><h2 id="引入">引入</h2><p>在<code>main.go</code>中引入包<code>docs</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;goweb/docs&quot;</span></span><br></pre></td></tr></table></figure><h2 id="验证">验证</h2><p>运行项目，访问一下 <code>http://127.0.0.1:8088/swagger/index.html</code>， 查看 <code>API</code> 文档生成是否正确</p><p><img src="https://cdn.inkdp.cn/img/image-20210331234603894.png" alt="image-20210331234603894"></p><h2 id="参考">参考</h2><ul><li>本文源代码: <a href="https://github.com/gooohlan/goweb.git">goweb</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go读取和删除照片Exif隐私信息</title>
      <link href="skill/48989.html"/>
      <url>skill/48989.html</url>
      
        <content type="html"><![CDATA[<h1 id="exif">Exif</h1><p><strong>可交换图像文件格式</strong>（英语：Exchangeable image file format，官方简称<strong>Exif</strong>），是专门为数码相机的照片设定的文件格式，可以记录数码照片的属性信息和拍摄数据。</p><p>通过手机或者相机拍摄的照片中会携带Exif信息，而某些手机默认会携带地理位置等隐私信息，比如下面这张图片</p><p><img src="https://cdn.inkdp.cn/img/IMG_20210125_191526.jpg" alt="IMG_20210125_191526"></p><p>它的Exif信息为：<br><img src="https://cdn.inkdp.cn/img/20210125183002.png" alt=""></p><p>可以直接看到该照片使用<strong>Redmi K30 Pro</strong>拍摄于<strong>2021:01:25 19:15:28</strong>，甚至还可以直接看到经纬度信息(手机设置中可关闭)。这种未经过处理的照片直接上传到网上之后，可能会造成隐私的泄露。</p><h1 id="go读取exif信息">Go读取Exif信息</h1><p>通过包<a href="https://github.com/rwcarlsen/goexif">goexif/exif</a>，可以查看照片的全部Exif信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetExif</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   ImgFile := <span class="string">&quot;./IMG_20210125_191526.jpg&quot;</span></span><br><span class="line">   file, err := os.Open(ImgFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> file.Close()</span><br><span class="line">   x, err := exif.Decode(file)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v&quot;</span>, x)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没找到直接操作图片Exif的库(如果有欢迎留言告诉我)，只能通过解析图片的色彩空间，然后通过此色彩空间重新生成一张新的图片因为是重新生成的图片，也就相当于抹除了Exif信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNewImage</span><span class="params">(f, newF *os.File)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   m, _, err := image.Decode(f)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取宽高</span></span><br><span class="line">   width, height := m.Bounds().Max.X, m.Bounds().Max.Y</span><br><span class="line">   <span class="keyword">var</span> subImage image.Image</span><br><span class="line">   img := m.(*image.YCbCr)</span><br><span class="line">   subImage = img.SubImage(image.Rect(<span class="number">0</span>, <span class="number">0</span>, width, height)).(*image.YCbCr)</span><br><span class="line">   err = jpeg.Encode(newF, subImage, &amp;jpeg.Options&#123;<span class="number">100</span>&#125;)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="所有代码：">所有代码：</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;image&quot;</span></span><br><span class="line">   _ <span class="string">&quot;image/gif&quot;</span></span><br><span class="line">   <span class="string">&quot;image/jpeg&quot;</span></span><br><span class="line">   _ <span class="string">&quot;image/jpeg&quot;</span></span><br><span class="line">   _ <span class="string">&quot;image/png&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;path&quot;</span></span><br><span class="line">   <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;github.com/rwcarlsen/goexif/exif&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ImgFile := <span class="string">&quot;./IMG_20210125_191526.jpg&quot;</span></span><br><span class="line">   fileNameWithSuffix := path.Base(ImgFile)                        <span class="comment">// 获取文件名带后缀</span></span><br><span class="line">   imgType := path.Ext(fileNameWithSuffix)                         <span class="comment">// 获取文件后缀</span></span><br><span class="line">   fileNameOnly := strings.TrimSuffix(fileNameWithSuffix, imgType) <span class="comment">// 获取文件名</span></span><br><span class="line">   newImageFile := fileNameOnly + <span class="string">&quot;_no_exif&quot;</span> + imgType</span><br><span class="line">   file, err := os.Open(ImgFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;打开文件失败&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> file.Close()</span><br><span class="line">   err = GetExif(file)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置文件偏移,重新从第一位开始读取</span></span><br><span class="line">   file.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">   newFile, err := os.Create(newImageFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;file create fail&quot;</span>)</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">   err = CreateNewImage(file, newFile)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetExif</span><span class="params">(file *os.File)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   x, err := exif.Decode(file)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%+v&quot;</span>, x)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNewImage</span><span class="params">(f, newF *os.File)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   m, _, err := image.Decode(f)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取宽高</span></span><br><span class="line">   width, height := m.Bounds().Max.X, m.Bounds().Max.Y</span><br><span class="line">   <span class="keyword">var</span> subImage image.Image</span><br><span class="line">   img := m.(*image.YCbCr)</span><br><span class="line">   subImage = img.SubImage(image.Rect(<span class="number">0</span>, <span class="number">0</span>, width, height)).(*image.YCbCr)</span><br><span class="line">   err = jpeg.Encode(newF, subImage, &amp;jpeg.Options&#123;<span class="number">100</span>&#125;)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(*os.File, error)</span></span> &#123;</span><br><span class="line">   f, err := os.Create(fileName) <span class="comment">// 创建文件</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;file create fail&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-数组系列2</title>
      <link href="skill/algorithm/51727.html"/>
      <url>skill/algorithm/51727.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="566-重塑矩阵">566. 重塑矩阵</h3><p><img src="https://cdn.inkdp.cn/img/image-20210122002325449.png" alt="image-20210122002325449"></p><div class="tabs" id="566"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#566-1">方法一</button></li><li class="tab"><button type="button" data-href="#566-2">方法二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="566-1"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>创建固定的行，依次循环原数组，同时放入结果数组中，每一行存满后，就添加新的列继续存储</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixReshape</span><span class="params">(nums [][]<span class="keyword">int</span>, r <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">   x, y := <span class="built_in">len</span>(nums), <span class="built_in">len</span>(nums[<span class="number">0</span>])</span><br><span class="line">   <span class="keyword">if</span> r*c != x*y &#123;</span><br><span class="line">      <span class="keyword">return</span> nums</span><br><span class="line">   &#125;</span><br><span class="line">   i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">   arr := <span class="built_in">make</span>([][]<span class="keyword">int</span>, r)</span><br><span class="line">   <span class="keyword">for</span> _, row := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> row &#123;</span><br><span class="line">         arr[i] = <span class="built_in">append</span>(arr[i], v)</span><br><span class="line">         j++</span><br><span class="line">         <span class="keyword">if</span> j == c &#123;</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            i++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="566-2"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>将二维数组通过列行遍历改变为一维数组，我们会惊讶的发现原数组的下标<code>nums[i][j]</code>变成了一维数组<code>newNums[n*i+j]</code>,其中<code>n</code>为原二维数组的列数。二维数组的下标<code>i</code>和<code>j</code>可以分别表示了在第<code>i</code>行，第<code>j</code>列，由此我们可将一维数组<code>newNums[i]</code>变回二维数组<code>nums[i/c][i%c]</code>,其中<code>c</code>为二维数组的列数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums := [][]<span class="keyword">int</span>&#123;</span><br><span class="line">[]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">[]<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">newNums := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>值<code>5</code>在两个数组中分别表示为<code>nums[1][1]</code>和<code>nums[4]</code>，<code>1(i)*3(n)+1(j) = 4(i)</code>，<code>[1(4/3)][1(4%3)]</code>符合上述推导，故二维数组的转换都可基于一维数组实现</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixReshape2</span><span class="params">(nums [][]<span class="keyword">int</span>, r <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">x, y := <span class="built_in">len</span>(nums), <span class="built_in">len</span>(nums[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> r*c != x*y &#123;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line">newNums := <span class="built_in">make</span>([][]<span class="keyword">int</span>, r)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i++ &#123;</span><br><span class="line">newNums[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r*c; i++ &#123;</span><br><span class="line"><span class="comment">// 两个二维数组都是基于同一个一维数组变化而来,他们在一维数组中的值是相等的</span></span><br><span class="line">newNums[i/c][i%c] = nums[i/y][i%y]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newNums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="605-种花问题">605. 种花问题</h3><p><img src="https://cdn.inkdp.cn/img/image-20210123141345851.png" alt="605.种花问题"></p><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>数组由<code>0</code>和<code>1</code>组成，循环一次数组，并分别处理即可</p><ul><li>当前元素为<code>1</code>表示有花，根据规则，下一次有花必定是两格后，直接跳到<code>i+2</code>处即可</li><li>当前元素为<code>0</code>表示没有话，因为遇到花就会跳两个，所以前一个位置必定不是花，我们只需要判断下一格是否为<code>1</code>即可，不为<code>1</code>或者当前格子已经是最后一格，即可种，执行<code>n--</code>，然后此格变成了<code>1</code>，继续往后跳两格；如果是<code>1</code>，则不可种，两格后也不可种，直接跳三格即可</li></ul><p>循环结束后查看<code>n</code>是否为<code>0</code>，为<code>0</code>则表示可种<code>n</code>朵花，返回<code>true</code>，反之返回<code>false</code></p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPlaceFlowers</span><span class="params">(flowerbed []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(flowerbed) &amp;&amp; n &gt; <span class="number">0</span>; &#123;</span><br><span class="line">      <span class="keyword">if</span> flowerbed[i] == <span class="number">1</span> &#123; <span class="comment">// 当前格子已经有花,我们两格后见</span></span><br><span class="line">         i += <span class="number">2</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == <span class="built_in">len</span>(flowerbed)<span class="number">-1</span> || flowerbed[i+<span class="number">1</span>] == <span class="number">0</span> &#123; <span class="comment">// 当前格子不是花,下一个格子也不是花或着当前格子已经是最后一个</span></span><br><span class="line">         n--</span><br><span class="line">         i += <span class="number">2</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前格子不是花,但是下一格是</span></span><br><span class="line">         i += <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> n == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="628-三个数的最大乘积">628. 三个数的最大乘积</h3><p><img src="https://cdn.inkdp.cn/img/image-20210123145818480.png" alt="628. 三个数的最大乘积"></p><div class="tabs" id="628"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#628-1">方法一</button></li><li class="tab"><button type="button" data-href="#628-2">方法二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="628-1"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>首先将数组排序，再根据数组内的数是正负数进行处理</p><ul><li>数组中的数全部为正数或者全部为负数时，最大乘机为最大的三个数</li><li>数组中包含正数与负数，则最大乘积有可能是最大三个正数的乘积，也有可能是两个最小负数与最大正数的乘积</li></ul></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumProduct</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   sort.Ints(nums)</span><br><span class="line">   l := <span class="built_in">len</span>(nums)</span><br><span class="line">   <span class="keyword">return</span> max(nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[l<span class="number">-1</span>], nums[l<span class="number">-1</span>]*nums[l<span class="number">-2</span>]*nums[l<span class="number">-3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a&gt;b &#123;</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="628-2"><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>由方法一得知，我们所需的只是最大的3个数以及最小的两个数而已，直接循环一次找出这5个数即可，不用排序。</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumProduct2</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   min1, min2 := math.MaxInt64, math.MinInt64</span><br><span class="line">   max1, max2, max3 := math.MinInt64, math.MinInt64, math.MinInt64</span><br><span class="line">   <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">      <span class="keyword">if</span> v &lt; min1 &#123;</span><br><span class="line">         min1, min2 = v, min1</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> v &lt; min2 &#123;</span><br><span class="line">         min2 = v</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> v &gt; max1 &#123;</span><br><span class="line">         max1, max2, max3 = v, max1, max2</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> v &gt; max2 &#123;</span><br><span class="line">         max2, max3 = v, max2</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> v &gt; max3 &#123;</span><br><span class="line">         max3 = v</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max(min1*min2*max1, max1*max2*max3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="643-子数组最大平均数i">643. 子数组最大平均数I</h3><p><img src="https://cdn.inkdp.cn/img/image-20210123181732046.png" alt="643"></p><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>使用窗口滑动的方式：先求出<code>0-k</code>的和<code>sum</code>，再往后依次遍历，求出最大的后除以K即可</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxAverage</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> maxSum, sum <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">      sum += nums[i]</span><br><span class="line">   &#125;</span><br><span class="line">   maxSum = sum</span><br><span class="line">   <span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">      sum += nums[i] - nums[i-k]</span><br><span class="line">      <span class="keyword">if</span> sum &gt; maxSum &#123;</span><br><span class="line">         maxSum = sum</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">float64</span>(maxSum) / <span class="keyword">float64</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="661-图片平滑器">661. 图片平滑器</h3><p><img src="https://cdn.inkdp.cn/img/image-20210123211333512.png" alt="image-20210123211333512"></p><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>循环遍历找到每个格子，找所有 9 个包括它自身在内的紧邻的格子，去除无用的格子，将他们的和存在当前位置中，同时记录邻居个数，最后用和除以个数即可。</p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imageSmoother</span><span class="params">(M [][]<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x, y = <span class="built_in">len</span>(M), <span class="built_in">len</span>(M[<span class="number">0</span>])</span><br><span class="line">   newM := <span class="built_in">make</span>([][]<span class="keyword">int</span>, x)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; x; i++ &#123;</span><br><span class="line">      newM[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, y)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; x; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; y; j++ &#123;</span><br><span class="line">         <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">         <span class="comment">// 寻找邻居格子</span></span><br><span class="line">         <span class="keyword">for</span> ii := i<span class="number">-1</span>; ii &lt;= i+<span class="number">1</span>; ii++ &#123;</span><br><span class="line">            <span class="keyword">for</span> jj := j<span class="number">-1</span>; jj &lt;= j+<span class="number">1</span>; jj++ &#123;</span><br><span class="line">               <span class="keyword">if</span> ii &gt;=<span class="number">0</span> &amp;&amp; ii &lt; x &amp;&amp; jj &gt;=<span class="number">0</span> &amp;&amp; jj &lt; y &#123; <span class="comment">// 去除超出原数组范围的数据</span></span><br><span class="line">                  newM[i][j] += M[ii][jj]</span><br><span class="line">                  count ++</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         newM[i][j] /= count</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="665-非递减数列">665. 非递减数列</h3><p><img src="https://cdn.inkdp.cn/img/image-20210124001206690.png" alt="665. 非递减数列"></p><h4 id="解题思路">解题思路</h4><div class="note info no-icon simple"><p>这道题给了我们一个数组，说我们最多有1次修改某个数字的机会，<br>问能不能将数组变为非递减数组。题目中给的例子太少，不能覆盖所有情况，我们再来看下面三个例子：<br>4，2，3<br>-1，4，2，3<br>2，3，3，2，4<br>我们通过分析上面三个例子可以发现，当我们发现后面的数字小于前面的数字产生冲突后，<br>[1]有时候需要修改前面较大的数字(比如前两个例子需要修改4)，<br>[2]有时候却要修改后面较小的那个数字(比如前第三个例子需要修改2)，<br>那么有什么内在规律吗？是有的，判断当前数字(<code>nums[i]</code>)跟再前面一个数(<code>nums[i-2]</code>)的大小有关系，<br>首先如果再前面的数(<code>nums[i-2]</code>)不存在，比如例子1，4前面没有数字了，我们直接修改前面的数字(<code>nums[i-1]</code>)为当前的数字(<code>nums[i]</code>)2即可。<br>而当再前面的数字(<code>nums[i-2]</code>)存在，并且小于当前数(<code>nums[i]</code>)时，比如例子2，-1小于2，我们还是需要修改前面的数字(<code>nums[i-2]</code>)4为当前数字(<code>nums[i]</code>)2；<br>如果再前面的数(<code>nums[i-2]</code>)大于当前数(<code>nums[i]</code>)，比如例子3，3大于2，我们需要修改当前数(<code>nums[i]</code>)2为前面的数3(<code>nums[i-1]</code>)。</p><p>参考：<a href="https://leetcode-cn.com/problems/non-decreasing-array/comments/59727">https://leetcode-cn.com/problems/non-decreasing-array/comments/59727</a></p></div><h4 id="示例代码">示例代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPossibility</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums) &amp;&amp; count &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">if</span> nums[i<span class="number">-1</span>] &lt;= nums[i] &#123;</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      count++</span><br><span class="line">      <span class="keyword">if</span> i &gt;= <span class="number">2</span> &amp;&amp; nums[i<span class="number">-2</span>] &gt; nums[i] &#123;</span><br><span class="line">         nums[i] = nums[i<span class="number">-1</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         nums[i<span class="number">-1</span>] = nums[i]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count &lt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB GO Driver 实现模糊查询</title>
      <link href="skill/back-end/61018.html"/>
      <url>skill/back-end/61018.html</url>
      
        <content type="html"><![CDATA[<h1 id="mongodb的模糊查询">MongoDB的模糊查询</h1><p>  模糊查询时数据库应用中不可缺少的一步，<strong>MySQL</strong>中使用<code>like</code>和或者<code>regexp</code>来实现实现模糊查询，而<strong>MongoDB</strong>则使用<code>$regex</code>操作符或直接使用正则表达式对象来实现。</p><table><thead><tr><th style="text-align:left">MySQL</th><th style="text-align:left">MongoDB</th></tr></thead><tbody><tr><td style="text-align:left">select * from users where name like ’%InkDP%’</td><td style="text-align:left">db.users.find({name: {$regex: /InkDP/}})</td></tr><tr><td style="text-align:left">select * from users where name regexp ’InkDP’</td><td style="text-align:left">db.users.find({name: /InkDP/})</td></tr></tbody></table><p>更多相关的语法可查看官方文档：<a href="https://docs.mongodb.com/manual/reference/operator/query/regex/">$regex</a>，就不再做多讨论。</p><h1 id="使用mongodb-go-driver进行查询">使用MongoDB GO Driver进行查询</h1><p>先来看看我们的数据源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> db.users.find(&#123;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc3&quot;), &quot;name&quot; : &quot;1InkDP&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc4&quot;), &quot;name&quot; : &quot;InkDPPP&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc5&quot;), &quot;name&quot; : &quot;InkDP&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc6&quot;), &quot;name&quot; : &quot;inkdp123&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc7&quot;), &quot;name&quot; : &quot;abcdef&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;60070500fc9b483f284d0bc8&quot;), &quot;name&quot; : &quot;test&quot; &#125;</span><br></pre></td></tr></table></figure><p>然后执行模糊查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.users.find(&#123;name:&#123;$regex: /InkDP/,$options: &quot;i&quot;&#125;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc3&quot;), &quot;name&quot; : &quot;1InkDP&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc4&quot;), &quot;name&quot; : &quot;InkDPPP&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc5&quot;), &quot;name&quot; : &quot;InkDP&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;600704fffc9b483f284d0bc6&quot;), &quot;name&quot; : &quot;inkdp123&quot; &#125;</span><br></pre></td></tr></table></figure><h2 id="错误尝试">错误尝试</h2><p>上述方式是MongoDB的命令行的执行方式，如果我们直接在Go里面直接这样写是行不通的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.M&#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: bson.M&#123;</span><br><span class="line">      <span class="string">&quot;$regex&quot;</span>:   <span class="string">&quot;/InkDP/&quot;</span>,</span><br><span class="line">      <span class="string">&quot;$options&quot;</span>: <span class="string">&quot;i&quot;</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你兴高采烈地拿着上面的查询条件去查询时，你会发现它会返回一个空数组给你</p><h2 id="正确的使用方式">正确的使用方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.M&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: primitive.Regex&#123;</span><br><span class="line">Pattern:<span class="string">&quot;/InkDP/&quot;</span>,</span><br><span class="line">Options: <span class="string">&quot;i&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后发现还是没有，一番查找后才发现<code>Pattern</code>不再额外需要两个<code>/</code>，直接填写正则内容即可，所以我们改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.M&#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: primitive.Regex&#123;</span><br><span class="line">      Pattern:<span class="string">&quot;InkDP&quot;</span>,</span><br><span class="line">      Options: <span class="string">&quot;i&quot;</span>,</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;ID:ObjectID(&quot;600704fffc9b483f284d0bc3&quot;) Name:1InkDP&#125;</span><br><span class="line">&#123;ID:ObjectID(&quot;600704fffc9b483f284d0bc4&quot;) Name:InkDPPP&#125;</span><br><span class="line">&#123;ID:ObjectID(&quot;600704fffc9b483f284d0bc5&quot;) Name:InkDP&#125;</span><br><span class="line">&#123;ID:ObjectID(&quot;600704fffc9b483f284d0bc6&quot;) Name:inkdp123&#125;</span><br></pre></td></tr></table></figure><p>与命令行查找的一致，说明没有问题</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitHub Action自动部署Hexo</title>
      <link href="skill/front-end/3295.html"/>
      <url>skill/front-end/3295.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  <code>Hexo</code>+<code>Github Page</code>让很多没用服务器的人也拥有了自己的博客，添加好配置文件后可以通过<code>hexo d</code>直接部署到服务器上，这种方式部署到<code>Github Page</code>是挺方便，但是如果要部署到自己的服务器就比较麻烦，得编译后再上传到自己的服务器。</p><p>  Github Actions 可以很方便实现 CI/CD 工作流，通过它可以实现抓取代码、运行测试、登录远程服务器，发布到第三方服务等等，我们使用它来自动部署博客到想部署的位置。</p><h1 id="思路">思路</h1><p>  建立<code>yourname.github.io</code>库，本地写好文章后推送到<code>hexo</code>分支，自动编译后部署到<code>master</code>分支，然后在上传到我自己的服务器，这样就实现了<a href="https://inkdp.github.io">inkdp.github.io</a>和<a href="https://inkdp.cn">inkdp.cn</a>的同时部署。</p><h1 id="开始">开始</h1><h2 id="创建所需仓库">创建所需仓库</h2><p>创建<code>yourname.github.io</code>库，并创建<code>hexo</code>分支，<code>hexo</code>分支用户存储博客源码，默认的<code>master</code>分支用于存放编译好的GitHub源码。</p><h2 id="配置部署密钥">配置部署密钥</h2><p>使用以下命令生成部署密钥(一路回车到底即可)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f gh-pages -N &quot;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> You will get 2 files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   gh-pages.pub (public key)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   gh-pages     (private key)</span></span><br></pre></td></tr></table></figure><p><font color="#dd0000">切记将生成的密钥文件添加到<code>.gitignore</code>中！！！</font></p><p>接下来,去仓库设置</p><ul><li><p>复制<code>gh-pages.pub</code>的内容，仓库的 <code>Settings -&gt; Deploy keys -&gt; Add deploy key</code> 页面粘贴你的内容，<code>Title</code>可随意填写，<font color="#dd0000">并勾选<code>Allow write access</code>，实测可不配置</font></p></li><li><p>复制<code>gh-pages</code>的内容，去仓库的<code>Settings -&gt; Secrets -&gt; Add a new secret</code> 页面上粘贴你的内容，<code>Name</code>字段填写为<code>ACTION_DEPLOY_KEY(可更改)</code></p><table><thead><tr><th>添加你的公钥</th><th>成功</th></tr></thead><tbody><tr><td><img src="https://cdn.inkdp.cn/img/image-20210117235120550.png" alt="image-20210117235120550"></td><td><img src="https://cdn.inkdp.cn/img/image-20210117235147362.png" alt="image-20210117235147362"></td></tr></tbody></table><table><thead><tr><th>添加你的私钥</th><th>成功</th></tr></thead><tbody><tr><td><img src="https://cdn.inkdp.cn/img/image-20210117235828106.png" alt="image-20210117235828106"></td><td><img src="https://cdn.inkdp.cn/img/image-20210117235912296.png" alt="image-20210117235912296"></td></tr></tbody></table><p><code>GitHub Secret</code>可以用来存储一些私密内容，类似一些私钥，Key之类的，在CI中通过<code>$&#123;&#123; Secret Name&#125;&#125;</code>取出对应的值</p></li></ul><h2 id="编写-github-actions">编写 Github Actions</h2><p>在<code>yourname.github.io</code>创建仓库根目录下创建 <code>.github/workflows/HexoCI.yml</code> 文件，目录结构如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">├── .github</span><br><span class="line">│   └── workflows</span><br><span class="line">│       └── HexoCI.yml</span><br></pre></td></tr></table></figure><p>编写<code>HexoCI.yml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">name: CI</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - hexo</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: 切换分支</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line"></span><br><span class="line">      - name: 安装依赖</span><br><span class="line">        if: steps.cache.outputs.cache-hit != &#x27;true&#x27;</span><br><span class="line">        run: npm ci</span><br><span class="line"></span><br><span class="line">      - name: 清除Hexo</span><br><span class="line">        uses: heowc/action-hexo@main</span><br><span class="line">        with:</span><br><span class="line">          args: clean</span><br><span class="line"></span><br><span class="line">      - name: 生成Hexo</span><br><span class="line">        uses: heowc/action-hexo@main</span><br><span class="line">        with:</span><br><span class="line">          args: generate</span><br><span class="line"></span><br><span class="line">      - name: 部署到master分支</span><br><span class="line">        uses: peaceiris/actions-gh-pages@v3</span><br><span class="line">        with:</span><br><span class="line">          personal_token: $&#123;&#123; secrets.CI_TOKEN &#125;&#125;</span><br><span class="line">          external_repository: inkdp/inkdp.github.io</span><br><span class="line">          publish_branch: master</span><br><span class="line">          publish_dir: ./public</span><br></pre></td></tr></table></figure><h3 id="模版参数说明">模版参数说明</h3><ul><li><p><em>name</em> 为此 Action 的名字</p></li><li><p><em>on</em> 触发条件，当满足条件时会触发此任务，这里的 <code>on.push.branches.$.hexo</code>是指当 <code>hexo</code> 分支收到 <code>push</code> 后执行任务</p></li><li><p><em>jobs</em> 为此 Action 下的任务列表</p><ul><li><em>jobs.{job}.name</em> 任务名称</li><li><em>jobs.{job}.runs-on</em> 任务所需容器，可选值：<code>ubuntu-latest</code>、<code>windows-latest</code>、<code>macos-latest</code>。</li></ul><ul><li>jobs.{job}.steps* 一个步骤数组，可以把所要干的事分步骤放到这里。<ul><li><em>jobs.{job}.steps.$.name</em> 步骤名，编译时会会以 LOG 形式输出。</li><li><em>jobs.{job}.steps.$.uses</em> 所要调用的 Action，可以到 <a href="https://github.com/actions">https://github.com/actions</a> 查看更多。</li><li><em>jobs.{job}.steps.$.with</em> 一个对象，调用 Action 传的参数，具体可以查看所使用 Action 的说明。</li></ul></li><li><em>env</em> 为环境变量对象，用于放置一些环节变量</li></ul></li></ul><h3 id="第三方-actions">第三方 Actions</h3><p>使用第三方 Actions 语法 <code>&#123;owner&#125;/&#123;repo&#125;@&#123;ref&#125;</code> 或者 <code>&#123;owner&#125;/&#123;repo&#125;/&#123;path&#125;@&#123;ref&#125;</code> 例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - name: 切换分支</span><br><span class="line">    uses: actions/checkout@v2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: 清除Hexo</span><br><span class="line">  uses: heowc/action-hexo@main</span><br><span class="line">  with:</span><br><span class="line">    args: clean</span><br></pre></td></tr></table></figure><p>我使用的大部分都是第三方的Actions，更多第三方Actions可查看<a href="https://github.com/marketplace?type=actions&amp;query=checkout">官方 Actions 市场</a></p><p>可以根据自己的需求书写对应的配置文件，可以参考我的<a href="https://github.com/gooohlan/inkdp.github.io/blob/hexo/.github/workflows/HexoCI.yml">HexoCI.yml</a></p><h3 id="额外配置">额外配置</h3><p>因为上述配置文件使用了第三方<strong>Actions:<a href="https://github.com/peaceiris/actions-gh-pages">peaceiris/actions-gh-pages</a></strong>，所以需要额外配置<strong>个人访问令牌</strong>，配置路径<code>你的头像 -&gt; Settings -&gt; Personal access tokens -&gt; Personal access tokens -&gt; Generate new token</code>，勾选<code> repo</code>即可，创建成功后复制生成的<code>token</code>，回到项目设置中，参考第二步中配置私钥的方式，将<code>token</code>填入<code>Value</code>，再配置一个<code>Name</code>即可，下例中的<code>CI_TOKEN</code>就是我配置的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- name: 部署到master分支</span><br><span class="line">   uses: peaceiris/actions-gh-pages@v3</span><br><span class="line">   with:</span><br><span class="line">     personal_token: $&#123;&#123; secrets.CI_TOKEN &#125;&#125;</span><br><span class="line">     external_repository: inkdp/inkdp.github.io</span><br><span class="line">     publish_branch: master</span><br><span class="line">     publish_dir: ./public</span><br></pre></td></tr></table></figure><table><thead><tr><th>配置个人访问令牌</th><th>成功</th></tr></thead><tbody><tr><td><img src="https://cdn.inkdp.cn/img/image-20210118005047841.png" alt="image-20210118005047841"></td><td><img src="https://cdn.inkdp.cn/img/image-20210118005143713.png" alt="image-20210118005143713"></td></tr></tbody></table><h3 id="部署到个人服务器-可选">部署到个人服务器(可选)</h3><p>通过配置私钥到<code>GitHub Secret</code>实现服务器的免密登录，再<code>scp</code>编译好的静态页面到你的服务器，参考如下配置，其中<code>ACTION_DEPLOY_KEY</code>为免密登录的私钥，<code>SERVER_DIR</code>为服务器地址及目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- name: 部署到个人服务器</span><br><span class="line">  env:</span><br><span class="line">    ACTION_DEPLOY_KEY: $&#123;&#123; secrets.ACTION_DEPLOY_KEY &#125;&#125;</span><br><span class="line">    SERVER_DIR: $&#123;&#123; secrets.SERVER_DIR &#125;&#125;</span><br><span class="line">  run: |</span><br><span class="line">    mkdir -p ~/.ssh/</span><br><span class="line">    echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class="line">    chmod 600 ~/.ssh/id_rsa</span><br><span class="line">    mv ./public ./www</span><br><span class="line">    scp -o StrictHostKeyChecking=no -r ./www $SERVER_DIR</span><br></pre></td></tr></table></figure><h3 id="上传配置文件">上传配置文件</h3><p><code>push</code>到<code>yourname.github.io</code>的<code>hexo</code>分支，到此仓库的<code>Actions</code> 页面查看当前 task</p><p><img src="https://cdn.inkdp.cn/img/image-20210118014615951.png" alt="image-20210118014615951"></p><p>当任务完成后查看您的博客 <code>https://yourname.github.io</code>，如果不出意外的话已经可以看到自动部署的文章了，如有意外欢迎留言</p><h3 id="可能出现的问题">可能出现的问题</h3><ul><li><p>问题1：</p><p><img src="https://cdn.inkdp.cn/img/20210622202346.png" alt="image-20210622202346107"></p><p>出现该问题是node版本过低导致的，在<code>yaml</code>文件中指定node版本为<code>12+</code>，或者设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何读一本书</title>
      <link href="reading/38859.html"/>
      <url>reading/38859.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.inkdp.cn/img/%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B.svg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年个人总结</title>
      <link href="/2020.html"/>
      <url>/2020.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6ec2c51ede834930976e41c9366271371c9b1e713f64ceb3786edad9b46cfd56">b9cc9643baf4dcc59b37da2f24103eaccefe58073ae15acb17a69c6037edc4686470b4bafa04e564bf9dc1aed95843f10f67115e7fb6448bb0c7012688b008c366b64eb91d96f1f3183518c313cd6c9f1417878076a370dfbeb937d0fd3ad60cd501a0470d58ca374378f3dbc188213c592358c8dc8ed66c1f94f7e39cb789f14a9d78603f8673d307535539c7205e3308fa1e77c7512e4754bfe3f1ccecb2e3573d50bfd20ca81b77e54de0ade1cf5c2def802450999e8c9a327fceac03a3bdc864d8ebd536ec12f7d5ba55bd9b4dcce70dda5fe6a3a8d2b7b55c3fc5f99deed86f5643cb35a127a780a355d1231addb6e04b6870d341e794e8b050d1ac301c926339f359a6058a0a5fcee48a6c7827aa518ebec0237fadc4debe2345128d8254c9c82229cb38d4e53753cd4cffca9e7624df25f32592cea628cbc885b799b78a50c740cddb7dbad4ccf3269d4cbf8f2652bc5726206d7c88ccdc5052e0ca79085395a8c2393701ebddf6fa4c276e045ccd2a4aeb5fe39bf6ae164f9e97c8b1b03b0a0b430eaae05cd8f69e149c878961393fb20881ff718f505e259560cbed0f90f78d12e85d7f5c2c2bc6b173e6d53766f9527c9e40d2aa95b76832772e0921888b61aaab796be7263dd92ea0a63e41073a1d1ca21aeeb7595083037ea623eec485a6a6106bf275a7a3505afaa2e30ce5d65f0e39e3fd86789a4be309393e4ea8c7ffc0f7d6a6f227939f1984160b993b3b994a65850951ac04ed24f7d99551a91f99dfe8bd6edd1ed16de342fe1b1d0503073c3f4d61d103b9a6038383f7bd223004a6865e047870d63ef18f60956d5ca551c929bb9f90fead9af7edb08b2a359a7dd73a300153a3fd68b98545d1c62171d72e94069e244e68eafefecf8526232c6ffeae96bb5cd55e19d934c66d4f1cb808eac64ce8779c7ce868563fb1d057678a4fc6ecfbc26f082055114f68ede10fcc14dd2d5f9e644a24c55604fed484e9e1cda1013c529b181c4b7e1ff65dca36cab8415188426904465054b2ed6501ab7cc01855620919048524de3255af6d101add7d32b511f27ebec6bd45d09f7b7e1d633f702e76b148ae618a12130d35808afad1ecf383fae510046dd118bfaf9e5ed6876e0b0117a1ff5583857943cc7733a5ec1d64ac64bf13e4674a8a2b907509c5b46a870ccea29823e6c4bf415710f0e0e358a295d46502d21817a6adf814008ad1c4b8ae235353e95079198ab488938b35f53d3b6c40e2e0fc2dd7e8f27af5569a08e6c08892f65831d2de0e58a430cfa57de9e05bf5a3bdd91273e950b870545ce9a8ed01b87d69bdfe3be2597f890f7fb3c1b7914db35054d9c84f3ebab8bea7761e80a15e41c0e2fbb7ca13e2f1216851e1bc8d79c193fe1e4df087d779eecbb99d963c4fd3d396316192fc7c953d5eba32278ea425942604ebefa1ca6bacd45b6a23b918f78ded6f28387cabf95932e4944a8e832e1686223d0a0fc105dccddedefcaa171df6e99ce83fc06b2f9fe2c9b40780e99cdfe807979f06cf92c6160365d5520993a23c289063f0d89032df197c5816b9c4232a32ccc3956d7725d8d37818ba051ba944c89f7a92ba01eef7ffcd47a3263a61ba8868bfaeb7a9319a878579adaa418f24fe9b00e38e7ef9302a001cd6013ba2e1ea2c74ec68917a8ad0da391beeec45f3c0eb0a44d007b1943ffffe5f25ecca1bb18f0d79de7cf7f2ba521a9bc4e0e07f0d2812877b2772cc2e7c204582581c4275b6cab6e9e2d097e253eaa5da78a5954694d309d08d71d43f90f85bfa1c3a3f3ac780c09b3c9f512126f0605d8b7e86630127c95e5f1665146873be1297a43c90e13d13405ae9fc8174f47d0998ad62ce9c21070941544dc76e3804cc20cd60bf3e3e32e9260e646dc809ada316e79ff9a95761c90fbe769b747de4de33128519078f3de4d0fd5eb3081cce3c0017bda273f068d2eaed5dcaa2ddeab0d90863d30a7ee8b672cc5d2b367a32c882885264add7e353a19694fe1cf8334c90866df78444a19a073fb07eba13b9b9a12a7471576fa8f01307b53a3dc2800866ef9da32fb23fe535ce9f370ee6e9395eab656ae94d90d8c7cf67903108b9a81b3cf7f9b43b6317d1f059f29a3854d2ded08e32f304d6a6207f368afd6fa2ea37b9237eeaf3e13db420494dd612c7377ab9c90fd6a3397d192d750731e7770eeffd52a9a1a28931f65e6d4ac235a0e51a2de402da6a9e81e2d429b0ada3a06ae7aed716fca864c6684355736796fb97b71124223d11a3fc3e9880be4699f59b7a15c2406aaca6a05dfd8988e36cd49d817f96f23130dfe55ba4b5aa30f95ada34a636f7751d7d559cd07a57e24bb69f1c85cbbd66bb63a52b41e153b28ef83c1090075fe600bb3696cd7213cf61f6e33256518b3c25fff4babab934289cd2394fa4305a901465713c3b24b45b548a86a7086869ebf91c113344fe14596db5ad27eafe2418ca8afd64365fbda4a6b389987e5f01cbfaef0f4551a06d05adc3e85dd4a54d152267732e1a74981e984c956c35e6af4d73067be710af895aa0c68f77881bd23609c7df271a56b1f8d1788506cfe04cf4adcaced4702dfc053531040a28a048cd520f8d322a861db1ca03008367f30b39d193ac87ea45a9ee9dc88be74101af362a26c3785f60d4236650e94fb6176914d59665b69d9fc7da691c5fae108db49754bb4adfb0fcdf51f7a76a6145ed89c3c9ca432e8ab7b0440fd46ab1c19e03fc57839011e75a249d9f18ddc39307c44e351662b07287a165efd583c59f1c79dec5933fb6ce0d17ac58a346076f442a997b3e6f7e558c6791c51dae8327f63cf9117bd5af35286ff3641664e996d1007b254ee39bdf4bc85607311e64dd348e63d7a94de1f8210d02ed0b9f44f87a50133ab7cf5fc5d1390f0ea17c4947ece9357236a012a02b9c4078cacd0a451bf31d35c8ac02b538eaf06718d3b630811e302b4257259a8f7c6255037ff260c7e02d152c44ab5923b9893f89b3bdd563229c6780139afe0854ffa738124bb232ff5f2d4dd81b4ead0a23ecb68e30847b3ea51d7bfded39c00bac6eb4574ac0c19cbec9b54dc4b73a747e0f3ff2a10ac53072ff1a78b4446817077dc9e017ee813044e01b1289f7fff64c9bae021bd25f0312e795882fbf23b2f2f2aad538e62464704d07ffe55cb816d3ab76d6dc2c4ddbaa32797ed253b85e67350e3e442e58c6fdc617b0819da5881ca41a82044cbbb49cf569e647ca131237a7d825158585554b48d74886ae42f50e7988d68ac89d4f18d46bc9ae257601d783bd9ad567ca799e8f84a4d0ce872a1323848a0794a469694bcdfc148a1cc57f26262e3763dc5906eec622acd77ca149f985ec24bffceb9d6159e836170712544afaf4fcf9257341fef3c30001d45a61e080baf426efd5d66bb0566fccc5eb7dc17ca21a4dd04a51a7ca0243298385b169734c6b8f6adebc20da33b423eb98de1e02a073009929c89ea9f8d19d4bcc6dbb0c8920042828c45ec9aa4f772ab6ff4709182479651dfdd814c706ed033ca2666d2bd50365105f9b8a47061ebb1eab5717741cb767138944b4449be9ab34891eb0f21eef8053874d6b8e32b42bb5cf2e9e1bea30a10085f2ab1ba31d7bb6022923e8a2b64e81633d3cc239b015a21adc096dce9840f620f426eac5038d83cc7f29f43906dfd4d7fe7e829a9296f08d7e699bdfeb8f7ee5ca85b7db7c8bbff83691ff0e8503d5fc7b4a2f5df3229a03606927fe33dfed2b3820f6a22c1fa0f4d6e474863e60ec78bd89a85e02be3c4a282ea4930870d8796c4653623e843854eaea9c2d6fbe6625e5a65546b2dce7920b784405d8e251bc81097c737a0b34a19f777433e9c0979592ae097b80827935808191fee10c486d20df3ec1816adb11051da0afa8a9616f9e08cb17f060eea81922c1b89011c2505abdcb46fc56713bc169a25ae6a0f1f6576fc6d10fe9ec4e554e64f670691e57536127245c966e70080cf28f5055dde5822862fc1b42e49bf85fe67852285e5d9372094c405973d0c026e2e7dddcb83e35c48ceb4a02c24c8c829235d97ebe56466dd2bfedf52d573f7cbfcde95e162c5b412376c54a3a80175eddd4d1a39c31e2305ee45a8709e721acb2c45537f8f086065d021d95bd69338c030778d48d5ec7217831fb2ccb6aa9f12b3452b183508d8094b0907fb7d51c3ec0f41df19a76df5212e4f1dfe826ac3ced1d26d6bb19b1dc128a34a690cb70cb9529a95224472447ad9bff5cb2df60c75b2c45375533f69aef014fb9922bf668957178e42c37238735e00be3adb3d4a7955f87d55014de210eb0eb08368d8043243c4825a1755ae88dbf6a030c346f57ecf8ae2b34a913bf2a50fcd43388fb2c1ec17b998d31756cba268d42536a2c65762b752966b49db589a930272cc0cb9ea178c3afd27f6f25590d9d88590e977913092d1da5787481fbe77eec6135d0bd15ff711ace829fe38c7ef8080b0b02254a6dac005c8a2b377d24b932e75922373f66cf2ecefce64251f41ccfaca3aab51f7a0c0b4d273353cdf490a3315400138877c4e38f14a663229b6e4b952af9e940114237475651cb4d568055ac2e375ab1b71135026f471a506e18f5e46d6e45c55502659d93c6c487a1c7de23b025b95df2cd424098e179aadac3db224232ff15ebe098a24f04c9381f6d9f3bde6aa2713a3b24015472dce67cac6b3d5e3bf7120d696586b7a2bdec4fc9e5cbf6bde8532187f1cb51c84e21f4166e367fc35c0a170846e419c8bcb10017e9604e4508e96df20be47da661f1bc7ca914b799fad6400ef7ccd65621131f3852c29582d589b22a1af81faf1f12ff0f4843394d4ded1b0121b8ec4d9ad03b412f17dc6592bd1cb2267113209053cca95b47af945aaf13524753f172583c06d0ebd6f7752d0408d56f88ba4a3920c14aa9f3b741f910c66c68cd0e463e254c58828ab9a58afef021d9e56eb4e278c4bf07f27accefc7b923ece9afe734f4757012d5b867084acd4e807534e91f9ed6141a3b1c92d7814862ef4d151fa2e94317647fbf6caa07e20a615bcb76f5da77d19b5d148fd27ff5451272d4a105ade2393fa51907e06f82b119c604f88cbf1c089f77ee4e4062febf79f8f89fd70a560639694eac428ac51150cb1bcbeebe9b4cd9732272e2620c786edb55bae4819263322c3358f3815c40f7896ae0cf6a70ec06b114e20bc8ef66910bb083faa4fc3cdebcbcf793d824a249f8582bf1ee98f733f17adec86846bac4c2a130688710f3faa127abdd9ea4a3bc3bed5894e72632f63c7fa1194f508da5b572b889d6bc3a39a0f492637e1a475dbbfe7c48594b7e4533ca593a46051e91958f23535f80b854f506c50732821e2fedae7845ad329e14ff808859e83161e89da66f1fa259e5f27681d87972ab3a07da47e8e515a0b62bcbc715212459fb1646551e6c7c9fd1bc0753e40df60ba86b32c57e7dc9e5b89b2c645370890d306747b037c74d4d843c06aff4a4a1916551bb358aebb4593973578923785a760ea6f0c35aaa73bdcfcee4963ff47a5d5c5b7899b55247aa46b5c36fbcee6e2cba62dc8d06ed5d6e6d226b1802541a9ad540d206111d5507273c4bfa647e84d1a658c5fe20b098d5fc8ad6718369aed10366d3e30b15eabe8d34354783298be3dc4428925f4a1ca8c6cdf988010260ef8df677a3f924708c03d65d39c64ada8d63bb7c9a54b0ce57be2d55b7f8a3cad849c8eaa65a2617eb1060f5364b2ec304ac7bcaf2fcfb02cebd81c906854db70a7266dce81d1320cbcb380bc20781af989efb511de90512ac02156ff9a5b309b8c99b3a7096a0718b533aaa4aadfec732777adf1886418fae52cb77689d9b6a4383199060a692f0414e07e875c78ca26a0e9e202deb91ce4b20bfe8441474ab1f19e3b33bbf342e99e135ccbf3360f146a655a0c4c56e82348da139cee44fd9172fae4a26860ee82f55a09ac3a0874219043e2d8f47b330dcf9409abf838fcb0574ddafe675a73767a0b9dae9637bbf39cce0db4ad1b079a6a3d3eaac7b3442f3f4f30b00eb90e2488ba4026c70b5a5a301ed335a9fccbb08b373cd6a4dfa06cf3b27cfc12a22f2022ae1b509bdd08aac27274206bf0a0c7573e55a688d3d0e88919a5d154e6490dc99a96d6cc9d1b12a1807011bac3ef4d40796b6160177134b22a41d904b81f4d7dda6b53c17534e1fa091b0ba6aca61ade7321e5c1df3f24c68f644a9fc9293342d73790c42a03317e6625af84866568a861be7ee3ceba2bfd36ae3e3ff5672683082670c289e9914b0781532f68cd91519ab8989587be95e3e051093e9e86b3a0a3e87c8a0fb00aa44105c9376e492cf41e26a74c75627225e25fe16afee3c0c584cc8bf0efc5468a96197116fbf83a229c0f5110cc06e35f969bb7e645fe1ccc18ff691e0dbdd0d962b9188ad98213f068c2b1f50cb41281c978313dd524228e274b90188105d2887227788462ee8e993c6f1ba120915cc0562a36cc6d4df126c8f3689a465eb4721d9d37cb9f3726617581c524bd60bafbd4ff8a28b3193de750593844965c9a418d29fff95eb87ff795c16347b9a8fe92d8bd61c8f8a374bd5e182d53a19af32d108e672c4ccc74d6743e43c107a2047189786cf2f76dcdfe1a99f2d93b5736c5a2412530038b8307f03953f6b2ee91226ea8757e01bcf948f7fb557ff740fe8c7c067aaebf6c27b8038730c20bc170e251ae778028d9c3ecc27328d8c1712b23106173920e53f652b486c7c72e235c3c1c3567fa102715d6b4f4f5fb476316bede6b230d5c298d9ffbb5e6e89fd61f02005762c930f6a15800784b2d5d6734f23726d5c45cffe7b03bb0e7edbbcfda74d65447cf82f81f98cd4106570fd9582a672d2db5e69126ecc3f2a36e012dd45bccb17b33072ae84efc00eea3b003ba891c9b99c9c793058a0e201b2beb3b024fc5f794a306f1e3093a049f92767b158b8dd05e9a4bd46493a3d116990bccea637284151663f0fd64edcc021b9ff4e94b3ba0418f39ad69c06d96f0e7f85fc7dfe511a321510d4f2098b4a25728e156974c40a53afdad13f14a19cb495a369607b9cf1fdfd8c6cb108cb2260d09c14a03af7bd251b393435585d64da0b8df59e624e665263d68cc813644cccf7b43502d74f16c574486d82b6039c9b10cc4e4ddd1906c184ea84dc0cf1d468d22e191b8979ca0c7f110a57517ad69aa214eb09d10ed2b24ea5a6a686859c0c2d16235104f1f91a99431214c3b25435fbb730672cf27d6d12f88852d274554945c940cefec6118e55cb0952a5191abcddd23bad8e2c9cef0bad41e2ee6b2d5fd47f3df3175b618518979f31432707a76bd6f30ccfaabf50ed3a54902e7fa3d7191870a4d2490ee022dde65e5412d983ab04e57e7f1463c2822c8a8a37ad7bda933e880671f2ff6b747641d187abe3fe21d7e43b7086fc168204e3bc0ab55485e2893f82ba8ed6a59314122dd168495aed05beb1f0d8b358fd7de8d023ca62266e919010f227d4a46fb25904b5c4db7f75f92f40bed9533dd1d47592b91a3a3c2b26ed25e8fefbd24a9f5bb0ad9de050af249e893bb03258abbc03efc7fc3aa2118108fb50152a7ca40ffcedaf7a9348e21e7bbf1be99333600d7df4233281dedebce3a497b13b158788d1676f3c879b92399e10942689a5bde6fe3576befa0adc2ec93b2a8b16b28cdb6259ff8435ac6e5bc711636d36686d160f15c3cdcd406e10d79067b30f1799eb24b336feab3bf5bcfd87bd5c421557fcb58904aac1874275dfe4bec9aecfd83526aecf2b1dc5f1ad63cd20def1cbdfe71d8582b1a2cc154ede817447f23033a8069b4b5ad65358c2e11a91e43802e42448b0e90250c01d311d2df5254384202c45dd41adb3de35f86bbcbde6d17a713a14e2c4fd3957191b18bbdf4cdda9d82e71dc4669f32fdea911dc08a6013592c7ba901c117e1ac4cbfc2e1cb028ccc16b1ff1b6c8dadc29f0236c2df549a7621cd4356237b48f11ac20fe9a03a3bfcbdff3472e387e08d239a1de5818b22fa0b30913c498362eb56ce136c80b3c19e4004eea3c88b9de4b3aa3d028463d519d303d14cb9c4a1ec210d82fe09d7d14d8d01fa1426b0ea76ca6e506278b5dffb5003085c98c8b2449360d13d27a5a57312be3d1ba2cd253ae13ba818d4a22ce9c990fc3b82a88fe7193b8e9e1783be689c6e5d068166a261f8ff692055360e7474e2cff9970233004fdafdb751604dc3f291f542cce11c79dcbf424e3922c7ab3753db832c36cd09ae556a96553f671be0dac84cce1993b9e32f03b5ffe9e7d997e54f793f7bb32dff727952bc6f0e157be0e8f55589762b447f2cfa7b286b38a5d3a2addb9e5524f827ae0d1b93e1b8ec6da8cb6dfd8e1347ccd7c054e8030c74f24fc01595f60a936ae3d85d494c592ae6ae7cd7072af9e32dfaeaab80c74cce3ccf1ba7fc454bda354f3e68fcf83c2bbb0ae5a6a17dea10da82c016cdbe6b694fd1ba97f3039bbf1f750a3db221be0be6694eaad691b4591bfe643b41b6ae5891e3f198d4d46c4ca324be474a853f09388b69b4fb6f99af3df91a46ceef0a5d34161a0e7f544f0252d87a2368f8cba8d3cd04fd1c4067f784cfea45dba72237df1fa83014f09a410c080c0d6320488745275c09f94f9546bdb50c64ca2513515cea030700011115d3e5c977af4d06154b8465b11ec5b3e405883827992d5cdfcb7dd568e069d74c9a383ec88ff10bb492579ff6e0765e12a10149678b2166ff2becfc4df58a54f1a5dae1a9bddec2a249d43b6887ff17da3795fd6615ad524f8a6af080293a43ed0798c9e0791c32ce25496acdec2fc387d628ea110314f0ff20d6fcb9f32182c457b8d841e420865e2174ed032b66611f5be5b9712deb8eeeba9fd07428903e0a65639762add4593de2b5a9812e0f30e2fbbe28da775544bd7cdb2595677544c3f365d72f043d4538e043d12f2c42828b279bad1425faf4b05c6a452db11a25eff9faedefe0d1d5eb6b24ada42873f0db54103e91721a65ea796df0c2a1354eaa683e88d27ef05ef6741e775c3904cf1bbd1f9a06628ca783e7de2a6dbb7a1c4005fcac70abe6dd1f43a04b34e3723d98dec9fd60f9d2d364aba989ca3cbe54fb72c8425ac09fc9919520f2c500f16b15bd3b7c81cb6338d5cd4883b584b9643fce4abe4a69e540b8e2548d76c4b17812e008955c9af364fab459ca080202d54f7da15b549ce2d81002fa6a107f4ce3c4ed7b98b1404b80856d7c6d2b0a6fbddef402f59cb649683fa7abedb3b09a644f24db77010c95c4829cde9b81f033566e13c14a90bcb94604022afec2edf66cda65fccd3335736c636edf6a157a334dd26d2fcf9737fe4b075d9fc08abb227766a8328abb1f28e49eee3f92743b159798c35497138b59d9e2543568486b8e62a9de16aba45f04d5ece3e56c62342d7d972e050b798dfaf0615974b209466245f5f8b2f52c6c69a7e80feb919f21d524af0eb5f52640ce9fea787b0222635a2461adacb866f7f6b07f78b1e76dbaa45120a5e3c59e99350442b0b84a3b3d5cc68a4a178d429494ef7da0e5f481e71eea4db3e5ad9ede98e360aba35d714d5ff7844ccdcc6aded1d1848c6951c84b534fa1a5d6405797b9b9a62caf72709b21c0f2a9ea672ba84ead23916b98e6b93207abc4ad8be5a3c80e179a0129b3c3f3d4724781cc7d19b02ed7b5abfa2ef06b7534e2f3aef4c5d634e52a11bf7536939ba27ea8f4ddb13082a3e787c6110360f0aed5345da24c408ebf369c310af7d0b8961faf0a58f54f8c075a7c03294f68b95ef610d814c6f2625af6ffefdf11b0fa24686b751750cc115662e32a1c45e46d7953d8cd9b591bc55b83e7806c73a6d48d6427d9386c9699c090d2be2c7ff55a95dfbee9d6791c092c2cf8950c7a080959a9cbda9dc6dbfc71a69ed44dcc203e56bdada8e1e2495fae75288b0d4559b155f21f24e93723a3edc379ed9a8c411945f82a24e6bf522162e7866a88e91321bd7e27c29bb778bf3e0eb2602da4654099545ed0b140dd60ef8523a8f5dc7a3c16053cda6682c2b8ec7fe3333a38207ba05373b92c48cbfa3969680ddf73c2c4bbe9941e6e51e485f29014dbe738d8d4d50de3f2dfdeb3b272edc52a118f54890316d3ea46b8c862dea24866f0652762d2b66e1280cade88f98b809463e130b608bfcbb10658f7a29e20a957030122a6d6b66e6d5bcf049c52597ae6f5e9d8e1e9918928b3c3b24bdabee4378a4cd50ca4101c30acdb97798ba4f413c7aa80407cbfae73eacef9631ed2a775d52c9ad1db220488771838a87d3638071392af998946a1607fff8456fe528af09940cd8b80f8ef091660605239a2c18c572518f00797fa6266bd837bc314651d61b9abc7faf9ad17ed56cf1a3a2d959443d815cb8039b3b5cbf25f7548e592f5f5d5519d9def879cfa7e484cec1756a4162648c5070c296f5f5eebf3aac8e30979d4ff921597ecfd30aabfe0211d23253bfa22502abd436846c4366e531404569203abdc3b8b6e3de36ba73a25fd8f6ec19b3eafb42fac0e78b5253648520928dd941d18a23b91ec67c0cc0d654d4e9a8cbdbdebe8f676e7821a010fab2b92eaee1467344cffd7e3080a3dd9229a6082005a9da6eea06ab256ebd834a314f81749ccfb15f5e25d7d01caa97bcdb3a0f586c8b2b68ef0dc10a5a9341f9b4a23b45ae91813f5a148505affbf03af88bf8a3d2406c45327d762ad4890ea9c01a24c3f46601109fbbd03cb0b1aa04d911d90ddbfe5530400714f716278ded1c249dd5a4c419bc7426383464fb1e492e75850a1cb16289f0b9b3ebc2514aa87165f614c23a909c23cd1ab074ed7b8aa581fad6dc67d746a68caeae76f933731a2642de45f2027c3bfdf62e87971fbbf48d703e5624f8b1012852091d83370851bbabb3ee415b1b3f600b30dedcfff2d7059b4486908a9073cf3835e969a02eb092d4dc4b3cb9bb5279607d54d41c664046437ec6663e16635d20213cdb7cd343a5363cc347e205acde3d96d7b64d6adf49b76cad03aa5f9b3eaab82d367a34d0ef10d608a6602d24b216fb80672fc19387f1d6a06849f66ca2679e5c99dcca2a248895efb7d7835231975f4225110fe32e0e676a4b0d159d27e0458d1ed3a297be8c2f565698e9dccaf8c1c4df0bb887368f7ee1f384b6555b3ebd34a495503d1dabf1da340c8c7ce3469fdaf2dca08c894f9bb02a61cb3ed98c92a7ecdff246ae9821e6be9f036ec7321be7a74041b3b57bcbd2b9e7bdb4d551481724178f8521da1a9120940be0d4288bed27ca7f863485e4ac69ab487eeb56a655600cfb371c1f579337c3a90758da44eda3898d6f0b82c9c175a6a69221e42c6c0783ffd11dd61d53ca545b158c14dcc5bcafa9ba424892d28418131e277f9b4d00bdf3a4766ef20cefeaee600c4b7bdc021523dda8e76833df74a8417bd265ca5c18cf86100673016e6ee1f4c9f385a05f538f91a7bff654c0476db65827b7f5a7625762f4c72b591ba26affcacf00bf5f54270806144271cefa188681e4d5742a0971ff4d2c811bbe7cedb8e90bef9edd0ef6fef23bcb88c2cb5e37cfd9cfe57bbfcebba8d0638a8af286f229221f9094c5b59fcf92ddd6cb5824180b00d805a6738c0ee7738c509a6a18500dfc658e80ddbc9480630c0aca095649e97039d914b5c4a723e1e97d88c1e93ad97bb5e946afe6b30d495ddca59d1967aa049df4fd9d7d80ba49909ee52a8b1dc9e5da47d9e74389a926fd59587136f7845311446ee7e4b3dca0223820d8a72bfc349e0103a16ea9e5ef9891249a014ab5dd63a778c539018b9e229c9e65177ba4ba6ad4113cdfdb19bd65e13906edb1b4852581755a7a49606a8f77c617cd716ca173f8c6442fdd8be5911c7931c0bb0c767abf98d996afb672a4b57bc0d15c366815b895f015cdc3ec27530d96d0122260affe2aa6b55b51efed709b1765054a0e9d90f5a96e01014c34a86864584c6711500916526a0b42bf9ac1a5f641e7ec0fcdc67ac07b90b44f4616e9853e537ccd3d9ddc5381f9719923ea6a30c507674f2fd8edf491d30b94ea160a23186367de32535f330ccb485413ba27962ffb8bb43a641aa2633a78c735f3ce35c3949c6a27c34ad8507c60bbd2bd2165a7d49a5f87fd141130b7b3e12445f1aff128cd6120709a0cd84fa4cc6845d73cda17330eacdadda0204368037b29bf6936d409400348e44dacad4b4d3c7a29afe2e25a59269facf1ee3504d39d1745bd8a6bfaffd0997b8a8bf18a281be23fbef690160fb7020ae7f2b6c525eb373292cf094a1f46a0304aa4da2b7667d0cbb6c26ffe521159c03111e6cac44687e9a87f806d098c704a51cfb73d0fb670fad0eadcdf2da2a97bddab3e3bde0f4ae8e9f15eb25eef5def6e66801ead765ed55867de9a7d79a32f4fa6aa64c796f8960842589d9840215d0e61bafa399d89889b2cb1d3100c669311eb97ef15986bcd2612c700edc5a23f2bd3831f697ef4c78ba7d354c99706f4cbdfbedf2a8d4a3c09e48b5ef7e02f92c8d17e1b0a385641428fa5a5c8fe50d5d049997814a800507abbc4a728d8a1b8dc6c002b23c0b878adf3f931750883f81138253d9a0ececc26ed5b1fd0a58ebe1b32f0ca4a0e9ecf6ebef74f02081f68de59d962b4cd95a2c8ce4f256b26b4a542289248e51b97ef6b94a8507a089a64e65ab1005ed33c2a6d74f1c132c97c22e3daadcd536b4eb9324b16ae2277703a345d830b70056f9981f6230ecee04880a6f1c13cc2618cbe7b5f23c275497bfda41f1e4ebb160fa6e6c412798ef959c2b60f4baaf80f8b50256548a3ee61ca5dbb3c396b64607ce9e60a40a0f3d626e67d542611902e629c73edc5256354796101098f7323e4b97457cc46e60c20fb85ffe84a15b6ce402cd67d498bf19c2df97d1db4594e2fa035be682739eafb320336e75c46dae464543e86fc553c02485c74b066138ac8c1765822359dd833aee6d06e6f2c1d3562aa5b3cd3ea03f59045d0139cc9298fc668c608456f941ae870572101af52aac17314d9695d8d702e20cd6679db6d04588580ba35e3e9656babe6a3eaef1f629aac0a0a1959984732e91d7cceaacaba58e633ac597efd0a7832078e6444ef130ec5f81a22a52b79617d274369be449d28c577a9277f63e5060a42b62b569eebc25cee70ae3711b444a4744727fb7604785bbef21d1ccb731d8c076543c4813a760af0133590a8418cef5de6fe28b8848d6d885863fae1be0144c25a1bbede256bbab98728b0d1739919c28bcb53c58687603e563e59cd9c56cfef475107d750ccee49e46d81924b28b7de15ee80c8fdbb604cee3f54e18641af838ac0221d99749f11c3ec28892acca6578fd631b01dcaf59280a0f1b2e19d3365602e72ffaa9a294ef25871a07f7e7bb21e4a8b0db4de485b23c79f1ae995b06bfbba483b09fbd9dc679353fc09aba827044d1d721fd6f2126493ef5b0fe2873722f395deb6e36a06cb39fe3c51ba3e448cf434b397c66682401a99cef4a1f8b1e9797438dfe3e4bf30c9fa4f48f134ac2124ead7e50696367207675b22702ec0563f02c7bf24b303f9714fd1f8d50b04ca12cdeb11d169b55e1463dace363b9cc8d8df82551e214e17883c186fac241f19e5a9c4673903e7f1f89cbd1a45f70b5edcf3d7bd0799e5431960283c2ddc18d6a510c9e8810429517e7a5d12e922fc19f2fd94a42c295d07088e150ac7daaeec10e9994c1454058e40b5c37dab2a28cbd0ecc885564c16b17634321985d8ccab647f56bfd0ba94b3d219db9f21510f0b06df9dc9150636e8e837a9e6212fc01dde33f279baa29783116ce9d5bb6837baa454388205b91c419211a1875cc94dd34ec984befaa36189e8490a242d4034b230706a085fe0335d68cd42a6a609e94ac4a9fb5828162376de4d220dd20c43406c3288921250074f7c75d9dbe5ba3018d6dfd5e419dcab5ba36d383ad8007b52c75e230a4817cf982516dbcae87cdae71f3622489949e6b3cf7b18d79a73a488ba8c314d31ddec13bff859a5cbb9c3b175bc4e493ab7483d152f300d063ade17b995845e93d0a67b5f97551a4b877e8adfa9672350ac36d882579aa26f272ce93276f4881fdc00fb20db9f08c72ac64b7442e8e70351385ec14864190eb871614f21bb6244d5df1018ada8612817f261f8cb1a5e59c9184d3b1437fc671ed639393a5daf54ac5d50642390783884becede2053905abe9839583ddf166f45ef1bbfd006b1e288700bef7c3a048aebcf96b544ce56bb77521894372403b676e833e86d49b84623f7b71fec64d6df4907809b3f248b73b79ef9ba614cfe21eff14692db22409bffa2b91be5915e3bee9aab60f5c4e5000813664a108a051ab5ac26a182f193ea3dcba0b3eb434082f7dc4cefa70224cd76e0f4c01e982c35d302a2d0914ba6b286c1e7008a61930a522fabce82751ee490d368dfe96fd2b0da9edf4f96ee146bfa6df2187d8aa6e70b222c8cbca6953a0fc18501524d930f5debf9dadf406f20a61d20588553473d2545f7f38437c02a9a475de0f635415b9a120431eb7d3b3fce8d487deb800a8203c244c4a8f4c9305950d27b88e5a5575894ad9f43a6eda143f8479144d918400ec1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-数组系列1</title>
      <link href="/leetcode_array1.html"/>
      <url>/leetcode_array1.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="169-多数元素">169.多数元素</h3><p><img src="https://cdn.inkdp.cn/img/image-7f596c4b.png" alt="image.png"></p><h4 id="解题思路：">解题思路：</h4><ol><li>利用哈希表存储每个字符出现的个数，出现次数大于<code>n/2</code>的即为多数元素</li><li>根据题意，多数元素的个数大于<code>n/2</code>，每次遇到多数元素就将个数+1，否则减一，值为负数时则证明当前选取的这个数不是多数元素，则更换多数元素继续循环(摩尔投票法)<br><img src="https://cdn.inkdp.cn/img/image-022d2db7.png" alt="image.png"><br>上图来着，题169解解<a href="https://leetcode-cn.com/problems/majority-element/solution/3chong-fang-fa-by-gfu-2">摩尔投票法</a></li><li>排序，取下标为<code>len(nums)/2</code>的值</li></ol><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map解法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">mapArr := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := mapArr[v]; !ok &#123;</span><br><span class="line">mapArr[v] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mapArr[v]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> mapArr &#123;</span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="built_in">len</span>(nums)/<span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement0</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">mapArr := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">mapArr[v] ++</span><br><span class="line"><span class="keyword">if</span> mapArr[v] &gt; <span class="built_in">len</span>(nums)/<span class="number">2</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目中保证了众数出现次数多余一半,所以遇到众数+1,非众数-1的最终结果始终大于1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement1</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">count, repeat := <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> v == repeat &#123;</span><br><span class="line">count++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count--</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> &amp;&amp; k&lt;<span class="built_in">len</span>(nums) &#123;</span><br><span class="line">repeat = nums[k+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> repeat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先排序直接找 len/2的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement2</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="217-多数元素">217.多数元素</h3><p><img src="https://cdn.inkdp.cn/img/image-3291f9c1.png" alt="image.png"></p><h4 id="解题思路：">解题思路：</h4><ol><li>哈希表</li></ol><h4 id="示例代码">示例代码:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">mapArr := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> mapArr[v] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">mapArr[v] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="219-存在重复元素-ii">219. 存在重复元素 II</h3><p><img src="https://cdn.inkdp.cn/img/image-b7080722.png" alt="image.png"></p><h4 id="解题思路：">解题思路：</h4><ol><li>哈希表，不存在则存入，存在这判断两个下标之间的差值是否小于k</li></ol><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsNearbyDuplicate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">mapArr := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> v, ok := mapArr[val]; ok &#123;</span><br><span class="line"><span class="keyword">if</span> key-v &lt;= k &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mapArr[val] = key</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="228-汇总区间">228. 汇总区间</h3><p><img src="https://cdn.inkdp.cn/img/image-071d61e0.png" alt="image.png"></p><h4 id="解题思路：">解题思路：</h4><ol><li>判断相邻元素差值是否为1，不分1则处于下一个区间，注意处理最后一个元素</li></ol><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">summaryRanges</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rStr []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rStr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> head, tail <span class="keyword">int</span></span><br><span class="line">head, tail = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != tail+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == tail &#123;</span><br><span class="line">rStr = <span class="built_in">append</span>(rStr, strconv.Itoa(head))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rStr = <span class="built_in">append</span>(rStr, strconv.Itoa(head)+<span class="string">&quot;-&gt;&quot;</span>+strconv.Itoa(tail))</span><br><span class="line">&#125;</span><br><span class="line">head = nums[i]</span><br><span class="line">tail = nums[i]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">tail = nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head == tail &#123;</span><br><span class="line">rStr = <span class="built_in">append</span>(rStr, strconv.Itoa(head))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rStr = <span class="built_in">append</span>(rStr, strconv.Itoa(head)+<span class="string">&quot;-&gt;&quot;</span>+strconv.Itoa(tail))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">summaryRanges1</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rStr []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i,j :=<span class="number">0</span>,<span class="number">0</span>; j&lt;<span class="built_in">len</span>(nums);&#123;</span><br><span class="line"><span class="keyword">if</span> j+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[j+<span class="number">1</span>] == nums[j]+<span class="number">1</span>&#123;</span><br><span class="line">j++</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i==j &#123;</span><br><span class="line">rStr = <span class="built_in">append</span>(rStr, strconv.Itoa(nums[i]))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">rStr = <span class="built_in">append</span>(rStr, strconv.Itoa(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + strconv.Itoa(nums[j]))</span><br><span class="line">&#125;</span><br><span class="line">i = j+<span class="number">1</span></span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="268-丢失的数字">268. 丢失的数字</h3><p><img src="https://cdn.inkdp.cn/img/image-89a5554f.png" alt="image.png"></p><h4 id="解题思路：">解题思路：</h4><ol><li>哈希表，循环一次将数组元素存下来，在循环<code>0-len(nums)</code>，不存在的就是丢失的</li><li>排序后遍历，下标和数组不相等这标识此下标树缺失</li><li>数学方式，通过高斯求和<code>n*(n+1)/2</code>算出所有的和，再减去所有的数组元素，剩下的就是丢失的树</li><li>异或运算</li></ol><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber1</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">mapArr := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">mapArr[v] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := mapArr[i]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber2</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> k != v &#123;</span><br><span class="line"><span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber3</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(nums)*(<span class="built_in">len</span>(nums)+<span class="number">1</span>)/<span class="number">2</span> - sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或位运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber4</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">miss := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">miss ^= k ^ v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> miss</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="283-移动零">283. 移动零</h3><p><img src="https://cdn.inkdp.cn/img/image-be9c99ed.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ol><li>双指针，A一直向右移动，遇到非0的与B交换即可<br><img src="https://cdn.inkdp.cn/img/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif" alt="283_2.gif"></li></ol><h4 id="示例代码：">示例代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != <span class="number">0</span> &#123;</span><br><span class="line">nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL分页查询优化</title>
      <link href="/articles/2020/10/21/1603213579436.html"/>
      <url>/articles/2020/10/21/1603213579436.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>Mysql慢查询优化，一直是开发中不可避免的问题，当然面试的时候也是。</p><p>今天的面试中，面试的最后一道题：“如何提供分页查询”，我自信的写下 <code>LIMIT</code>，认为此题十拿九稳，面试官此后的问题为当 <code>offset</code>到一定数量的时候怎么优化，因为之前没有遇到过类似的问题，而且也没有量特别大的分页，所以这个问题只能作罢。</p><h3 id="复盘">复盘</h3><p>回家后弄了个大概有快20W数据的表，实测一下，查询速度是否会因为 <code>limit</code>边大而边长。<br><img src="https://cdn.inkdp.cn/img/image-f1d086a6.png" alt="image.png"></p><p>如上图所示，同样的查询条件下，因为 <code>limit</code>增大查询速度确实变慢了很多。</p><h4 id="why">why?</h4><p>对于limit子句 <code>LIMIT [offset,] row_count</code>，官网说明如下</p><ul><li>The<code>offset</code> specifies the offset of the first row to return. The<code>offset</code> of the first row is 0, not 1.</li><li>The<code>row_count</code> specifies the maximum number of rows to return.</li><li>翻译一下就是：</li><li><code>offset</code>参数指定要返回的第一行的偏移量。第一行的偏移量为<code>0</code>，而不是<code>1</code>。</li><li><code>count</code>指定要返回的最大行数。</li><li></li></ul><p>因为要偏移到 <code>offset</code>处，所以就要先扫描前 <code>offset</code>行，所以随着 <code>limit</code>边大，也就越来越慢。</p><h4 id="解决">解决</h4><p>随意Google一下，就找到了两种解决办法，分别贴出对于SQL以作参考<br><img src="https://cdn.inkdp.cn/img/image-dbe47374.png" alt="image.png"></p><p>因为数据量小，然后数据没有特意去设计，所以整体来说效果一般，但是还是有所提升</p><h4 id="思考">思考</h4><p>针对limit的优化，更多的应该是让limit去尽量少的偏移数据，具体步骤如下：</p><ul><li>使用索引列或者主键作为<code>order by</code>操作列</li><li>记录上次查询的主键，作为下次查询时主键的筛选条件<br><img src="https://cdn.inkdp.cn/img/image-bef7270a.png" alt="image.png"></li></ul><p>参考：<a href="https://segmentfault.com/a/1190000017059239?utm_source=sf-related">性能优化之分页查询</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go爬虫初体验</title>
      <link href="/articles/2020/07/09/1594287406684.html"/>
      <url>/articles/2020/07/09/1594287406684.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>闲来无事的时候，偶尔也会看看漫画，但是鹅厂的操作大家都懂，想看最新的你就得给钱，本着白嫖精神，我找到了<a href="http://www.pufei8.com/">扑飞漫画</a>，但是这网页的阅读体验一言难尽，他家的APP也是，动不动就加载失败，一等一半天。思来想去，还是弄个爬虫把图片都爬下来，然后想法弄到kindle里面岂不美哉。因为不会Python，所以只好用GO来写了，虽然没写过，但是可以现学嘛。</p><h2 id="初识爬虫">初识爬虫</h2><p>网上找了下资料，go的写爬虫也太简单了吧，几行代码就搞定了，比如下面这样，几行代码就把整个页面拿到了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;https://www.baidu.html&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;http get error&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;read error&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得知爬虫这么简单的我笑出了声，剩下的工作也就是获取网址源码，然后正则解析出我想要的东西，循环以上步骤拿到图片地址下载即可，整体可分为三步。</p><ol><li>爬取漫画首页，获取目录标题极其链接</li><li>通过目录拿到的链接去访问图片所在页面，然后解析出图片地址</li><li>下载图片，并存储在指定页面</li></ol><p>有了如上结论的我开始奋笔疾书，然后当我进行到第二步获取图片地址的时候，发现爬下来的页面与网页实际的不一样。</p><p><img src="https://cdn.inkdp.cn/img/image-5aa0dbd7.png" alt="image.png"></p><p><img src="https://cdn.inkdp.cn/img/image-1b67caf2.png" alt="image.png"></p><p>我获取到网页内容是一个loading页面，而不是这个页面最终的状态。起初的想法是因为网页一开始打开时这样，加载完后就正常了，所以我隔几秒在读取网页内容，事实证明这样不行。</p><h2 id="意外之喜">意外之喜</h2><p>因为不知道啥原因导致的，所以也没找到解决办法，期间尝试了一下爬虫框架也依旧无果。但是也没有彻底放弃，没事就看看这页面的源码，希望能找出解决办法。</p><p><img src="https://cdn.inkdp.cn/img/image-4b9ea23b.png" alt="image.png"></p><p>乍一看是某种解密的东西，尝试运行下发现可以得到这一页的图片地址，还剩下几个变量又都是干嘛的呢，好奇之下运行了一下。</p><p><img src="https://cdn.inkdp.cn/img/image-82545a4e.png" alt="image.png"></p><p>如此一来，整个章节所有图片的地址也就都有了。问题也就是怎么在go里运行js，然后就找到了一个叫<a href="https://github.com/robertkrimen/otto">otto</a>的包，完美。</p><h2 id="开始书写">开始书写</h2><p>因为在寻找解决办法的过程中接触了一些爬虫框架，整体感觉比源码撸方便一点，主要是不用自己写正则，可以像js操作DOM节点那样找到自己想要的内容，所以就换了框架<a href="github.com/gocolly/colly">colly</a>来完成整改爬虫。</p><p>定义一个全局变量，用于存放章节与之对应的链接以及该章节下的所有图片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Catalog <span class="keyword">struct</span> &#123;</span><br><span class="line">   Title  <span class="keyword">string</span></span><br><span class="line">   Url    <span class="keyword">string</span></span><br><span class="line">   ImgArr []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> catalog []*Catalog</span><br></pre></td></tr></table></figure><h3 id="1-漫画首页">1. 漫画首页</h3><p>第一步是爬取漫画的首页，通过获取目录内容去获取到章节的标题以及该章节的地址。比如<a href="http://www.pufei8.com/manhua/419/">一人之下</a>，目录存放在 <code>id=&quot;play_0&quot;</code>下的无序列表中，获取对应 <code>li</code>标签内 <code>a</code>标签内容即可。</p><p><img src="https://cdn.inkdp.cn/img/image-bad891eb.png" alt="image.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c := colly.NewCollector()</span><br><span class="line">c.OnHTML(<span class="string">&quot;#play_0&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *colly.HTMLElement)</span></span> &#123;</span><br><span class="line">   e.ForEach(<span class="string">&quot;ul li a&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, element *colly.HTMLElement)</span></span> &#123;</span><br><span class="line">      href := element.Attr(<span class="string">&quot;href&quot;</span>)</span><br><span class="line">      title := element.Text</span><br><span class="line">      title = coverGBKToUTF8(title) <span class="comment">// 页面编码转为UTF8</span></span><br><span class="line">      catalog = <span class="built_in">append</span>(catalog, &amp;Catalog&#123;Url: PF + href, Title: title&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">c.OnRequest(<span class="function"><span class="keyword">func</span><span class="params">(r *colly.Request)</span></span> &#123;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">c.Visit(MANHUA + strconv.Itoa(Mid))</span><br></pre></td></tr></table></figure><p>扑飞漫画整站的编码是 <code>gb2312</code>，因为go只认 <code>utf-8</code>，所以对于爬取的内容需要处理下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/axgle/mahonia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coverGBKToUTF8</span><span class="params">(src <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> mahonia.NewDecoder(<span class="string">&quot;gbk&quot;</span>).ConvertString(src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-获取图片地址">2. 获取图片地址</h3><p>通过上面的代码，我们已经获取了所有目录对应地址，接下来需要做的只是去到对应页面，获取JS代码并执行，获得该章节下所有的图片地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该章节所有图片地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetImgArr</span><span class="params">(catalog *Catalog)</span></span> &#123;</span><br><span class="line">   c := colly.NewCollector()</span><br><span class="line">   c.OnHTML(<span class="string">&quot;head script&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *colly.HTMLElement)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> e.Text != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">         JavaScript := coverGBKToUTF8(e.Text)</span><br><span class="line">         JavaScript += <span class="string">&quot; function f() &#123;return photosr;&#125; f();&quot;</span></span><br><span class="line">         vm := otto.New()</span><br><span class="line">         value, err := vm.Run(JavaScript)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;解析图片地址失败:&quot;</span>, err)</span><br><span class="line">         &#125;</span><br><span class="line">         imgStr, err := value.ToString()</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;图片地址解析出错:&quot;</span>, err)</span><br><span class="line">         &#125;</span><br><span class="line">         imgArr := strings.Split(imgStr, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">         catalog.ImgArr = imgArr[<span class="number">1</span>:]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   c.OnRequest(<span class="function"><span class="keyword">func</span><span class="params">(r *colly.Request)</span></span> &#123;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   c.Visit(catalog.Url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-下载图片">3. 下载图片</h3><p>这个网上一搜图片一大堆，所以直接copy一份就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建文件夹并存储图片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFileGetImg</span><span class="params">(catalog *Catalog, index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> catalog.Title == <span class="string">&quot;通知&quot;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   dir := DIR + strconv.Itoa(index) + <span class="string">&quot;--&quot;</span> + catalog.Title</span><br><span class="line">   err := os.MkdirAll(dir, os.ModePerm)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">&quot;创建文件夹失败&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> catalog.ImgArr &#123;</span><br><span class="line">         resp, err := http.Get(ImgHeader + v)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">         &#125;</span><br><span class="line">         body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">         out, _ := os.Create(dir + <span class="string">&quot;/&quot;</span> + strconv.Itoa(k+<span class="number">1</span>) + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">         io.Copy(out, bytes.NewReader(body))</span><br><span class="line">         resp.Body.Close()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-细节处理">4. 细节处理</h3><p>在获取图片地址并下载图片的时候，可能会出现类似 <code>Get http://res.img.fffmanhua.com/2017/08/22/20/28acd5236d.jpg: EOF</code>的错误，我处理的方式是再获取一次，知道它不报错为止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GetImage:</span><br><span class="line">resp, err := http.Get(ImgHeader + v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">goto</span> GetImage <span class="comment">// 获取图片出错重新获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-并发">5. 并发</h3><p>上述代码已经可以完成我的程序需求了，但是面对漫画量很大的情况下，执行的时间还是很吃力的，所以需要加上并发。一开始的考虑是在获取章节的时候直接并发，顺道把图片也下载了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> catalog &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(v *Catalog, k <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//获取图片地址</span></span><br><span class="line">GetImgArr(v)</span><br><span class="line"><span class="keyword">if</span> runtime.NumGoroutine() &gt; MaxNum &#123;</span><br><span class="line">MaxNum = runtime.NumGoroutine()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建文件夹并获取图片</span></span><br><span class="line">CreateFileGetImg(v, <span class="built_in">len</span>(catalog)-k)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(v, k)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>我在编辑器Goland里面运行的时候是没有问题的，但是当我编译后拿去Windows和Mac里运行就会出一大堆的问题，最后只能限制一下并发量的问题，最终的解决办法是并发获取图片目录信息，然后做一个队列去下载图片，同时最多下载10张，这样一来，性能也能够吃得消，虽然慢一点，但是它稳。</p><h2 id="源码">源码</h2><p><a href="https://github.com/gooohlan/PF">https://github.com/gooohlan/PF</a></p><h2 id="后记">后记</h2><p>吐槽一下，苹果有时候真的很坑，我在通过队列下载的时候，出现了 <code>catalog</code>数组中的 <code>imgArr</code>长度为为空的情况，调试了很久都没用，扔给别人在Windows上就乱跑。</p><p><img src="https://cdn.inkdp.cn/img/image-cad22904.png" alt="image.png"></p><p><img src="https://cdn.inkdp.cn/img/image-573937e9.png" alt="image.png"></p><p>  最后的最后附上一张成功的截图<br><img src="https://cdn.inkdp.cn/img/image-1a984f24.png" alt="image.png"></p><p><img src="https://cdn.inkdp.cn/img/image-c06579cf.png" alt="image.png"></p><p><img src="https://cdn.inkdp.cn/img/image-fdd3f60d.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广州一年记</title>
      <link href="/articles/2020/06/22/1592755563685.html"/>
      <url>/articles/2020/06/22/1592755563685.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1b17d8583d4e45142cd6adf9440dd4061bec5378c82faa61f3a06540020bf9ff">b9cc9643baf4dcc59b37da2f24103eac37ff121e67ef096a95c79130141c84301736acac900bf511dda6cd7ce629f0a878abb712f86d4958d8d477c8df63bde00e9e3b4bbce2416af652709d324c142176638c01a7c746e38f467d873e5557125f0cb63ba6da3b539d7c4a6029eaa819865eec4e022552e276d3c7c8acfe22510617c0a758c644bf703809f38486a524826d8a3781c43f2e1df0028ed8b116cc29d647c46c8a74a54521431737deea45bcd4a0d4bb5484e827195098a5502a86e693f2691dd99b6b25d31d3b978ee731a945a208916b28441b275715ea30c259219b91690da12e427caf112d8397cfb2a08b43308f75e38558ff07b232b1b7224703d0e0bdc1dce96ae54a62894bcf368fc503cbf72d178a971ddba63d57c5981212e0266aeebafbd8a3c676d584e5fbafc9b985f941b62762c685bc7350b9fcb89c8571aa953effbf1a21cefb44d726fae91cb0f3a5d46f2b88ff1c427d0989b0fe68cee1ee709a617175d02c77d6373df7aa093ee857290b2d42c4587062a38b475da2cc0b7dbc296391bea6ac177232570bd5c1f8a8fd3cfb7334f76452d12954a1551eaceaed73e0b39de2f90e683928df5b4e569665b06c45e6d922cc7cdd381588d20de495d35717fd00f443cb3593ed16875e4c1eec83c5c1f8c32791b74207a17c9f1e90de2cff2f6322a37106cc9969e545aafed939a0ab6d958ceebe0f78cab5939f2defdbb143d57b196970c6d07de4b062a02dd2d5ee37b4d3bf64b44a1256265298339c3656c54bec692e4cd8380aed082dde044fe67ca48d766e80881d30b0d180504ee2d57c4dca7cfecf6af934766cc6fea423cbf6147175e987b719cf01dcc9376356dd93503371cf9b78c111002c5a881a83539fcf187a974ce7555d21f52b14f9d779deae4b1d7b5f09c35832ab05e8a39ba73de72010dd4fdc8520a5f93bf1c8ccf2de273383c2da2a1cdec6ce834d643a1e5938b206264c0af33d7099513c581056fcf8bfb6fea24cf84c8cb98c99c508ee031e278450a9e1bb9fcc224fdef46b89b5ff412a3a3089753b2a80a8da01c7b7fa4f011b9bfc52beedc4a62d1ea4afde1fdf38e6ec766f0735b4da6905b2f8f501dba9d302476c91ff2dfa59df2573d5b7efe4a88ee429ca9332fd7f01dac670910cbb9f5a03a75b270a56eb577eec25cbc132001f26203a24d0eae22e0c2025fc1bc3a8df11a049d26566965eda2e120516f45b1c190e68d3f0c839a8a45e111ff6fcd136a41eb07cc4c93f53f4aa2f43d6430c1d5add173545a033f1a6449ffb02857af91af11042a4ffdfadd90b3871a112158bf4fb356cbf216c331fafd2bce078ddb18fdaed5beda8e8f7e5128c1e74efc971bc0559657a55c5c5180ef074db63e675b2094dceb33b61214e9efa77de645ef32273412057b812ff4afd377e1d43551a6cce84318263100484a9e5dae55989431a817b27d087db73972876585f471cddc324f9f3c30fe82734a9fd2f5b488a5e00aa143b35339657a2d46180ebb991b01c852e95cc7c8ba7f60846b95b1ac3dac3d6894cead9b885e4a9ae7e5075f5ddadd082db83f8f21c4e508a2b3c1887a43fd94c6ae0380efc7321b3b75ac31f9383989880c5de6c52601ac20ab21cb25734fafc65e21c6f18cea85b29fda962805d9dbc7b3c0d2dc65accdaee4943a6c18a35e9909a9d2f35d070db50decd693eb1eeb0d3fbf6446a6dd3f612bb87e8bafe6531d937e5b5e82d8810a998137bdad75939f20374106890c23decf9035de6acd43cd3e947495e05028bf0b6414332726b225a53d1353dd165c87f21e1a56ae5ddc7488b1436bae5d9ec32d9c69578a2c83aff3498caa708920f19f64e43823f5b7a07c6419b545e863f4ec788d74a89b23a39c01d1782a63375c4d152518d8f3ef3061f37a68636b566fb748768873d0fece6934a827d4c1f4ec845054240132cca3aba5280e65fcb7c9c4ab9e8bef4b1e931717ba11acc96f681a5027c43d71680b7dfd417eef3c773544a478dbd7db495864372c7dd9fd6fbb983b8dfe4154f4d414aa79f64869baf27fb03f6cf9f6b514750a5b2f3b72dd4b6f0c8820a586cfe759efff5e2506f8f4e183e3f4a2c8570d04999eeab42c9765d7cd810511c46b302971a6e9384c5c72d680b9b257c848ee8395b480ce99c579d610c05d2d27615fb40410e378d099dc3e28bbf5c5fcfa6ff8247052fc6b471d3d8252c8d75e2289b4e977ba2bff2a2cb505b2318d9702b654719d6ecc775fc198ccc3711159a6526bbc32a1a5b93c2caf3e06b6d32d050a262b391f3f7c21f734855027d1f102dd094698c25a190952770589a014e3dc28df5408859152a3691f183b9747afe7539334095ae1153dc9cab37c3af575c0a477159c4e49c06868cb236a3ca7a9e8fb0f9002d4489c3fa0b07cacfa494eb1d268dee1c1a356d367e3770283bdb78703313c0745ddef68384dab6c494753424526309cb55d7a8279a4a6e5dac3b47862140566aca120515260ad72af119407418a2ec3c95071f573d193c1621fc3620e28133d8e31e83ed2b285ebdf7fabc961fae8aa648fe75e41ed8f60083f41f877d78548313f4a6206093dfca740b442778209f983555973ba835f2044fee3f3c723c074fc307cf3c1a7cfa7215d54724b87c462c18acfff6a07d29c392606b5a81abeea5c0a4bcefb887db1f2933c4933627c86a731800fd907ae4eab267a039cf6e8cf154d60622d3b6397e2d0ed3bf4b66be3d46885e75b9455d56213c9cd92ffd2a8113558755249adb0822b3f317fe8e94fee75e26f9958516e490cb6555e55a52dca5219bf389521851905939b502ac114aa503dd4bebcf7ef887f2054caf3f66b3b9ac1fcac860722db78b3d513ce4df2ea4d290a99c400b08bab19937a12a3a20b077423d61b5f7527b8bf4c2f9eaa1a2f4c8d2a6d04df86e454aab708906e2ed5b51d3f0007f7f2ad34be06e12b7d2c59818c294bd77db926d0b3ae8def76bb1e775dcf7bbd79801d729dfc6c1349229f23ffe40dce1bf0e09599603622cc61a8595bf495745d7df160cd223ab180d93cb32d771e4469d0de604745dd5084d38d73cc64d4f6dceb9ff38005660994f6bb29ef430067791ed73089956f28b1cf5b7523b816c0891c1547b953907d985cc9ea58de1653b6b18b26d60dfc88063931db5682fec3ee3a8e930453325d20b6edf897caa4ef182a21e0fa2a1f6e6ce0b316eaebcd8a070ee77eac083ef2c427e823a66e0d92406a775507bbf9a71d4da2c35a6d633cebcb36a532f1425aea85a1c16f95afa809e7ea6d9df79b667ac88b2c6818e53a2491fef228494f6bcebd39c5c956df112bd86b933255b732abdf0f45072a06b2c2d0042590894f5404878f1d00ab7a6f8a365f0a47bd1161f490bedd12093b85dd403d3342fdaf71f031aa4e473410b5340b8141a960d47f070a4e17e9f517661f61f9b2466592df78e420226c577a85c46ff8fe59ae4783b9cc23695a22a64503bb11f1664b9e55535b9e38462714b0111c29217fee087efe41d0051f36bdae82d278a81bf7471ec14f4693f3d6be2b0470e705ac9e03d637d6af2f1a914476ed39b3b9125311e828a9796c9e54125768a259d2b8efe85ae83d12b3956fb22cb4cde2c6c5408183daaa7df9150030b7f441348d1b2d954a8873445a4f628b590619c3f0974dc64982493d17c647aa071d854a85caca0b3062739c698fe0c102dd3b13c3d227cf011809c80858e7edc2c283143eeb5ce8dfd7fb0bcf76c7a5f313e9ff5f38ad48514854965ba5a20bb506727c04eb1e26bf1a9b027bcfe6e810d512a34ebec1bae7d9269a9368fb9c52f9ad2f2c20f3d0c35b360bbee1af42600a1a7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go小技巧——不定时更新</title>
      <link href="/articles/2020/06/19/1592560522403.html"/>
      <url>/articles/2020/06/19/1592560522403.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数返回值定义">函数返回值定义</h1><p>一般的函数定义都是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Test(a,b int) (int, int)&#123;&#125;</span><br></pre></td></tr></table></figure><p>然而go却可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Test(a, b int) (c,d int) &#123;&#125;</span><br></pre></td></tr></table></figure><p>你可能觉得没什么，但是对于我这种懒人来说，这东西可太方便了，因为go没有 <code>try...catch</code>，所以所有的错误都需要自己手动抛出，一个函数里你可能有N个↓</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际中，你绝对不会只返回一个 <code>err</code>，可能还夹杂着各种乱七八糟的东西，写一次还好，写多了你真的不会烦吗？然而有了第二种定义方式，不过你又多少个返回值，只需要一个 <code>return</code>即可搞定。<br><img src="https://cdn.inkdp.cn/img/991592559676.pic-f90f3138.jpg" alt="991592559676.pic.jpg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b buriedPoint)</span> <span class="title">Retention</span><span class="params">()</span> <span class="params">(channel, projectId, startTime, endTime <span class="keyword">string</span>, list []dbmodel.BuriedPointKey, data []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//return channel, projectId, startTime, endTime, list, data, err</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment">//选哪个不是一目了然吗，当然实际中不会让你返回这么多，这里有些夸张</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上述的方法虽爽，但是也还是会有问题的，让我们再<img src="https://cdn.inkdp.cn/img/991592559676.pic-f90f3138.jpg" alt="991592559676.pic.jpg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToInt</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(v <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">int</span>, err := strconv.Atoi(str)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">v = <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>乍一看没啥毛病，但是你运行下看看报不报错就完事了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.go:17:4: err is shadowed during return</span><br></pre></td></tr></table></figure><p>出现问题就要去解决，提供两种方法↓</p><p>方法1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToInt</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(v <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">int</span>, rErr := strconv.Atoi(str)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = rErr</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">v = <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToInt</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="params">(v <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">int</span>, err := strconv.Atoi(str)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v, err</span><br><span class="line">&#125;</span><br><span class="line">v = <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这个时候，它是不是就不这么香了，是否预定义需要根据实际场景决定。</p><h1 id="json数组返回null">JSON数组返回NULL</h1><p>当你的接口返回一个数组，而且数组正好为空时↓</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>:<span class="number">200</span>,</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>:<span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会返回这样的东西，那么你的前端看了可能会打人(我帮你们问过了)，去翻了下go官方的json包，发现了以下内容：</p><blockquote><p>Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.</p></blockquote><p>借助翻译软件：</p><blockquote><p>数组和切片值编码为JSON数组，但[] byte编码为base64编码的字符串，而nil slice编码为Null JSON值</p></blockquote><p>日常定义数组时，我们一般采用如下两种方式初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>函数返回值定义中定义的与上述两周并无差异，所以也就会返回一样的</p><p>定时数组时使用 <code>make</code>就可以完全避免这种情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := Str&#123;&#125;</span><br><span class="line">data2 := Str&#123;Array: []<span class="keyword">string</span>&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">data.Array = arr</span><br><span class="line">buf, err := json.Marshal(&amp;data)</span><br><span class="line">log.Println(<span class="keyword">string</span>(buf), err)</span><br><span class="line">buf2, err2 := json.Marshal(&amp;data2)</span><br><span class="line">log.Println(<span class="keyword">string</span>(buf2), err2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="append-函数常见操作">append 函数常见操作</h1><ol><li><p>将切片 b 的元素追加到切片 a 之后：<code>a = append(a, b...)</code></p></li><li><p>复制切片 a 的元素到新的切片 b 上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br></pre></td></tr></table></figure></li><li><p>删除位于索引 i 的元素：<code>a = append(a[:i], a[i+1:]...)</code></p></li><li><p>切除切片 a 中从索引 i 至 j 位置的元素：<code>a = append(a[:i], a[j:]...)</code></p></li><li><p>为切片 a 扩展 j 个元素长度：<code>a = append(a, make([]T, j)...)</code></p></li><li><p>在索引 i 的位置插入元素 x：<code>a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...)</code></p></li><li><p>在索引 i 的位置插入长度为 j 的新切片：<code>a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></p></li><li><p>在索引 i 的位置插入切片 b 的所有元素：<code>a = append(a[:i], append(b, a[i:]...)...)</code></p></li><li><p>取出位于切片 a 最末尾的元素 x：<code>x, a = a[len(a)-1], a[:len(a)-1]</code></p></li><li><p>将元素 x 追加到切片 a：<code>a = append(a, x)</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能消息队列NSQ---GO--demo</title>
      <link href="/articles/2020/05/21/1590046687574.html"/>
      <url>/articles/2020/05/21/1590046687574.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>  关于NSQ是什么，NSQ是做什么的，怎么启动，网上的资料太多太多，详情请移步<a href="https://zhuanlan.zhihu.com/p/37081073">分布式实时消息平台NSQ</a>，里面讲的很详细，还附带demo。</p><h3 id="客户端-生产者-producer">客户端/生产者(producer)</h3><p>  NSQ发送消息非常简单，分两步完成：</p><ul><li>创建Producer实例</li><li>调用<code>Publish</code>发送一个新的消息到指定的<code>topic</code>中<br>具体实现如下所示</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cfg := nsq.NewConfig()</span><br><span class="line">nsqd := <span class="string">&quot;127.0.0.1:4150&quot;</span></span><br><span class="line">producer, err := nsq.NewProducer(nsqd, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := producer.Publish(<span class="string">&quot;test&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;Hello NSQ&quot;</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;publish error:&quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端-消费者-consumer">服务端/消费者(consumer)</h3><p>  消费者用于接收指定<code>topic</code>中的消息，实现需分为3步：</p><ul><li>调用<code>NewConsumer</code>为指定的主题/渠道创建消费者的新实例</li><li>调用<code>AddHandler</code>为此使用者接收的消息设置处理程序</li><li>调用<code>ConnectToNSQD</code>使用nsqd地址直接连接，有多个地址时使用<code>ConnectToNSQDs</code>，这里官方文档推荐使用<code>ConnectToNSQLookupd</code><br>具体实现如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cfg := nsq.NewConfig()</span><br><span class="line">c, err := nsq.NewConsumer(topic, channel, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">c.AddHandler(&amp;ConsumerT&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := c.ConnectToNSQD(address); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*ConsumerT)</span> <span class="title">HandleMessage</span><span class="params">(msg *nsq.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;receive&quot;</span>, msg.NSQDAddress, <span class="string">&quot;message:&quot;</span>, <span class="keyword">string</span>(msg.Body))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者生产者搭配使用">消费者生产者搭配使用</h3><p>  我上面所写的demo虽实现了最基本的NSQ的功能，但是对于一个demo来说，整体不够直观。理想中的状态应该是：服务端一直处于执行状态，客户端发送消息时，服务端接受并处理。<br>  改造后服务端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/nsqio/go-nsq&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConsumerT <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InitConsumer(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;ch1&quot;</span>, <span class="string">&quot;127.0.0.1:4150&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*ConsumerT)</span> <span class="title">HandleMessage</span><span class="params">(msg *nsq.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;receive&quot;</span>, msg.NSQDAddress, <span class="string">&quot;message:&quot;</span>, <span class="keyword">string</span>(msg.Body))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitConsumer</span><span class="params">(topic <span class="keyword">string</span>, channel <span class="keyword">string</span>, address <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">cfg := nsq.NewConfig()</span><br><span class="line">c, err := nsq.NewConsumer(topic, channel, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">c.AddHandler(&amp;ConsumerT&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := c.ConnectToNSQD(address); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  客户端这边呢，倒是没什么具体要更改的，可是每次都需要重复去运行才能发送消息也确实麻烦，所以做了点小更改，让客户端也一直处于运行状态，通过命令行的输入来发送消息，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/nsqio/go-nsq&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cfg := nsq.NewConfig()</span><br><span class="line">nsqd := <span class="string">&quot;127.0.0.1:4150&quot;</span></span><br><span class="line">producer, err := nsq.NewProducer(nsqd, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">fmt.Println(<span class="string">&quot;Simple Shell&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;-&gt; topic: &quot;</span>)</span><br><span class="line">topic, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">topic = strings.Replace(topic, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">fmt.Print(<span class="string">&quot;-&gt; message: &quot;</span>)</span><br><span class="line">message, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">message = strings.Replace(message, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;消息发送中\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := producer.Publish(topic, []<span class="keyword">byte</span>(message)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;publish error:&quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码请访问本人GitHub下载：<a href="https://github.com/gooohlan/nsq-demo">https://github.com/gooohlan/nsq-demo</a></p><h3 id="结语">结语</h3><p>  发送文章那一刻，发现上次发文章已经是5个月前，最近太懒都没学新的东西，希望早日回到高产似母猪的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年个人总结</title>
      <link href="/2019.html"/>
      <url>/2019.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a01033616a07a0c164ce1227ff81ca8b0dcbc7be9d6366599446b0bca3d7ad1a">b9cc9643baf4dcc59b37da2f24103eaccefe58073ae15acb17a69c6037edc4686470b4bafa04e564bf9dc1aed95843f10f677027da48631804914bf746e4a3642a9476be01481c3142156408186238c469e2b1cf22587fdf06347be0559221a4a54be5b18e6e9ab6e6ee2f5ea3f2cd4e5ae8c27d8e63c621f468d8dcf87dff17296606deca86561b48d6878c8c686f740f56744f7eeabfdd5ef737cacfbe97fc93f8871538b16a2169bdfce7cbb4ec89cd824beeaf4d3c3909850707fd26e4fb55455026c2bff51e7dc0dc6c7f2b10c8d1f93f99b4524092ef77d1912cc616869110cca573f41cfd17bfb7d0a4b9e5fbf081b4177abdaa44d218af33af79e235c6814cb6d9f416dc28078c538dbce666a3bb08e3e3787519306d97b91296b91d4d3c47e79f7a23ab9cdf55d08b170a57ab5c53b77c32617a7410227e675fbaad7aa25a5451de5d0afd34e0947d1864ea283501e0246c2de40a20e7c7884b01a96ff56c51a061009600bd660d35a5502ff330567416d4c77eb684918ec6bb62253cf86d27567db5b09a5a0956c3ac0ba1400c4481d36e51756dd52f2009cb8b86448e8144711049727f058db4ecc7b58384e0f928b3305a5ca11da41808dbc48874bac68a0c08ca0947bf29e912de6b318213c1174c8b4d5c3ac8f55da6fc85257cd7a877ec8727aa7d83d90f3d943db10f7235d08eccc4790fec9da7a3cdca6dc45fc294543b9149d2935a46ee0daf33c63db29ed42d447178e893b6137fa4121e6cd8cf9ea2239becff3194ed1d3d5d488ea66c0cb22f378da7e7f0369aea4991095ae08eb9fccf5faec1b8ff19ed77a004389fe014d705444503d6c91f3c9bf019e5ea3b04ed2d70c266abed1a0f10ab7a057fd2416ec76d94ca0daca3af43365398f6ad1cd92a4b0514883b6f80194eecdbd9eae079fa02bb766829faed1accb75d951260c35d6a8a914c7e34c045f6fd2184af87dbc01fb2fa8bfb825f752b8c3339c6a4c32699c0371c284d0aa5acfc0f13094081d15a5f707844eba9d90ac3aa90e8d2414d9332b2dbaa200c5be3a5ba8c03feca6b3ed88a58d879f41fd4754e5b9e071ad538fcc68f392c8683537355f98807090b5075ff7356ba6ba0ef0de69480cfeff6c88d6cd87e129b1c73b9dd43df549a8db08b9880a519fc32a3579eb7be5e97dc105419babff3f97e3b4372519f96e1e0f2cba3034480f1e9e8d361b7af7474e184b3a5bd3a354845e36b26635fbe4dc4c875e44c7185ae26e0857fc209962f08e91b7fcea7963ad033a702a9effc1ecdd9f14c37209377a59b6abb179e3e50b67b0ba28e57a2ff9ee2edadb62f4ec33345eb7731d1c833bf6ef905a53141764abc42a313e7240ded9ced09e2da5da52d7861b72ea186ad4c07fd3be550f1c4af264f1486a5caf6508b077a87f95e5ff66851d68312c6a699f85bd8f60760b80684b41a585e919a44ede6756b48d7ed2e3373613bb1a3b74945187c1a62cae555bc67dda3ed9811bbf3d63a09aae0e78d820758d81d288d112dea0798d6b68470dec985007dae7b90bf8888fcfd3590f4b9547e2cd2baf0a522df18698685a0f77e1a4b1479f2efcb7401462a05d86c784d1bcd93fb0f3f82716dbce7401afdf59b32e5545835b0a6576c877dab9b36bfe41a0f9e62098249f5b7fe9f636bed7c67c3315d7a3592239f7f03510f171ed74a2159953818838f4145f3dc17d0d4af1724d3c8f7afbb1a2260613e7314ea67314fd3e84f518ed75f7a9b90a85d547ae850cd3224581baea92a8d9aeef80dabbc1cca412b57b43dce185633834142c583980bd1471f4dfff2012087d42f6f52ac1a1d8021bc07cb7ba93927460c1f7c3e79636fa453a196312096b7df95dee4519994f8053be0dbc0f3ba14db66cc814aa633140ad34d98101010af34c444e367d89ddb086b88823d7471f70097cdf2c80f68aece07ad8ad56e8a90c878d643328fe43259623951a56b3ebfa1bfa56622fc0dba89f7382653b514b6e15a7c958878481c8f01e052e9e4e377694219e2438776d009bc0543c379ff3711dc14a73d75f227a67f7558dd4e062c49d5da928732cd228e5a022a55d009800b302656a08e320d092f30b6ddd863e4e861d4601259b2ead7295631cd9cd192624029175237c6e7cf98ebf6c96135fbce35d6f52d54446e0ddd29ff24a09fba147e85364357fad4734fdaf694c03f612b56d857b0b42911074feb09b27aedba648994a180e39a50fb7ab25ea8b2b8660945ba7b1333281d148945b953de239b8ad4be2eda4b1087aec029015ce7cb803c8781875012804c824fa0e23074b9d340cf4b20b56dfabc973522a7d6a5ae2c14e639437ef3e9d316c2bb777eac3a663d334a194aeca1eeb529c7a3ec6089753405d81802e9d3c11cbdc1657c3ba273b7b5bcae2126796d15675690001d03e3b9755ff42ac6ff140b9129c8cfb8c233141212036881634f213a13bcf15e361a62dc1fa53c7862858c84992b029633a59b2625f8a938b84b4843fb8855fda8121ccebcc7aecfa44c93d5e60bad027b1e80f300450e04cac5348c9639f56cd9d64ce97ae100ad0580c8d6ad5f23b3981ed719ac326c42750d5a9cca59da18e171f93eea5965e34f5b2952b3bf6e3220e59e916ae763fc60ccd31d80ee14e49ec6c11f95bc6a59874fd0589240f6aef8433aeb387545a94942cdbf2a3b0770eabdd5c5ce46faa4030d4663bb926c1a99fc6cbdcb717be98a2e091d49328f2b927e85b459b98c16683a17bfc97e8011695dabe655aeee8abe9e484688cbccda6f09a77f792d33650d1e71e055ae0d0dcfc2c92e4749e46d8a7b82a093bcfe940e39e630feb8a5c50eb838dffa070ec8af5d03e6c7e2efadfb82806bac0ab74bfeb9410bd22073b67b8c1079919ae6f60134a4d16733c5b4ce33219565de3f1f5c4e6fb8497278f8a1d25d8d6337afeeb8657ec2aa99a95df62d163c7c22f70191c01bb0d1fb4fc02c30f388fe9883d5964d15b6e286fee1d586cd1ee5f8da64017cd1b8651fc05298c88b4f497ac34f22cf30d8483cee65ac02fdd76a877a373a03a3fd36f27dba092cba5d8723d2067c6d098ab8c8b6013f1c2383f750b48446016cdd53fc5db4cbfb3c6986006233091a1a057173ad3955c2205201b03916dd8c8ac70c22e0b2338d026b89ca18032f29aeca03fa36b068b44002b4f88b68215606b3710cb2d3f9133d5fbd56215ea6a2844f054c3ed953d9c163a0b8d7a4ea30eacfd0c2560d2590fe2abb3f73520694ebe5ca0efddba7fdf63e62a182c69490fb94526a4d0bb0e2f3fc1f934c71d61aa59c644dd9f63ef730d0ed434c04009a3ee1941ca8d8633bd5afa4b3792a361cd362fddfcbcb8795cc608c95df4312cbf94600afa445b4c6e4ed3ea7d76b43e493aa03f8cae4e819a6624ce5a00eebf173b80c26b591549f71758632c9dad8f04aaffcc29e33729cdb4bda4837edc4cbd3e290b129f045cef589b97e6a6cded95346f9cdceb06134386ba4cec6ed558653b089f406ff8398dbf01fc6647e211531f93d24f8e216c8c6e24e8154c7fd7082dbb5f3dcd5c237e5e16a2294473141fdb797e3c39270b1d130293961a36698c354af832e5458dca3aded3160a8e632673fa28da04e5ebc4a304826217adcbe79b289882e37428e50d468aa3d948f76ea803a9f86ab4f70c063a4e94537fe0c5c90c2cb923c0b9ee47d30d91e0cd02f11c3509989240690698a86fcd0018ad5e18aba3cec1fe0611ff49c9ead4a8324a472f5d667df7341e870103349ee816358f9f0f53f54d2613338e3e69ebbd4ecfb640c474fe931b7dbd67a719b5bf03437ad50492a2958d440c05377c013ee50fce4d16a4fc5c05dd26ee3da290d2192f524f934dd7b26e23a81a8c73524ea616de1232bbee1ea5d3c386395b5fdaf56973c0a108f82878bf67f2757d1636a072b18a587b0739046d8225db79adece43dbd614c64fbd9b32c062c3a58261cb5616a89ab20c143f9de9f7cb7f548b228751b36baca8f74b2d77b0d86d2741bafd7024a2c076d28366d70c4b4380fa22852532be41369136b9a8098fcfa970e9e015092081f7ddb784e033f873ce893da322205a94df0789de38e83a2b72cb32b4b519d52b3b1f5d28f3eb4cf4d0de5a5c8394e2da3da461af10ce2813b1a6853a3857df77ab6c2e1904da3189072a23feb36b7020b60a5aa107f5e9775ebaff292bae9cd8120197f932684d64c688840b5b12577c86dd8492d472c825bc4cca43fbd37f7eefd659b61a9241a6fb04d575a4bba1c0e8c304985a22b8c3ace05bdb6bc61d2b85a9a3322e2de980031df900a592ff43990bf7978dd79c0108390b6b59b0dc2a13ebcbb6004ac4643324a5011b0078de55645c99e1c5b3a18d10767c3848aed641181e48f270508fa16480685060745d8215d06f9687d0e4394561facd619cb6bc3c1e1d7690621f27cad174750400f64bbca10df21605118ce794d3ad92f5046089ecf68cdf254777572a3b5722058a4f4ceec94069251d7b3bd005fc6cf47268ad546730f598951f1eba4aeaf316667bd59c6a7bfc3a4925f8203dc5d66e5edb5fecf8217a0829c171a70901edb204583796104e757dd122fdb005067f40970b84e3ae72eaab048685d7883019e7e409e51a3c861b306b505f71bab853c5f67bcb6e70a5fc40fd50b8690621574d182ef6c81f4afd1fe3d534e634e626362f2ba3e858033fdb6439f64d526d5569a12f74c13c36908c1d71887701e3fe84c1b51c562c3dd67fa7153fc719d19f05c7aae24261507ff672f7f0bedeb64b55cf35901deafbdfb0357b36bd404bc6b5170ac980087f9239de6b4354328f95badbf126dcacb7d5877f10b46293f369f942294f9dacd32b4b1ba8b04b8c0e55cc5168f94061ec51653bce826ab9157c068663f59cb9a4b0110773638570cb64a28c0017b22135fa82c8fd7509ab47b9d5fef99b4c6e56d301afeaa114a6551963d7e1e8842ca41ed749a92e32ceb443424d71723d9f901f233730f158b3879f07354849623daab49cbbdb0ddad4bcf977155bdec7e79bc4aab029f90387ca28ea74a50bd860801989d910568d2e9db5ca1a2358e4ad98a14e257095180fa0192a50bac74810cd2d1cc2f3287dc111a4f59cb16509f5629807164cbd40669cfb3d6710eb956109b862df3a2509ac2bdd9e3828480b7b4f90cc182a4ecd9525b34f51424a7f581e41601585848fe46060279f451fd8b84cb0592e6527d01bca80e3a7ff81a5a39a6749e1859927624d0167ee947d250175a6deb78836bf32b1e083847c7808d6c68d7d17d2f0a20ba0473c52f1defa098518f65000f58ccb9489de98fe3f203dc03579d36819c1d7366d51f77d44272497535995a9355613be6f4629dbcbdf154fa6d5a51b1869ed21531512aaba03f622ec5985f7b8974b0bcc4f82b7c7c76a66aa4b62f283dd7bd3c73d7ca5590c56adbfbfa7ad67050fce460e6ecea13de9f81866b61a680e3a44b084f8bc2ff0be5a77b4f190266b49f60e06fcab53ca428a42e440050e98f52f6067abf44222e23a8d89effae84fe32ef0fb43147bb90f3ffcdbead4dcd469fd2e9a11bef99b9ef5aa119262e80a69c709c40b1837f8d36817abb086eedc103545d33e438cfbf00afaf5ca3a40a398dbbcc90c4ba5a3a4f7956846168106b9e8a8e4bcdb864780b8fa8f5ad388941f483a41585d5cd4d66d38daa82eee44fbe3ab203b550ddf21a94bd3a2174e4d1c95bb3ed324bd54fcf27968711128db32f79c169e6fde0c109de1dec9e9ff202592899b67517aeffd90ce6ef2cc5957fdb396ada534a85f5545391194c1ad1bb2fba89b4d9b51c13a0142b2753db72403e2206f0750b59714c927ef858fb68be0fd48d8aeae855de3c55f32ae82cb63bceb5aa0126bcee39af1efb857ae6af36651f178186e692b24543ef174d5190a4a5f0d6133ba10b4b95e15fc8d1c3fbb8b75364f2d5638219cc26dadd56e25a194430d42ab35a6cb1a91d5a2e087b78e4775fdc233edf2b3723200b3f40bf0584d0de9e56fcad0dbe9281a8a3fbf42ddf960de74c83cbdd78378ebbbcc4e046a5cc92d5fecb12d8624a2d70a922ee697691cdd582a592be9e593d6c752a3c9e13588ddaa8cbf35b86f796ca52a9a313e9afff1deae40fc01a7ee56880fb2b43b081ece9d611f36cd7ba49b51d42a9e8d57ab46dc8c28b7822ed530f1ae5a18eb9b134d0267f11266811c6c3f682bfa1d87c739e4b97f0cb2ab6ec6fc410560a402f71fc8bd31caca3a0697a6bac11d61215cb109f1c9092170da99e5daa636741579b8ec261509488540cfd73141dcefbb4fb13ebac50e9c7fcedd1c7cd2c0f4c84f84d27717ed629e6bb5b6aa3cd0337d5c65b866e4c85a27d5d209df8ae75cfa1f79a22a4af4b577ade1e9acc2876b7fb810c04508c6c9893bb1d8c3d953ee6fdccbcfc6b34cff4bef0da28cf6dccfccdd8e07475e70df3a24627382919ba9e26ec0985a9319a3bd5718e2baeed3371933eb3ead9ea9a902f1ebc700414c3b0aa1ae432f57bcf7a293d58e95af075a449ec0f626552cc76f21875e7cb2c76a75cd34a4343a3cb4866d6d1e22f7a609de6bf5ef3bcdcaca433b9253c56ba6ece3420baaa0cc735f5f2edf6eedec0b2d31a97314c8c49b91b5d7d030b55ee8f7608922416bd59557bb99ef8d7b1194a56f45a687fbfd8aa78983c34c48bcd8495198d47470890b5c0a4c5470870d9f74bf1a9a5cb828677bd22172b014350d4b536ff09d5e41834f2611c04d53f3b1ee8e0abfedbad3442414a5496133161da71028df57e1d86a2787f700b5a10c3d4e2f848808526884be02fe7b70484ad71d26795c374c23f3685c8ca9d1b111ac8b194f22c0b7545c31963bf00890977eb5375d6bf8cd7438d61b020e3ae14b3ad8e4c51fd55e12819877021364f2d0619f2d8a15bcfe7a55c880f93b02f3aa09b7d8468667d93e7d5205c68cb6cfee8bf2f2628ca5ceea4cc9b665254fd0426d137190397de1442207f7b08cf5734932333d89d82d84ef97f2f323abf636c519818bd50a609a8ef8fe697b5867b385cda328d3ab8482a3fae3f881e9491ed8bd23ad30c052ce25aa8cf8ac3df7824fcc95f38430a1e1690f5bc785303c7d1e249d501562e0b48045e88dafdfd003e5555207dcbef8e1d64c1a007b99aa17da84e0492819f9bbfac22be501b28cf9bb4b8c301183c3b3666b4484e306f6fdb8020a5e1912f27743de237977dd79a655a65ff9acca73e0ad2008c446fb143fbd6ddbaa45a66cdac83efe1ffc64c5a44668d19ddbb292c450b9a001b757ff87e8df4aa16a5e094718313ed7b4b63bc960b71c9ca4f2cd47b5dc872ce670f5d457f4e59aca21135d44e5c3a3f396af35dedfecf3780129452afe3ef0cc34b34891d561d0031b806301a931b7b9887d7dd59a3d6bd04e71fe83909ff485acd29b30e64bd6e39d18b33f8d5cdcd7c718c8157a3692bd6a6c19a13c2ef3ce81bc2fadcebd45d8e2cb5921d054126629463e94d4d1cdba5763323607223bee758a842d48876b45b971e31bb8107e647773a75944ead275ed9e0b1f87d64859e9d6ac183d985de261ed56a84d8c22ccb0e8cc5ab678b541a23e9187d849770d8b2f320b684e30b580b034a662dc20a06933334e4231196c3e91ddd6cc144fea5ac5b0cf319f112a810b534e6ef31052f28d7a3a6cd7bf48c69f3c2af44737cbbd116f00628a983c898f87c0305ea80c793d064e07c0cc14ffc2cbe6ae861e02c2fb81d9bf36b0dbc6686a8f02a35a3d5502c93b91b8c5eb33d0c17236da7b0de9c3cf493e73c7fdd84c05ef31ea572ed52033267cbb759e4a55f0e48de4f34d88d2af8b58f969b77af34a42624a186856a77111a1d29b1833edeb180b1e0a5a3079de58b58b6157cc7409580d5eef4d410dc337895bb19b0852cd894e2f5a67c3addb9db277bf56e56f78fecb899394191c54b54de88c5801d095f4a97a82d00571d3dc51e3110cfd08ddf87af10defe23f8ad05a66459e9bcce850d80315e143c8f54670ffbe2873c872df20e9ef97bd28d7758b405957d636c30047ca39faa0c4fee6449fb062d62ef3b07afc935b51d33faa2873563e791e0462cbc9216f9da03185dc08640c31fba18f408c696dd1dab47d596562641714de11ee4f04278aa71b3b2f9a0f1173b36826988a5f9ff5495ec7eb8b87f5602d454698b0f86b8b127bd9145dee60fc3c47756cf575ad48f5191c606872d4548632b98d5e6978860c77a68e10c4a3211a19d51fec03f3498f61e796e0a07b1189a185f7980f5bbb293c7510d251ddb924bf60f784d6a6ef7ed51837cb7b8f91a8e13cc81c985efdd9b59a233b51323e153f97dd843a31972a978864d3d6e0e889d15439a2354de9782dee7ad463d087a2c7d62b64860396954adfbe5da79a1ea552dbaf2c6ae8ea8c6340963bd1fe82469d238dfdd48e68a69cbebde5ebd25eebb08969714398008fae46eff411883f0f468ed15e2ffe88309c3b7826ad9393dbe1ef8920ba94925e0172437dcf78618f31dac2f7af2e28001a08c86a08f79b1142d0a44678f59d85896bd9b817974b5a879a75349dc321a283d190a50b581c1fc9c8eca7400bdc053d759682fb8713f1ecaac39cdc156e48260162861bbfd8abae23274ae5bfcce6853e3b7543d6a2f6d71d11d4abb375206a4fd115086e015c214fec61f290035cb4d6a778bcc5886ed495dbe066d40b3186ec1f04d6ad672cb07c6180344f785ebbc89fe488b4ce3e7bc0ac2bd156cf167f37f661a4dcd178fc4ec15edf2f437875791b0d3d465f23be8097f6a59cc33466ccdcde75e175a6be5ba92e41fc2b9427e00eb55cb5b8e801bbdeda40ac2d46abb1b69062157ea1e03cebdc04265f6fb6537a3eb6780e6fa3e9bf9de64c97609571c97e479288e8c0a9e1525d9442d925ea826e31372261562e91b887cd03f5ec0b19718ecfc492c754a60cf9efea9acbcd4b9282d8ce8d9a379944a5478eb6282a25a77fefd0ce116f6ff9fcb06c7c99fac02b9e025c0ce5fa299e3173789a106d737ab07067a485ce3d0cf86207e2aa9bf1cc34745dd2f89203d6a83922edff2648f4c32e16fff17dc7c4646b2f654ccda57a5144e08d4e612691ce4019648ab96565bcc4a9e1acabc88f5088a92ded1aa4ffbcb6f7690c4338fa77972f8b19a8e14f750a4a3a3582a27626f726e0c037d746ee09fa1bc682596508053d63d0bce9d4274d3f6146b8f5dc16a3621205fe7c2eb4ebc206762eecafaa59c9edbec325e6211f7f12d793517ce0af150acdc6a3776a5ddc91477f0d83fc40fb1040f4e933a7cc1cbc6cf55f09fda5a858f2e74ee49957b4e82aa9332cbfc06406ddc1f540894a287d610ef268b1b2a149a5def0b805e91f586d22903bf7d55608b26b4196403e7a1915bf93a38f38c29e6ff5865f8f0bef617d700a7e9b04033265939561f362bedde3f101a50fcd2572cd17511e383d9fd321a5777ee34e406babfa5fbe3050d9ff10dc4eca681241e33fa57edb73a616c2ef57aebddcdb94abffa414774fc4be4c4f1a62af905c7d4ea4e1ad252f2692d1b572d715b3b86e3d58ee95ca0cff2965c3994283276d9b29d801ae2541a9c14cd21055ebe4971fca3095a5437090db61937d3bff60017951a1008479a2026745ffa89a6ba499a62d242ccda787683a6afc05f276e1c97ab3e5892e7fa531fafdcdc8b1e59c5743c1ff316075fa0e6d690310eaa3a1be6ad8c3f90cb15b1dc79326f5acda44a43fb6d93890bec04d5e47dc5385873714cb2f10660e2211000ccb41a5aff4d9808f0c745ddb4d8a0dc8233b9a1b652b847f4404557b57703c3a9fdf4c967df5ba8dec87487bfa68d07f811e466ffa4b798da1da8439078681192e87d82b6d8b0eee8d6b77f2c08169dd1d76d83f64f7dd73adf9e4585b2be7ae05f27fad5456fc579d979108cda6becaf58f333579d8a9e6df8e5f25d4e29ea92b30e54ff87673b417b8469d348cbf55a910698f1dedea863d99a352c8b5fc57e9c1a5e5a71d07ab8472177fb48e43c18d03513088f91d4438a6ac9d94fb4eeb0e64d5b3028540559071a18a5649bbc6e48177ed2ce982b1a8f24165f90a5c4ac188cd9265b29daa8cbb25176f15a4ac90f90a3b62d8eb535ae82d835f7db027c6f58d312e9770b03649e6d1aca2a79fa1d859a1e5325792ab6cb3ff8212c51a6809c72a2d29d9a2f33792392cf6042442cca92652ac4bfd41a96c728d8f7320e952e9cf33bb8c95d440d8702050a67a77ab9d7475e93da75b4eb927482965bf9824c3a1c0e546f59c9a1df6f96dbd804b2dccf0c9232d7bb452b736bda4976c3f70095ef11a33c1cc854eb2cad93483deb2501ef27afa523cff4051f703d84c9f4947d2e4b60ce3744edf994741f9f5a309db04daf07138f27b933fef8a33796d43ea5eb66e3117c974c7ede17c255cbcba427a258bdf219c2d91f9fc725dfc2e5e9b34e0c244a7aed114d09df732c4eceb1962a62077977b34614cd2c7dae4bad634cd7523a9ddacd1ce85de2d09ca8f02b81a6db7e260c6e7cc7bad0413ba422c0c9597111c325484dc85a6347406058f053ed6a99aece278f131133b5421d6bd78187d18371ecf2bb165e554650c6a0a4e2975f80735cccdc6b48661889f0cd81f6f0aa1fecb4ef25f9770d6d39e3112dda2a1a1c5c803fbcd07a95d90aaf3b9032ed5d1f5a9c0e68cb8210b292e0da6b86b68df83d064780e3320b0ebaae53b0856078432f8fc9e3eb51644c5921bbee5f5e38afbc48681a8e7b49a93851ffd3f150f8ecaa73da981cad21b4747edcd9da77672570c5d6e09b7323fd36a6c1135dc8b0bb6f6c417e42fd5e8fc48e08014bad1105600c2d7a44bac9f8afff4baee0e44b3f44c8bc1e0251cf06752d444e59d5dd6aff98fa27deaae2441461c3d08e3261f1e44381019eff58251dae1e0c23f31e67f831f47cdd1fc24503abd5744ab2b2f93e9ab9d4d53581bddc2ba70fe57740c4be68cabf6ff7ec7bc17533060112121d806c54ca978a41567bd73fa61496d821d3d09003d0aede0725a45937aff65e7f6b9323702c7a981220031afca2f02f7c7dc31b3956f6d6754a1f51a2bc5693f7f528d2c43bb2eec7a90a396db453b3fc7721bc3d6cd255a6126a651dcd020f07eeae72431844390d85a2eef7d11c68c8f2f6336808d378001d9506bb2ff5e53307e7104ad63e7a1f8ca4ded4bd8fd47400ee3dd1fcff115c13420864a9af6c3be703168a653b290bff9f7775277ac6a9651ca11c12eae3cb11d3c82ee4b2605dc850543514fc4c9e21aac4dfac0cd3e298160622aeee8dd42396c366876f411c2f9ac95b508462bc18eba40aa6e3c45732b1e2784b550d961bab4a4aaf0d05142eb3b1f71167ebde7f0fe9557fc77d4fdc9526405f43fde1eb84a08eb578df84b40d1d6bc1ff1cbac3b37d07b7ad37e497b9865e8db323dfa8ee58d151ef101d9b353e65e0bde5afec9de09557ac1ef6a53ff79307f1aa5f9bf5f1d4ad578e7fa5b0a8388797bb0b32663e5b1666240d1b5e275f9dde0fed349df2ada76dc491c153e2491236a0205568582fcf3ec4593bbdbb07b7d4211b337a0352b377afe1e2421eade46d2d8a17e01f635453af74a543dc57425b1237873dea43fa1faa0aab10f251e6035a2db0bb0d6f4b30036707cc98473b52d8fb9733e6f77f9426b995cc0c62179a031830e49e2add2106270529833a1105f1ca276c8c8988128d6e2dcee00855ca8dfe10499481239e4fcf24296b889b5ce8d781f959c317f3aff4d3b95924979e670e56cd47b5ab0a4e2ea61b4c6737ee031ae43aa9322a9f33a15d1bf8e7e18e76e12f40de3517606256a85958558b66ea4bf4a247ce0d65792a02cd32df9999f770dcffd848b86f2daffe2ccaebbc353b9a4712ddb23f0c8cafdd1b9fc1fadb514871961829aa591c69a9b4866a90cd757c7094b2e57f06a5f3b78ac1f9b8086c32e177ae5f6405ade347a210dcd43b0fd14000955e23866e3d4fa0b319a72606e0ff444c553e66dee903de02555bdff8f78287a1f7c78d780c224d7f5ed9de6016d27c84c67ef8da6c26b2612873eb30b0432f16eee37207d4c2a33d6e966a56c06ff8fcb355f4921be1e78a3fc150294661def577ca5a6801138eed06429ad3372ee9d8b4a72ba45bb1090248eab13f945421d6d51560828ffbc988d343e51b4a1c1f616a38b9558f12b62cfb01271dca4db9ec87acd042a3232963d52b5a04f5e30998991c82d13fb5f0d0daff98a533fef687cecee05c622c9464c16cc12ded4c9927855a8c72685eb799b2394da765dd6edae09fb15be75e63097a3d1e6c225cef6ccce0a16217cd139db0b78f0636a34bdaddf4e6bebb08d3f07f3cc3056519ad269882292bfb5d147f815f5066649c42fc727b61e546c407c7bea73e2903e1da8420023f1c8a1c2ad0d8b127c8d4941045a7895cb6a6123be2c011d39947c7d21b15b0cf0e2e508456efb69af1a699069c6d68dca36cbd631e5cd6471ecec92b5ce052a1b4383ab50884cb7427f507a7d19511eebcb269ff572b65f0fbb7818496411cb89c4ef44c490605723de6522deb92889690dcb47f32ff7caa3bde7d21fd4e1ab14913ee7d28e61c8e1db97e6ed12ee3a9473eb37262eba928c66d888c38456b165457d8b35a037887b5086df6e4dd2d2510ae2f62924e908516fe34697282df3dd00dfbfa75d3aa89a724ec64e1b7e89b77a16badcafa9537664d18ac687fa7a3ec6b5a78a35914e055fd01c6c3f76bc853baec388b1ef168f7b7fc8fe3ea6bc0268fc4970512649843028a2bddbdb59a82aae1af219565f1b876b83b3b94c267c63ea701d91961e0273e333b4f317a289f6e4fe2515e4d5c5d1be04dc246cbe5870b1daa5c3e760a7c7326ef5c628f1de2b53f6c8ebf9762d319cbbcc1d76e85bd95a66526777d3cc9cb52fd8ec37c9526fadbfb2f338c98ab61ded0b370696f13204439cf6b1eb5b3b044a980867bcf46b0cf3ddd0884268ecfc4c0f447f0885affef3429708cef969a34241060a045804fc1d27c2ab50a042d19955d32466df5c4665d94cf0579ae196e4875605b948b8caf6a2b17029426911b87bd686b063858dc987942129f780019a1265701a6ac340430e03f02399ed621d02f90d5eee584f446e1ccccf565e8bc7cb1fc4195e37b87b07d19e50401fd07553b53b13496970c71632419815260eeef649cc482f7cf9fbb5c8510705611641a177f288ac147b91a811ce7223f475f959518600487dc9fb176febf48166ec8f9eaf8298e43372ab600143af0e152b2ad9c1c229afa2eb2ba183e79ae4284e81ae7375de2b5c9fd716cdd8e6439786ab3212504913e5a19f6033341f90cefe57476569751391c0e89368a3fad3d0bd7fd6bcc4e80c169c45513d7bf21b3d9d954870f84ba6789659fac45fb02ce68a431fa0b262fbb7085c52a54c28040b5aa4a689aa49f4024f15cd8febbd3cfcf01dc0551ac19717a1c8df5151d0ca01bf566263c9e48f2eb86ec215649cafb218c51aa23e4f5b6c22feb9d08e8cc1e8e841be4837eab43fbf62b5b1b2e99b416f4cc370e3331a2a2e1950c5bf5acf011ffbcc4fa00917aaad7f6841bb16f0a55e6197516d8372c50097b6e5282a0566281cfaf985f9cdb798b7ce538ce31d88fcad7e7ad13a6c05dd6b0a5d989db4a1b7081ca3a6805b778aecdc6551247a3568ef94eeb5cc78f9229694628b2a5bfcd27dd7291c92e9f2135d683c0c0f1f5d7909e98de38a215dcce479c311f231d2f134d66c7b48fdd12f46892d292d5fabc214f49efe55c58fccd70c4f74ed2de24d12671269c29a8eae99909c46dacf072ae181ba0780efd225ecbc4fa07e91817bd3adaba43605826156a23a1d18c6b2edda2b3990656d92c916eea6b1702735d65a554228de4a7844b10173d04203df9fcda141a0d6131802ceb86ca5a23072e95a931bdc1f599840d2e70fa9aedab19b1f1e8f292799a2f0132f066c3677fb8787d2721d323bd84f19e15cfe88e379c69bb7ada4bdc280552d1c15f04b7cfb83a6e9bae26d42db82f200c20d8573bb815710e83a74bea78780a2fd7686e851923f744f0757a79ddd9fa68e272b56ae626c40d901571b7b6ea955823a78198e3842fde5dca23488e0f27756b02bf8efd9a127377e705d9528efa22b23745cb59360c3d45baa2249cc2146609c32bf970e82484e7251e3c45a79bc3f433f276c817e76b408375edeada3ca2917f6d91a492e869f8927fd998e2c5244fcdf06c43552923c26b29f0c26d1724d915f64b6939ee5738fd375a4faa40d0fc679037bce96c72f647b55c149ad273dc40b5735378c8ecf766e91439a9e77887572e773cfb1658738d8e5e34e8e585951fea0a3e86e6a37b022589d7a97b33b8a3a8f714de4a792bb0620c312cf7101fd901282872e6b66d8a8028b8b54914961dc4cc308e7df6ef4c959b4e90a7eca1dfe24d0ea3cbf659f565d57059907a539389161328efdbfcd90c7e1465f784bd141d6ea8ac1b0a45405beb8cd4751d8a065820247aa85980cebd93cfc01c0acbd1c5dca078f3a90c5334f8956a346e40866193c6a74a4f6f617a2172145f7b8a9c31aeb5fce68ec18b709e5cf57cd51ba20086df4f535e3413eebc3c632097f52f79156b21851f84d3d29b646d50d4420fff1f91e90a1409d8d6002833490222c1367c9fc01e076246323c29f1017fd5b439488237d3cb1ae798d2ec2152522a7a5ad7caa2d3804d8ed0204dbd0ee59e0bcfd6cbcb7c94a535b82fe49911662754afaa49644f8384c6a57dbe5703861f32858eb7a1cb88da16489c5a97980f5fe8350c5c0044422f91e8696cc040d3530c737ae5cf1e06a94bad0fbb80dd009483d36d3bc9032503f214587b20c2fcaffc2fc38f03be5bc52c2dfd49d10d1ff01c240624f72621794ee1a1bbee7acbbe4749771b65a6e01f0ae7cf075bda166d49c7cb343a483c79c61149d5edf1ce050c337ea436b9c09b44f9039c56c99c9ac7eaef2624202f753f805f0a00e0f0dd75f6504fc78a7c3521a779084ac1abcd63ee182e3017c0c565dad207c2799fb34fcddb92f182ba39677ff25c6021c2ded4a141f20f0a55b005b43708a1184cafc19ad7520592b2546608c4c7a83caa689f29c670a1aeb8d188cf42ce2fb7a8b853bda13503fb027180c75212635eb75797efcb7b48104358bccc23326102595bab4c780db83128b3711943a88b5c2f95dd7cab2afcadd79f060c99a6f828378760c22c9c37a167b77058a765641f25e3d38e06dbf1a55933177d2a42fccb3078893243dbbd073d4ce9cecf0ca4bd91d5bfe750a4459135e0b3cfdecf1bee7089604c0d4dc5b01794cda9bd935190f5f844d12a58de0d8a9236494172c6b1ac8d34bc4daee1efbfe8f78d10be455e05419b3773a7705e1f35f8d690edb1f6552d898ae7b4380755e3a8f63cebf8aeb578d3fd18d9ddeccfdf8a8a074ec038cd4d401dfc0488a5d3367e5ec92aab7a4aa32bd7521903670d4e6d8b71005be6ee692add6ff7278f24c6819531019970dc721e18ec73de795332060725ccbe3ba22f0a6816a5e22af30d0fe6a1c919e2b56267ddbce52ae141c89ea661ece053bdb05804411b54b27875c49e6425f6317247a3b2e1ebe78e2d187ec8f6ce31b40e8e64c13fefbc1aae8f1700dab93a56391588a4099e1d352f98fde096151984d9ac82de2b4b04f9f8a4f6471c2f0fecfb8d1ef39280a41cf75e181940f1c0cbf12e8e90c1d9d13be18e90a95f72321d67b8bcaaa89725c085f76d98f30546ef8f36a739c6568dbdaeaf73ee6fef0aab3ac5e90ea08b1ecebfe24652c32f4a8b770f1fa1967318be4ea05fa85ef01f2a2bb00947495e6171d00261e0e8047494498b2a42bcb89f372385657dc687ef9bb373ddfc6cd024fd3e159899cecea0ea76f54379949b5a3234831c77afe24143b3eb5a83db550bfcad1b57a04496d0895167a2c20474a34eac46e6f5135fe7c6b641096c55b6cc620883d7b9f81c323b10ea2a85738f51d99eb5e1a2adba16b494d43a3374e6013233bdfb76bccc35df77eb31fc0812dc010d1da3f253726b7cc37c2f79ae96415bc066bf3be9e5e437c796f886686b56c0a660cfe0ef7d2059ac499d4f3658acf81764288b880be151d749eb6693aa48841a554fad47a968dcd4738daef2925d4a8bb8e2b272040b71e95eeb568cfc0eae51e6d982557c3a8565bdbb5578ad5ca8128836b6019086f9bfbb3cb1e458fefeea0b753d4b1a2d5eb20b117738c96a6c702788ca387c788824299730b0ca231ea58786fee823b0d3cada86fa3056ecb5fb450bce0fc225ce2322dfb9013842febfd66b62747f33f445c7658fc301eab8a5d4cc61041164b325021cf7e0b6ff60264ba5f31fd8ccc9e8ca78552f90c5fbd8d7dc5ba5c4eacf175a955639e6e4c4716a9b33aa325884f47597129d4e5175f53a6f14fda22723f280a8a59a10a2b389722a34067b0faaba294886f9975f9c85282eb0e7f3fbf8f66af64fdf6d28ee7ff8a250b93ba0615e9d43163374a92d9f1f78f8a5c506726bc91191864a11e566eba0d5d8c50009f9c9b852b651ce4dc2455fe1f2491c27bc52cdab1f25cc6e03b174e9d47c324b6612d581138db9ebdfc3869c0c7366ee1431d8f583c49e5b089ce15091c4dbfcae68a4c90daf1642f1250bdbe2a097fabdcfcb3ca2137c71818b470f4b9b908f70e84b7716069e3e4096418a9d7e5a8367f410e8c3bae18ebd3d88c83e579e21a06ac4f41a7ca685cfde2141c261a5e3393f74cf9f9b4cb83065d6663dcbb75b781b6dae99864338701cd1ebabf4af8633cfdf38b935a69da4c02bf8d324e591835d977b39d3e27a7c1627379ea4d2bdbb6a50edc131b447805a615e2188eb9cbe7c1ac7753cb95914fdc2d5c1e10c2e0aaf5094ed9fc40fa802ec980fc885d4f11eb3a86433c7e4cb94bc8853a9279a5079101080beb4eb7b49162f6c31be072474d11045acea4b439f54486d2534496775104b5f39c232819e3b34b14faf886c07b1e89ee23a08967aa9bbc64a89eaee188d97a76a4791269c882d5aa4b4289c3be9bc7a339408c7a9f15a51822a3e2402b0d01e7768c04cda97619a103142326e5e9ae221aa25981127c84a83a6acbb2fbbe6b925cabd0c3918669cb09be40f5a2c29b56c6460956801a864be0c34e1ebc4e07e0b374bd8161d69d8b6914711498fd6b81b57206eacf034d676cd521f2dbd1154e78ff4ac8366750089ce9ac620de74d57401af5adf0098a7f056941359a073df267faa65ce1fec8b876d7ef2af4e39d42fa7a0d58a21a77cbe62f7de967e5279f8134099052cae98df3a2f866b5a0cc5cc3050ea4337a8c67e935d0b59a769874e8936ea253aafd227c9dc885fa3ce51dd7be4cb0691d44d6aba61fb27d3fc49a90a5f5af7c2c95acd591aefb33bfdf2d15c54d3a183fb717b0ba7ca5c8ed2515ea01bdae309419097af8b882d766dc4250864a2bde0f1f2268b7a3df7697726e6688850af7dca51b66f269de3cde196fd52aac801aaf88c3fe20f4bf8667c0ee9a77c92297c9e95a6d01bd1c962b93993faef6561740db220b8e2e1925e37380530e6a7f5a6b446bfa1690af6300c3bb512eb8ed67af045fdb15777ee6b6813f03ed6893e51defdd6b4b609fb15e67166871684ae5050c1ad914de87ce0ea637697dc351737b388acd76583ce10cab90a0fcd7e5fe4d7cba2a7f25d78f48d1ddb44a8d6368a8e25100af763d6bfd07df1b6524fc94cfc960ee9b75b1207c38081bf30b38b9684cb050242dbedec5532a5b6df2072877f3d8d17bbc97a3f1e8ae21ee2e3886e5693b0fb42890b0799aa62018da8935d91e94b840a6afc3a1690fcb918a62a78029177a902258396b30634b71b4f0d277ebbbdb274065cf12215344f11c4c4b043fcc4aa987c18e8375e451b0483427ff8f6c63d38c2ad2efa920b82c113dfb1563ed6da1b441601d6481cde896b3b6b157561f5d14b5635dc340a9693627dde00e17ca2e491d99a79ce3b64d76a251451c881e3b0aa082af9a35f24dacc3200a1000ef2d40e4b10f50650fe8b1d0fd06b3b313b611fd00b062760fb19e8e881dcfdce0c75137e87d529379aecdab481dc3a3a04496594fe24f0512dc1abb199d05d735eb963e5e8ea1b0fa466a7e9b08a1535b7a761009f00dae21d7cca0fe916909cd4b00c18f139aa133f68c6cafff9fadcf41cc8b2b7e660186b3a9cd794021d06910e80fa051607934399fb21f98f64d0b09f03537e888ed166c81fc98b2d88f8c0f0ac191353a13694228b4ca6ad917c6117682c5128d8df867121acfbd192b5eed1d7734fcda4e42ce1add9ae1585413cf5fde5af105be087321429d1e17fecd1dd14859daa89f03b56b4f95b25ea414c5ddfe6662d250b771a29ce0d5f2be479beb570410ae1dc1b69939f7e8e96d15b73833d95bde36ddcac54cb419b274fff3c32b870f9252cd57a072080e619d24e1213debf365eabe62b28de62e32b93f9a97218a4f5c4e9755acb491276123aabd25f26c6842028c9c1707300db5d01b7a99d2c7a846e82b25c5e73c3343cc7bc15bae4e4abdb83858bd8c866b304ec8b7ffd8d96d6613c1f3953ec6223bdf27a39e2761c1eba5d8d79b0ca6cca0338b61ec92474598caa6d5074ead946060d8d0abdbdafbb25389437d91b48289a493af3b918eb4825cf65583db9f51408527fce6a29336a5bae97bd172e4ee1993c7563b369a55951f186e512f50df39691fe642577f4aa68c4ff5556266dc9de2726603b2c2f2b60835eaee0a56d03f5ad48b05edc01949f9239ee97ba8fc5f50b0105200bc725c324984d422fb636c7f22213671d21c1b402e64066a85ef4565a8b22dbb531f8be16543c18d4df3147a12e9848725be8f7153e12de07f1535a5710c454f19cbe57b815320a271366ad2a6ea6d3ffaba9d84e019c1935b04d442f7e8b98d9a5d7bf4194dc6e4b603234e835010a03ceef58cbafbf41f33ea7a50664a8b8ce6cd3bafc5bf1b8ea1e652c9ef0cc8a8d1f4960460de342c666e9d0f6fa7af32a97b1f7edd847683762fb36c4dbfcb787c1d910c188355a8b1a0d0aab00dbe1d21763bcf09ab4f26d06293aef0b530fc013563dcba5cdace5ab28e5c5e2cbc1e4629037244d1117b7fe571a6fdce644dcd9c9fa35fca58bdf7b3c63430d66af91417a1e19fb2c3a97aba5ee94ee303f2225d9f662a885e0a0f766a8db6e07320</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散文集《我在人间凑数的日子》</title>
      <link href="/articles/2019/12/17/1576553542302.html"/>
      <url>/articles/2019/12/17/1576553542302.html</url>
      
        <content type="html"><![CDATA[<h3 id="声明">声明</h3><ul><li>以下内容皆节选自散文集–《我在人间凑数的日子》</li><li>作者：全体皮皮虾APP网友</li><li>如有侵权，联系删除</li></ul><h3 id="正文">正文</h3><ul><li>关于你，时间会证明我曾经的付出，是多么可笑</li><li>小时候真傻，老是，盼着长大</li><li>我对世间唯一不满的是，它总是让更懂事的人，承受更多</li><li>溢出来的爱，就像水一样廉价</li><li>花言巧语是猎物，支支吾吾是喜欢</li><li>算命先生说，我是一只苍鹰，前途无量，后来才发现我听错了，算命先生说的是苍蝇</li><li>我善良一生，从未做过任何坏事，可人间疾苦一样没有放过我</li><li>世人慌慌张张，不过是图碎银几两</li><li>我遗憾的是，从未拥有过一个女孩的青春</li><li>寂寞如你我，一阵哆嗦后还是路人</li><li>咸鱼翻身还是咸鱼，蚂蚁再强，也只是蚂蚁</li><li>光阴惨淡淡，人无再少年</li><li>你和她约定共度年华，可偏偏你却一人白了头发</li><li>所有能够言语之苦，终究可以缓缓消除</li><li>读书时偷的懒， 要用一辈子来还</li><li>等你音信全无，我再去爱这世间万物</li><li>身上的伤是勋章，心上的伤是成长</li><li>鱼和熊掌不可兼得，唯独穷和单身可以</li><li>爷爷没有数个战火，父亲没有输给贫穷，我却输给了和平年代的生活与爱情，以及太过自由</li><li>我不记得小时候的梦想了，但绝对不是买一套房子</li><li>感觉什么都不缺，却又好像什么都没有</li><li>自己卫视的深情，一厢情愿的热情</li><li>老说找不到理想的另一半，问问自己，成为理想中的自己了吗</li><li>世界很美好，能让两个毫无关系的人走到一起，世界也很残酷，硬生生让两个相爱额人再没有未来</li><li>活着，就是一个接着一个的妥协</li><li>嫉妒使我面目全非，暗恋让我卑微入骨</li><li>自幼以为会有一番作为，衣锦还乡，现在想想，只希望父母在家安好</li><li>有些事只适合烂在心里，无声无息的忘记</li><li>我到底经历了什么，才能收起暴躁的脾气和骄傲</li><li>逢人不必言深，孤独本是常态</li><li>我不求名不求利，只希望在这个物欲横流的世界，太阳能晒黑我母亲的头发</li><li>磨灭你性格的不是现实，让你妥协的也不是生活，归根结底是，懒</li><li>如果快乐太难，那就，祝你一生平安</li><li>街头的狗，午时最凶，我有幸跟他们抢过食</li><li>如果没有这段话，你都不会知道，这人间我来过</li><li>小时候觉得世间的东西都很美好，后来长大了，发现很多东西都归财神爷掌管</li><li>我知道， 我一生终究会有人爱我的，但我好像失去了爱一个人的能力</li><li>她说民谣太穷了，一听就是一根烟，一听就是一瓶酒</li><li>那天风很大，她的笑很美，我想我一辈子都不会忘怀吧</li><li>多年以后才发现，这么些年，一直在帮助别人养媳妇儿</li><li>到底是过了一年，还是过了365个一天？</li><li>故事不长，也不难讲，相识一场，爱而不得</li><li>你说我不求上进，可你，没看到我低三下四的样子</li><li>上天还是善良的，他也是善良的，只是要了我半条命</li><li>我每天都在笑，你猜我过得好不好</li><li>你所在的城市下雨了，很想问你，有没有带伞</li><li>到了小时候羡慕的年纪，却没有成为小时候，羡慕的人</li><li>比起失去你，我更害怕别人拥有你</li><li>他们都想把我推向深渊，只是他们不知道，我就来自那里</li><li>无需找什么理由，一无所有，就是拼的理由</li><li>错过了她，遇见谁都没有感觉</li><li>外面好冷，我想回家</li><li>明明是你先招惹的我，为什么最后放不下的，却是我</li><li>和好容易，如初难</li><li>我对你，始于脸红，终于眼红</li><li>失而复得，就是重蹈覆辙</li><li>骨气不等于尊严，不能为了尊严，连你都不要了</li><li>心若没有栖息的地方，到哪里都是流浪</li><li>他们说海最干净透明，我想那是他们没见过你的眼睛</li><li>最怕一生碌碌无为，却还说着，平凡可贵</li><li>生活不止眼前的苟且，还有前任的喜帖</li><li>来到你喜欢的花店，花店的还在开，我，还在继续爱</li><li>就在刚刚，我对我的影子说了声，辛苦了，对不起</li><li>后来我们都走出了这段感情，你靠的是新欢，我靠的是时间</li><li>终于长到能与父亲碰杯的年纪，却没能成为他的骄傲</li><li>后来才发现，那并不是属于我的花，我只是途径她的绽放</li><li>曾经以为贫穷是指饥饿，衣不附体，现在才懂得，它是孤独与无人问津</li><li>散伙是人间常态，我们又不是什么例外</li><li>一直想做一个特别的人，现在我做到了，我特别的无助，特别的难过</li><li>有时候也挺佩服自己，能咽下一肚子的话语心酸</li><li>条条大路通罗马，可有的人就出生在罗马</li><li>曾经有一个女孩追我，被我拒绝了，我没房没车，她不懂事，但我得懂</li><li>所谓眉间的故事，不是喜欢就是辜负</li><li>后来我发现这世界真的很大，没有刻意见面，这辈子可能就再也见不到了</li><li>成熟，就是看以前的自己像个笨蛋</li><li>自你走后，好像不开心了很多年，原来不开心也可以成为习惯</li><li>回了趟故乡，故乡的气候一直没变，只是我却像个旅人</li><li>请不要用那微不足道的成绩，来对我指指点点，因为我不配</li><li>生活真的挺好的，每天都有不同的难过</li><li>可惜我相貌平平、一事无成，惊艳不了谁的岁月，温暖不了谁的人生</li><li>一个人就已经伤痕累累了，就别再来一人痛不欲生了</li><li>最后你会慢慢懂得，你只是她感情空虚时的替代品，偶尔会表现的特别爱你</li><li>我曾想一世荣华，最后却四海为家</li><li>那夜我喝醉了，突然发现，你比花生还下酒</li><li>做人不要低声下气，因为你父亲，曾把你高高举起</li><li>我寻思着理想这东西没啥用，所以一个月两千就卖给了生活</li><li>这个世界是公平的，就像我，虽然挣得少， 但是我干的多啊</li><li>早知道现在的生活是这个样子，20年前那场游泳比赛，就不该拿第一</li><li>时常有人羡慕我这样的自由，我笑着笑着便哭了</li><li>我们来一次世上不容易，所以她说，她想过的好一点</li><li>我也有诗和远方，可是我的诗很烂，远方很暗</li><li>生活，就是生下来，活下去</li><li>我有喜欢的人了，可是无人作证，又无人知晓</li><li>年轻不懂得爱情与友情，长大后才懂得爱情是那么不容易，尤其是那么的脆弱</li><li>生活从来都是这样，不把我放在眼里</li><li>你羡慕的生活背后，都是你熬不起的苦</li><li>自己都是满身灰暗，还总是想给别人一些光</li><li>不要假装努力，因为结果不会陪你演戏，行动在于自己，未来依旧可期</li><li>微笑并不代表快乐，那只是一种表情</li><li>你试图以离开引起别人的注意，却不知道你是真的离开了，并没有任何人记住你</li><li>小时候总觉得要做什么样的人，绝不能像某些人一样，长大后，却成了当初最讨厌的人</li><li>大事办不了，小事不爱办</li><li>很多道理我都懂，结果我能想到也只能接受，但是，我就是难受</li><li>好看的皮囊你玩不起，有趣的灵魂看不上你</li><li>遗憾的是，到最后我们连一张合影都没有</li><li>我讨厌无边的猜忌与怀疑，觉得人与人之间要多一点信任，直到有一天，我把它们当成了兴趣</li><li>她向你倾诉着寂寞，你却以为那是爱情</li><li>未完待续</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《许三观卖血记》阅读笔记</title>
      <link href="/articles/2019/10/31/1572508975114.html"/>
      <url>/articles/2019/10/31/1572508975114.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>  浮躁的9月与10月读了很多书，但是大多读一半就弃掉了，或是一些具有时代背景且富有深意的书，心浮气躁下的我无法解读其中之深意，只得草草收场。倒是最近读的这篇《许三观卖血记》指的一记。</p><h3 id="正文">正文</h3><p>  许三观通过卖血，将自己支离破碎的家庭一次又一次的拉回正轨，作者为我们塑造了一个平凡而不平庸的人。许三观可以说是很惨的，幼年时父亲离世，母亲跟着别人跑了，所以一直与爷爷和四叔生活在一起，到后来成家后不得不通过一次又一次的卖血去迈过生活的坎。在好奇与引导下进行了第一次卖血，然后通过卖血的钱成了家；第二次因为自己的儿子一乐打伤了方铁匠的儿子而无力偿还医药费时去卖了血；而后出于对自己出轨对象林芬芳的愧疚有了第三次卖血；因为自然灾害，想让全家人去胜利饭店去吃面而进行了第四次卖血；儿子一乐下乡插队因病回家；为了儿子补身体和提供一些日常开销的钱进行了第五次卖血；为了款待二乐下乡插队的生产队长进行了第六次卖血；第七次也是最漫长，最艰辛的一次，甚至差点死在路上，一乐查出肝炎，为了给儿子治病，不得不一路上卖血前往上海；最后一次卖血发生在许三观老年，因为自己想吃炒猪肝和喝黄酒而却医院卖血，但最终医院没有收他的血。</p><p>  许三观不过是一个小人物，是那个年代一个最典型的普通人物，但是这并不影响他的伟大。在那个时代背景下欣然接受不是自己亲生儿子一乐，原谅出轨的妻子。许三观也是很聪明的一个人，几句话和一天的时间就将心系何小勇的许玉兰娶回家中，文化大革命时期给妻子送饭，对于妻子的保护，无一不显示出他的聪明。文中在得知了一乐不是自己的儿子后对于一乐的区别对待也属于人之常情，可以随着时间的发展，许三观却对这个不是自己亲生的儿子的却是最好的，文中对于一乐的描写也是最多的。文中的许三观是一个有责任心有担当的人！一个有情有义的人！一个合格的丈夫！一个优秀的父亲！</p><p>  文章的最后，三个儿子都有了自己的生活，自己也到了颐养天年的年纪，许三观却在想吃一盘炒猪肝，喝二两黄酒的情况下想去再去卖血，可是最后血头却不在收他的血，这个时候他崩溃了，毕竟他这一生所有的坎都是靠自己卖血度过的，在得知自己的血不在能卖钱后，他惶恐，害怕家里在遇到灾难时自己该如何度过，不能卖血的他不能再为这个家遮风避雨，所以他崩溃了，也是文中他第一次崩溃，哪怕之前遇到的情况在糟糕，他也没有这样崩溃过，这也从侧面描写出，此时他的生活已经变得很好了，不会再遇到之前的那一道又一道的坎。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日刷leetcode--简单版（六）</title>
      <link href="/leetcode6.html"/>
      <url>/leetcode6.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="https://inkdp.cn/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="167-两数之和-ii-输入有序数组">167. 两数之和 II - 输入有序数组</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-56cb3cb1.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>定义双指针，分别在头部与尾部</li><li>判断两个的和是否与<code>targent</code>相等，相等级返回，比sum大则尾指针前移，反之头指针后移</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">sum := numbers[l] + numbers[r]</span><br><span class="line"><span class="keyword">if</span> sum == target &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">l++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Golang 提交中击败了97.30%的用户<br>内存消耗 :3 MB, 在所有 Golang 提交中击败了68.38%的用户</p></blockquote><h3 id="168-excel表列名称">168. Excel表列名称</h3><h4 id="题目描述：">题目描述：</h4><p><img src="https://cdn.inkdp.cn/img/image-6f5a1e22.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>可以看做一个10进制转26进制问题，进制转换原理可查看-&gt; <a href="https://zhuanlan.zhihu.com/p/75006709">理解进制转换的原理</a></li></ul><h5 id="复杂度分析">复杂度分析</h5><ul><li>时间复杂度：O(1)</li><li>空间复杂度：O(1)</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func convertToTitle(n int) string&#123;</span><br><span class="line">var str string</span><br><span class="line">for n &gt; 0 &#123;</span><br><span class="line">n -- &#x2F;&#x2F; 减去一个,因为A是对应的是1,而不是0</span><br><span class="line">str &#x3D; string(&#39;A&#39; + int32(n%26)) + str</span><br><span class="line">n&#x2F;&#x3D;26</span><br><span class="line">&#125;</span><br><span class="line">return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat Premium for Mac 破解教程</title>
      <link href="/articles/2019/10/24/1571890488789.html"/>
      <url>/articles/2019/10/24/1571890488789.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本教程破解的版本为Navicat Premium 12.1.27，理论上支持12.0.24~最新版，所以在你开始破解时请确认你的版本</p><h2 id="下载并安装">下载并安装</h2><p>进入<a href="https://www.navicat.com.cn/download/navicat-premium">Navicat Premium</a>，选中对应软件进行下载，安装就不多说了，整安装就可以了</p><h2 id="编译">编译</h2><h3 id="1-安装依赖">1. 安装依赖</h3><p>首先你的确认你安装了brew，没有的话就先去装一个吧，然后安装下列库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl  </span><br><span class="line">brew install capstone  </span><br><span class="line">brew install keystone  </span><br><span class="line">brew install rapidjson  </span><br><span class="line">brew install libplist  </span><br></pre></td></tr></table></figure><h3 id="2-克隆项目">2. 克隆项目</h3><p>克隆Mac分支，并编译keygen和patcher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone -b mac --single-branch https:&#x2F;&#x2F;github.com&#x2F;DoubleLabyrinth&#x2F;navicat-keygen.git</span><br><span class="line">cd navicat-keygen</span><br><span class="line">make all</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/image-605b5c43.png" alt="image.png"></p><p>编译成功后当前目录下的bin文件下回出现两个可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls bin&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/image-6e4f4f06.png" alt="image.png"></p><h3 id="3-备份">3. 备份</h3><ul><li>备份好<code>Navicat Premium.app/Contents/MacOS/Navicat Premium </code>，防止翻车(不怕翻车可跳过)</li><li>备份好Navicat中所有已保存的数据库连接(包括密码)，我没备份(可跳过）</li><li>移除所有Navicat在钥匙链中保持的密码，可通过搜索<code>navacat</code>来找到他们<br><img src="https://cdn.inkdp.cn/img/image-b4f15694.png" alt="image.png"></li></ul><h3 id="4-使用navicat-patcher替换公钥：">4. 使用navicat-patcher替换公钥：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> navicat-patcher &lt;Navicat installation path&gt; [RSA-2048 Private Key File]</span><br><span class="line"></span><br><span class="line">     &lt;Navicat installation path&gt;    Path to &#96;Navicat Premium.app&#96;.</span><br><span class="line">                                    Example:</span><br><span class="line">                                        &#x2F;Applications&#x2F;Navicat\ Premium.app&#x2F;</span><br><span class="line">                                    This parameter must be specified.</span><br><span class="line"></span><br><span class="line">     [RSA-2048 Private Key File]    Path to a PEM-format RSA-2048 private key file.</span><br><span class="line">                                    This parameter is optional.</span><br></pre></td></tr></table></figure><ul><li><code>Navicat installation path</code> ：<code>Navicat Premium.app</code>的路径，必填</li><li><code>RSA-2048 Private Key File</code>：PEM格式的RSA-2048的私钥路径，可选，不填会在当前目录下生成一个新的RSA-2047密钥文件<code>RegPrivateKey.pem</code></li></ul><p>默认如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;navicat-patcher &#x2F;Applications&#x2F;Navicat\ Premium.app&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/image-27449b40.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-5c6f876b.png" alt="image.png"></p><h3 id="5-生成一份自动签名-的代码签名证书">5. 生成一份自动签名 的代码签名证书</h3><ul><li>打开钥匙串访问</li><li>选择创建证书</li><li>输入名称&quot;Navicat&quot;，身份类型，证书类型</li><li>点击创建</li></ul><p><img src="https://cdn.inkdp.cn/img/image-99b4f449.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-8b2aa128.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-ea68d143.png" alt="image.png"></p><h3 id="6-签名">6. 签名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -f -s &quot;Navicat&quot; &#x2F;Applications&#x2F;Navicat\ Premium.app&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.inkdp.cn/img/image-c224bb16.png" alt="image.png"></p><h2 id="激活">激活</h2><h3 id="1-使用navicat-keygen生成序列号和激活码">1. 使用<code>navicat-keygen</code>生成序列号和激活码</h3><pre><code>Usage:   navicat-keygen &lt;RSA-2048 Private Key File&gt;   &lt;RSA-2048 Private Key File&gt;    Path to a PEM-format RSA-2048 private key file.   This parameter must be specified.  </code></pre><ul><li><code>RSA-2048 Private Key File</code>，PEM格式的RSA-2048密钥文件路径，既上文中提到的<code>RegPrivateKey.pem</code></li></ul><p>默认如下：</p><pre><code>./navicat-keygen ./RegPrivateKey.pem  </code></pre><p>输入语言以及主版本号后会得到一个序列号<br><img src="https://cdn.inkdp.cn/img/image-acf9356f.png" alt="image.png"><br>使用这个序列号来激活Navicat<br>接下来会要求你输入用户名以及组织名，随意填写即可<br>之后你会被要求填入请求码<br><strong>请不要关闭注册机！</strong><br><strong>请不要关闭注册机！</strong><br><strong>请不要关闭注册机！</strong></p><h3 id="2-断网并启动navicat-premium完成激活">2. 断网并启动Navicat premium完成激活</h3><ul><li>启动时点击注册</li><li>在注册页面输入注册机给你的序列号，点击激活</li></ul><p><img src="https://cdn.inkdp.cn/img/image-0aa226c9.png" alt="image.png"></p><ul><li>一般都会激活失败，这时点击手动激活即可</li></ul><p><img src="https://cdn.inkdp.cn/img/image-81692bde.png" alt="image.png"></p><ul><li>手动激活的窗口会给到你一个请求码，复制并粘贴到注册机里面，<strong>两次回车结束输入</strong></li></ul><p><img src="https://cdn.inkdp.cn/img/image-eaa0ba85.png" alt="image.png"></p><ul><li>不出意外的话，你会得到一个激活码，复制它并粘贴到navicat的手动激活窗口<br><img src="https://cdn.inkdp.cn/img/image-0b68abdb.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-e8dfb932.png" alt="image.png"></li><li>最后点击激活，没出问题的话就激活成功了<br><img src="https://cdn.inkdp.cn/img/image-d3b2e298.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-50a37e9d.png" alt="image.png"></li></ul><h2 id="参考">参考</h2><p><a href="https://github.com/DoubleLabyrinth/navicat-keygen/blob/mac/README.zh-CN.md">Navicat Keygen</a></p><h2 id="后记">后记</h2><p>由于删除了钥匙串的密码，所以原有连接里的密码可能需要重新输入</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迟来的9月总结</title>
      <link href="/articles/2019/10/13/1570960015377.html"/>
      <url>/articles/2019/10/13/1570960015377.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="3bb5edfe4e1819393d68a3b98d2ee232dff94d20d52628d662c207fc48af1497">b9cc9643baf4dcc59b37da2f24103eac4b24f3d12aae0a90d793c4295eee09d70b824dad37c68064534cc72d585388a00e4edf8645dafd03745d1eb7c1ec4c0db5c60361bfe8c4e1430907840a59c1ab786c5b885b2427d926b6ce2d3bcd6207830f42d2da7386b9477056978284043a398de1aed306a8aaa00959b6a146198620eb4291a8a432b45b59be3640568a5468c8fe95e0145fa567adbc81762d09cf5ab8b193dcefb22dd28b08ae79856d4bbdea9e522b1f6d9b9c2d511b3dfb5a07af73661a53dca7eb5c71add82782e0f77cbe6e9882dd13ecadf435f51a080019a0e1ea70abd08ff9212aed5c3383cb577cfa996ea701f959914c86784702d6034fa0d87191e03fd90fd7547888ddd2129bdeae632f94f8580927247aea78f3258316d91e2109b5c835f36e5a8496bace68ba70242532e0dd01ce85e709d1948100137ed9bda91a93b9d02badf0e2fc12b0c1fcf3d61e872e16775fd1879f00a85fc4aaeb77ea24b7b237533a6eee4125bdaab83bb1dfc69652412747be95d6593872565ea00fe5f5282c8687cd12d7ad9069f98f89ba7852339cacb1c2fd7a680f4cf92b9fb5c8503f8881b312bea2bfdbed1b98fc3ddc5e8d0a278f8fcd22e8f6f1fdd1831762d5078905bdad5c6ccac897a469ae164e45e81b95713c03fc1ea73e8165f30fb084b573e411effdfeaa286d2b668e9d121d395cc3673366ec6d0383487f7cb57dfa0c9b833a8a0639d22fd2e97f1ea0d0a2cde737c25d8026360daf43e203141adf25b455a7b6812be00372e8c68dc56d63e0cc4148152aff3e8c0987db109b2cb5acad4b6de02c7bf4864ff21b830560c0e724a036f45287be8a8014f154651b6ca73057a59957b50fe211ba6e5ecdeb12438b9a0395519bdb83139112fe752026529198cd8a0ea1208692538b5164affc84a346b8ec626547e887e939689ba4cf8ac3455c059930a989865f8cb4e4e68e56f5b6c3ab84466865c98703c31330055572f9a18752165dae05637ae4d874dc71aded4b64e0b074a4263fe03fb5d487fdcebc8d3bf57eb732159350863992a2c6017751f1aa6bf7b9285607fe35996126e1599976f411b45d85edde796c26a8d4c0552fd228d7c3b96406d06d386b65f38f0195d9762cbacdcfaea9149a830ff6ca5f7d3456a3ad8f8b82462776f864843e76b321ec0e095646b07887734c631cb60b09ce4e8f3723e1efae55edc8f999f5c3184e3b801af89a317cc65717271e5de5d8757a608d8fa6c728f3bd53ff133702ae73cef5bbe9325d050c8a1461efb0bef03f5e5811dfe2df780cb7c75495af34434fde1e7418cad705e1ecd2b7860574ce765bfa0a6640311a73ae535e1876cc9471262ebe2213e7e5d4a936f8df3eb3d6ec8c301e4e4f9ec9c4ecd02426084f6c3c1d26d0f279fb4545015f4b6293309531fa631dc1262645b878bb0c2fa37a0c5a703326872397890cc89c39675f9e0cbe2d0fdb5b03a97d26eadb1f26eba0884a2d5f24f9fb1903d02f092f1706ce5b33bb6832245730a4d56708cfdb470d7c24979b279d9f8bfcab05050f1d0898e5d196cdf60029b7c82ea9b9c40f0877426bb047d3582a07c0b44b36025dec306cc6a3e67481e120e89be3fc1099b71f7869ccdda6ed2ead3cd0b1d43ae3dce1cb7cf120b8f52e2a6aaf2bdb36d3118a027286823ed0b49e5853db159cba03ffc161d93561e3cc17b9c6802f42869de10ba491318f5de8bf66a7904857fee594d09384f1696959ba94a8f81e2105560f700ac4f95418471b9d2331b5e673543ef1a6098fcaae336d5e312d252558060f3680fad3d874773d95eb0b73846f990066eff9f988a0374553fcdc25af0a8845836c170ecf4f597cdb4f9161ce77d1a0538b05e377dc2c6f562780c3e1e4f50380b0e82cbb020f178f380c7360d7a796f376bf5589a1de816956222de877cf98bfa93ba9d28e4be653a383583399f49964e63680dd4a39314239b184a3666bc80cb9e5abe0e01e6c8c19c2a5bb50ae0996561559413ece3d78b6eea6ea77feb713ba5d5410aed5d92ca300cdc1f098e333b6dea7efca361ce4aae2d51418173e9947d3d08b9b097d6207321afacf35f2df7c46d744c6b4e707dacc00f2c8d83d46fcab94d6e69a00435563bcd536c77908c21cab9247d577633a12642413e67e6d33596deb6a8f2e071ebf97ca8052aefbe5beae7663623428bbcfe30d03718ee5dd571722683883c77246e2c2c9e5f1b815ba4a711bccbcfa1940b092a806649cd71b8277f8af35d7c5ed098ec1e11f120bcab25edd3a5bc094e08438ad30c62be5dedfecb5a00af4c42541b36b95042c0d9486d707e54bc1c94fa45cfec906429278ef956f00cff1ccd0294eaf13e1f8efa5e65bd82a01ee37c1939636fdea9691204b74e33ce657f9069550821b366866dfed086f33855c290dac3d687a576d7e5d11ffefa33970bedd7dec2b59e8b89c1ed9110f42517ceca4f04f75619c79fa3f599d581af02e85f8c423fc761a03b52edfaf8b3a587d2058ab7033d3bed7d28f3045e57d8432a599a7d830c6d5cf99ff87400e9f88b44ff4a043152b0f22b10a23c7ac3eea838bf04437a828aff76514ee1b8671f2d751f7c704b81e8e0b08d8333eb92303c7f4e454c4a4a97ff98a8f312b19f59d4ffaf41e4520b18c88581066d4f58bc93896d49137d053e8ce1bec74d9b4affae11c2d4582e8699b96029a8a6f56b80e6a94b08835176737fedb2344d9bd360fa92c60ca7d618096d26fa620abb4deb33fdca032c2c3bd5b7585e2aec2c02acb50ae4e57732a6db755525780db924f0ffbb533d7ba71122f95738935ebd9fd13a7867aa2c078d249543dfb08b091c6f4bd132b7843a07729d784cd4095e49a193f9cb8d02565b3e1d20cfbf680ba454fe401ebc12e4227b8cce59cb1e69d3eb216974188a29d1c73884841e726cc56b67b675c20a0fd358223896c4482ad15ed1188a40cd5291e9f4ec95aca8723a1495536b3dea97aac99818a1b85e89c85dcee626f37a9c66e9af369920f3fd613dfb4412bf1981411b1d2bc7514fd15bfd2bdb6848c0958873910e106311fefc4e5be84275fe48784f3b2b7ee3aae72eb13ea7fff83d4a89f08ae39edbee8714c46e151f76f5b340f6ac77fce37824521687952d424787f7e2964ef632f06c8c2b67c24bb39987f47c292265dc5a8398ed6959cd17a6a64131b787b44e1a74eb203c51e7b2cdd211e03f2309193786056dee49c90439c8ce5e0a02718ec7eacb0f312022a2fbff3774334c7070fbe2a9d7e408ffbe5db447d79290673be78394eff122cb3dee90e4d7b40300f905f74bc2af6ca7197bb747ccb0d537d617ed177f599af4bde26899b094d0805f6fdd2c2aef7b2354b00ced2f59982483f4d65b343063ce40668438f4e06024c69cc9398ed379cdd655610f647c18fe994accd3a9eeb8e8ec1e0d0c728e80e5cbdf5ecdf290555df812259e54af5fa9d5ddd318ca321fa2beba63c1c1d1913b4dfa0c2db6ecbe6160edb3ac58dad04db1d0d60189c4f4c109ce1c214199b470a6daaf137ea42888b6319ea0ae0fcdf41fe11f97d57872d1c0002ea09046f5256a104031696848e05a336fafd4180ee362934eaeb56c780fb69a2bd7539a9b7c03fde18a12dcb04776d464472d230a6e3d61a1339964b4c03084bee02ceedff8fba834af0929ecc4f48520e4311d9928e58668e0b99db575cf7f2c756e729aa1330093a152291805a0c38f5d73424a237d2648d619b1c1a51cbd48abfa9c8b209428b2f33636f6e663f170ca346200bde310b897dcc75c1a7986b7dd6032a4b6aed8f1a7b223690cea9c74826be01803955a53c639ce89cb28409e8430d66f0bfa5b8930cb9042de00e5cbfa30a89e426bd760d5686a18f202a481ae0a6286974ca0e6666d7d6e86c4b666835c2a2d64b7f6137da1182e9c5392706a6f7aebff311a61380b1b6ca3369c0c6d602d7c435a19a1bbdb0aea1aae31451f0a0b84a8bed5adce9d3f4b15bab3a19d64fb5f223ca44a7945ec9cd9ab6b74504b80e53e8718aa42291dc500028a16e861b1d4f44e39bbbc4448d3f0c7212f8d93dc66f3258b0adc3393679e5d72559f75e62ec02a561d10722ce5351f833df9a028dd85ecf390038643b1d781d25c671f9d6b4a5f879aaed2cdcf0949ffe6bfda91d9bf06c1a2b89a0ee8ce92434a3ccd13efccdb30a30c3c5c9d90dffb1b9936c5c19890e48441bfa1ae2dc2771329dbbe24b725369d7dc469116474e3f687cfd078517eaa0f97afecd502d53a9845f600f0cd8c80b33fede90c1a5bf9e1556d5efe1c9501e637f5cd0d75cecd478eb8e44eb7d91410e47bae68e86a2f035e7a23994049badc2274b9770db422480d66214d66ab2025fc31a4fc380935b8c5638d66df46a0e33de84c8fdcab052ed20adea33935500696affcf953c31b305d3fb451945c814c2bae9185967dbb1b2185868c1ffd5390047be2c5dd3cc476213e2b6e0b9f5bc308d1dcca804f0a202699e05cefd307f6272f3032300a9e47e177da5e7379fa7e2ba7228c3b7103864cd77526f95b3b0b085a50d8d0a5cbd9d93391f136b65928b731082f2227937ac69a318e7e5504406ca153ee73c52aeaadb0a3980e8d6023f2f0ee7f989bb64195c513880f0922901616acffadf012bcd844e15ee25f2df74279c17f5097b8404bdb8a0b0437fbe75d48dd4d2cd31d6e5d9b800d753151454c3fcdbe9a399b3f03c76702a4b8ee9edca7c786598bbdb1b2bdea1e27262ad8b39b2f672356c490ac6395ade6963471fadbd815a05c901bf9f173ce3d7742942f4cbd600e88b3c1172b8db90a11ab9f0cd7076ce09d0a645113d7ca76f35abef6baeae154164869c6681fcfb4c1932ada743f4d7f20dd4a8ef072407d29784f8737a8417886b8c7b0e103308fe9bf44c5071829f50a56a27ed145b33c75d669aa772a89d6470fff34ca5e0ecd412b9c7261c1917d5b509656b934d0a402f097f143eb705b4cd45226afb2d0d1f9ce66cff360b405011cee6657704c7eaaaf73e098175a501d00e56a67b165a9c7cf82a2c02494c13efce3baf19d4c504486e97f6dbc65a6b5676441e5e588e2f69bc42d7a0b2e57b21cfa3a53cdf7cc4ef0513ae86224899ba4fbcbd517bcff1327e1cc5ca8f8ec8a9948d0cd48fd10e0e81843d9e1482b8a20c56528a5e8ab035a14f4108939e860a31a9b8c3c9471592c2c1d3e8e9ed69b14688c136ce5b8f3e60a0fa87e0d067a3c1d1c393a3f30fbad64fe631b22acb6e4815d8bf1f4379dbebd0089eb8e462ac125b2f4a9423c194b77659fdfc01cea91cfd80cb2e6bce99d279c5f3ab4596c4c35348e0c0ffab68d28c3dec5595d2f4c9368ecba42847dd134bfde87b5bd669fd78c3ed68d5a13059454efc5738fc5ab21033346fb523340e0a3420aaffb0335fb332eb0990cc7f2dd5f0a4295b3dc4f7ba3033d9055f03121504f745a8dab336bec4a2135b57de1ad8db36d29395169d78a7e1293f09da70148a0756be427ccc398cd763b8c6b5e7f954d84c9125283ee070363fd99a2876632b543626df77d2fd6ed7a8581b5d1c503724107386a96c3b45ab9a8c9e9cd7afce9a68e942c720871c041231846f816d461c12b9893760042cd5039a2d961f84572b65f98637bcbc3d70eefaa073e95955e1f15feb04e272ea8ab2772a4263ca2bc0b98bd7a0e194cbc7337d20e44df30f3debd76466a405277976253cfd5ffce09e4e7a050da241fcc93e4e2a69fc0d8335a1d33b1e0accc43512b74568423d91694590b1cfc8dc54a2a1ed2008406cb052075e21f100e5eaeda97e6f0a48947820be597ecf2108428a6e6c4d8b79bad2e55bc2b4990c75736e2c76cf11c04387d38760c061b715e6476baeba2afa277dd276f9fef5906fadd2529882d0a8dbe535e2292b1eca9db8779da0d5b5af623ee296bc240c5f4e195e39aaa61ec5b41241b5f9cb6337e9df2ab7a35e183eb22c2c99da4fbc8457f6e053b93e193efb35d451df70f7110533831778a3e468f0405a4acfa70384f33c5c9614e8c49237e1c759d7c8d312aa92c7dfeb75783fc6e94bc24d8cd4415f183be2f9625a129a1c8888731327c601c59d5d538f9d2b2d64ab249215383957cebbbf6ed03d48ae5764b1df0f7ed03a0e028587db6125a19a4c1d9f11e0e3ab22e1efcdf0b3c697b8fc8f4b91d5a9365e00cf26c7d55e323afd36774b5d1bdddd9d2e183ccbfa2b6ca4ba775d3aeb065d5682b8dc84c425027146337ae5e8d8af48b8103814f9261529623ff616c73921e97c3cdeab35363ce62eaf6c12b73259124a7a0f28da3b8f514183000b64bb5d881ed959406c390b17a6876a62c324ddc3b64ad18edcc2154503da9317c0cba61daeff54d3d976fc323080e68ea96d3e542c92fdabc17aae06ce7f23bde145dd3a1075567934</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO实现一个单链表</title>
      <link href="/articles/2019/09/26/1569488898577.html"/>
      <url>/articles/2019/09/26/1569488898577.html</url>
      
        <content type="html"><![CDATA[<h1 id="不多bb-直接上代码-有关链表定义-请自行百度">不多BB，直接上代码，有关链表定义，请自行百度</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ListNode&#123;<span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *ListNode)</span> <span class="title">Traverse</span><span class="params">()</span></span> &#123;</span><br><span class="line">point := head</span><br><span class="line">fmt.Println(<span class="string">&quot;--------start----------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="literal">nil</span> != point &#123;</span><br><span class="line">fmt.Println(point.Val)</span><br><span class="line">point = point.Next</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;--------end----------&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *ListNode)</span> <span class="title">Insert</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">p := head</span><br><span class="line"><span class="keyword">for</span> p.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">p = p.Next <span class="comment">// 位移至尾节点</span></span><br><span class="line">&#125;</span><br><span class="line">s := &amp;ListNode&#123;Val: val&#125;</span><br><span class="line">p.Next = s</span><br><span class="line"><span class="keyword">if</span> p.Val == <span class="literal">nil</span> &#123; <span class="comment">// 插入时发现首节点为空时前移</span></span><br><span class="line">p.Val = p.Next.Val</span><br><span class="line">p.Next = p.Next.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">linkedList := New()</span><br><span class="line">linkedList.Insert(<span class="number">1</span>)</span><br><span class="line">linkedList.Insert(<span class="number">2</span>)</span><br><span class="line">linkedList.Traverse()</span><br><span class="line"><span class="comment">// --------start----------</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// --------end----------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go面试总结</title>
      <link href="/articles/2019/09/25/1569402355322.html"/>
      <url>/articles/2019/09/25/1569402355322.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>俗话说得好，打铁还需自身硬，面对面试官的各种套路，刁钻复杂的各种问题，只有自身实力足够强硬，才能从容不迫的对答如流。<br>此贴意在总结自身面试中遇到的各种问题，让自己面试前能够得到复习，可以抱抱佛脚。</p><h2 id="go-基础">Go 基础</h2><p>基础部分有部分为包的一下基础东西，自行查阅文档或谷歌</p><ol><li><p>sync<br>参考<a href="https://deepzz.com/post/Golang-sync-package-usage.html">浅谈 Golang sync 包的相关使用方法</a></p></li><li><p>channel</p></li><li><p>goroutine</p></li><li><p>reflect<br>答：当时答不上来，依稀记得公司大佬说过，反射性能不好，随口答曰，影响性能很少用它?</p></li><li><p>并发通道安全</p></li><li><p>go支持类的重载吗？<br>答：不支持<br>6.1. 如果我需要的话可以实现吗？<br>答：可以用接口实现（具体实现方式百度）</p></li><li><p>interface</p></li><li><p>包名/目录名之间的关系<br>答：姑且总结为一下几点：</p><ul><li>import导入的是路径而不是包名</li><li>一个文件夹下只能有一个package</li><li>尽量让目录名与包名一致(非强制）</li><li>代码中使用包时，引用的是包名称而非目录</li><li>一个包所有的文件，必须位于同一个目录下</li></ul></li><li><p>字符串拼接的方式（延升问题，性能比较）<br>答：使用运算符、fmt.Sprintf()、strings.Join()、buffer.WriteString()。执行效率如下图（理论上最后一个应该是最快的，不知道是不是我测试用例的原因）<br><img src="https://cdn.inkdp.cn/img/image-b6c8f4f0.png" alt="image.png"></p></li><li><p>GC，何时回收，如何手动回收等</p></li><li><p>并非时如何防止公共变量污染问题</p><p>答：锁或者通道</p></li></ol><h2 id="mysql">MySQL</h2><ol><li><p>MySQL 事务隔离级别<br>了解隔离级别前先了解脏读、不可重复读、幻读这三个概念</p><ul><li>脏读：一个事物读取到了另外一个事物未提交更新的数据，事物 A 更新了数据，但未提交，事物 B 读取到了这个更新数据，由于某些原因事物 A 回滚了，而此时事物 B 读取到的是事物 A 未提交的更新数据，此为脏读</li><li>不可重复读：在一个事务中多次查询统一数据的到的结果不一致，事物 A 中多次读取数据’a’,在此过程中事物 B 更新并提交数据’a’,导致事物 A 多次读取的数据’a’不一致，此为不可重复读。可重复读与之相反，即多次读取到的都是同意数据，事物 B 更新并提交后的数据’a’读取不到。</li><li>幻读：在一个事物中使用同样的查询语句查询出来的结果不一致(这里的结果不一致体现在结果集个数，而非数据内容不同，数据内容不同为不可重复读)，事物 A 中多次使用同一查询条件查询数据，在此过程中，事物 B 插入了若干条符合事物 A 中查询条件的数据，事物 A 后续查询突然多出若干条数据，此为幻读</li><li>小结：不可重复读的和幻读很容易混淆，不可重复读侧<strong>重于修改</strong>，幻读侧重于<strong>新增或删除</strong></li></ul><p>| 隔离级别 | 脏读 | 不可重复读 | 幻读 |<br>| :- | :-: | :-: | :-: |<br>| 读未提交(read-uncommitted) | ✓ | ✓ | ✓ |<br>| 不可重复读(read-committed) | × | ✓ | ✓ |<br>| 可重复读(repeatable-read) | × | × | ✓ |<br>| 串行化(serializable) | × | × | × |</p></li><li><p>索引失效场景</p><ul><li>列类型是字符串，查询条件未加引号</li><li>未使用索引列作为查询条件</li><li>使用了比较操作符 LIKE 和 REGEXP，搜索模板的第一个字符是通配符</li><li>在查询条件中使用 OR，如果想要 OR 时索引生效，需要将所有 OR 中每个列都加上索引</li><li>对索引列进行运算</li><li>查询条件里有不等于号</li><li>查询条件里使用了函数</li><li>在 JOIN 操作中（需要从多个数据表提取数据时），MySQL 只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用</li><li>在 ORDER BY 操作中，MySQL 只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快 ORDER BY 操作方面也没什么作用</li><li>如果 MySQL 估计使用全表扫描要比使用索引快</li><li>…</li></ul></li><li><p>MySQL存储引擎的区别与比较</p><ul><li>MyISAM：有较高的插入、查询速度，但<strong>不支持事务</strong></li><li>InnoDB：事务型数据库的首选引擎，支持事务安全表（ACID），支持<strong>行锁定</strong>和<strong>外键，InnoDB是默认的MySQL引擎</strong></li></ul></li><li><p>Delete，drop与trunkcate的区别</p><ul><li>delete和truncate操作只删除表中数据，而不删除表结构；delete删除时对于自增类型的字段，值不会从1开始，truncate可以实现删除数据后，自增类型字段从1开始。drop语句将删除表的结构被依赖的约束(constraint)，触发器(trigger)，索引(index)；依赖于该报的存储过程/函数将会保留，但是会变成invalid状态。</li><li>属于不同类型的操作，delete属于DML，这个操作会发放到rollback segement中，事务提交后才能生效；如果有相应的trigger，执行的时候将被触发。drop与truncate属于DDL，操作立即生效，原数据不会放到rollback segement中，不能回滚，操作是不触发trigger。</li><li>delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不动。显然drop语句将所占用的空间全部释放，truncate语句缺省情况下把空间释放到minextents个extent，除非使用reuse storage；truncate会将高水位线复位(回到最开始)</li><li>执行速度，drop &gt; truncate &gt; delete</li><li>安全性：小心使用drop和truncate，尤其是没有备份的时候</li><li>完全删除表[drop]，想保留表而删除所有数据且与事务无关[truncate]，如果和事务有关，或者想触发trigger[delete]</li></ul></li></ol><h2 id="算法">算法</h2><ol><li><pre><code class="language-go">func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; var prev *ListNode p := head for p != nil &#123; p.Next, prev, p = prev, p, p.Next &#125; return prev&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">2. time，string，regexp，goroutine</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;regexp&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 第一题</span><br><span class="line">from, _ :&#x3D; time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, &quot;2019-09-27 00:00:00&quot;, time.Local)</span><br><span class="line">fmt.Println(sumDiffTime(time.Now(), from))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二题</span><br><span class="line">vars :&#x3D; make(map[string]string)</span><br><span class="line">vars[&quot;name&quot;] &#x3D; &quot;小狮子&quot;</span><br><span class="line">vars[&quot;age&quot;] &#x3D; &quot;18&quot;</span><br><span class="line">fmt.Println(printTemplate(vars))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第三题：并发答应1-10，要求顺序输出</span><br><span class="line">gogogo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type TimeDiff struct &#123;</span><br><span class="line">Days    int64</span><br><span class="line">Hours   int64</span><br><span class="line">Minutes int64</span><br><span class="line">Ms      int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sumDiffTime 需要实现以下方法：传入两个不同的时间，计算出两个时间的间隔时间</span><br><span class="line"></span><br><span class="line">func sumDiffTime(from time.Time, to time.Time) TimeDiff &#123;</span><br><span class="line">diff :&#x3D; from.Unix() - to.Unix()</span><br><span class="line">Days :&#x3D; diff &#x2F; 60 &#x2F; 60 &#x2F; 24</span><br><span class="line">diff &#x3D; diff - 60*60*24*Days</span><br><span class="line"></span><br><span class="line">Hours :&#x3D; diff &#x2F; 60 &#x2F; 60</span><br><span class="line">diff &#x3D; diff - 60*60*Hours</span><br><span class="line">Minutes :&#x3D; diff &#x2F; 60</span><br><span class="line">diff &#x3D; diff - 60*Minutes</span><br><span class="line">return TimeDiff&#123;</span><br><span class="line">Days:    Days,</span><br><span class="line">Hours:   Hours,</span><br><span class="line">Minutes: Minutes,</span><br><span class="line">Ms:      diff,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 需要将str转换为指定字符串:⼩狮⼦今年18岁了,不要⽤字符串拼接</span><br><span class="line">func printTemplate(vars map[string]string) string &#123;</span><br><span class="line">tp :&#x3D; &quot;&#123;name&#125;今年&#123;age&#125;岁了&quot;</span><br><span class="line">str :&#x3D; &quot;&quot;</span><br><span class="line"></span><br><span class="line">reg :&#x3D; regexp.MustCompile(&#96;&#123;([a-z]+)&#125;&#96;)     &#x2F;&#x2F; 创建匹配&#123;name&#125;&#x2F;&#123;age&#125;的正则</span><br><span class="line">params :&#x3D; reg.FindAllStringSubmatch(tp, -1) &#x2F;&#x2F; [[&#123;name&#125; name] [&#123;age&#125; age]]</span><br><span class="line">&#x2F;&#x2F; 替换</span><br><span class="line">str &#x3D; strings.Replace(tp, params[0][0], vars[params[0][1]], 1)</span><br><span class="line">str &#x3D; strings.Replace(str, params[1][0], vars[params[1][1]], 1)</span><br><span class="line"></span><br><span class="line">return str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 并发打印1-10，并按顺序打印</span><br><span class="line">func gogogo() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">go func(ch chan int) &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;(ch)</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>时间复杂度计算方式</p></li></ol><h2 id="docker">Docker</h2><ol><li>Docker swarm<br><a href="https://yeasy.gitbooks.io/docker_practice/swarm_mode/overview.html">https://yeasy.gitbooks.io/docker_practice/swarm_mode/overview.html</a></li><li>Docker machine<br><a href="https://www.cnblogs.com/sparkdev/p/7044950.html">https://www.cnblogs.com/sparkdev/p/7044950.html</a></li></ol><h2 id="linux">Linux</h2><ol><li>进程管理</li><li>netstat的使用</li></ol><h2 id="redis">Redis</h2><ol><li>讲讲你对Redis的理解</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> docker </tag>
            
            <tag> Golang </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一别两宽，各生欢喜</title>
      <link href="/articles/2019/09/21/1569077915744.html"/>
      <url>/articles/2019/09/21/1569077915744.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f19c12306bf2501cc624aa76303012ee982764ab9851976406ad20ba5d23b9df">b9cc9643baf4dcc59b37da2f24103eac0385ce3a5cf19866d56ec5127910f5f124273920f57a5cbdee659e5a6e265b75a4ed75457b864f0637c9d808587fc4fe6ed8cb0f6298e324c81a53ab5dbcca0ce871b1f23af15642aa3efd81eaac4fe416f28d36bfcfd048849bf99833342b1c0ceb9e1a43c1a6c8a92ccfc145f4ef9025a4bec774433efb16c96ddf812c3535ed8804992fd71d14df05fb7d23eb018d1e3e0998c3ccc9d60f33bf8f06e12d919dc7dd276a21be59561f153dbea9e3961f329507d4c180138126f4084265cc329374a39420cafab026316383d910e94866a021067cd354b844d5e6bb1f1d4d8fc2933585cbad9c7f738a3af8cca6f93c9d1fd59451963cd76fa9ea7bc14e1906b982711dfc8e58b83ac254d31cd2c1f1ff7ed120bccbdd63fa8b1099fce6ac93fa971760c7b3b729a9675eae2ff4ce0e402b3dddeda2e9db628e6544604eb95c933f7ec0249ba71a3c1cd8587ce17131e9ad4768ffe5f3b39ba815fbdff89f9bbd21a123ddb089d4221347eba7041fb68a9290f5fa6973bdb9e26ea7ce08f696975cb7ff61017e30d1bc38b852bcaefdc59f3ef62a782292fe04a2e92da720cccf9e1d3da9ebb0233361e54e79bc18697ae4592a9d7b2c35a2c3c4da12cda24644edff0d66269dc9d4efe596b6ff197244503d0b80c26ac5724cd29fb35327b29836ee251d43d314552947506b3cff69ca14736b91030ddbf47c524d6f8b7f42a0d49d78efad5cf05cdec05f4bf7daf50460271b7dfae136c9de195ccb5970bc08cf60005f754ec25d01b581d7e75713244e31cc380a7a5c200d0962470103b237ea4b5cb27a08c346ff63ae0fdebd65d658176d45b50312f5601fe153d20c48586171cc43a06c6d76b49cfd974fab05f704670e89224675fea359ff7c9aa60eefdc109ab91c36bb410e763842c795240314fdd9c4c5baa3c75f5407a29ccdcaf51847a545a6a69ea7731cc84333a52f68aa5e7efc7af16b3f9efbe839cb1ba2d92ded9248acebaa958cdcea70c3c820078c2de6ef46a90be18a30a3c5f30cd0c81095414e8ffdabc941e1f92923895731f8954abc9a1699d6a0977d9e97c2a4e4e49b30759db18c6746caf3954d98b0ef97a57049290afea61993dec3b775907a02dede898fc0cfb5e25ec2be5d162a4836d1dd7c0362539a42b19ef2b1be985ac09b522d951653cb007f1ea3179786863a786baa091d8456e6ef5a6eb3d5ed7fe9bd4912187533460a3e066cad0cc1d6a0d6000df416ebcfbfc2ac23237219b611540dcb44e5fae6e3224a07a866bad730d93d314337f3426345c259ab24d2394dbba8b03d5d76efd8dd2c647d3e69ce61d5bb116722eca902db0337a7311c0ad397c1f045d5a070a3af415e8e1207ce648fcee44645d5e9d68ed374cdef98e7ce780ea9fb30cc1ad1ff6840aafeca2d01c41615e2986223732576c844c3b7d2b3ea788916ae8f08decc29317bed2993c02e93ea958e951f00af79cb318b6eaac732ec8543a664cb35c866b6a96f50520a2811135c37890e957162a91ec104f887b4a27836cd057ff767c7ac8ce6d1c0b3933e4d9c05869ee8c52bd820c08500e951a1f7129f24696100a212e484a0cd34549b288975b59fcd2a2a7db3fd087ba7b5f8f47cc5862a8214dd7c7e8f286bcb4e230be6d3f3dbdbe288352e2bdf337c6492062e3156fc3d03aedd6806c49a0948fcd5008a924be3835dd5f6e6f9329df47e83abf2c5eb6c359a4d31604861828f8cf162f4eca8453858d06329d8a6e3f3452dbe24fe960bf6b8ebd94fca5ca06e9bdd8b482e48508933a8bb75bb22ab7c4dd35ea38f4aa7a7326db0de0b2a2e561b5545b16aa6479da928a79017285b7f471bcf5eca0050ce16f1c837de7a6fd0dc2963110670779284b8d630702a5fc8fea2fdb4244356579fac6a282ca7f3914934d2147857da251b6f557e3352504e78149fa741e96e55e2cc345b8c97f224cc319bc207340d06cd4260741fe1a0742aec2405a65f9f2870a0170ba735f23c9d16abaf54bafce47dad1071b893986edcba1a01470487f254fc44d3f04eb1cfdf5b02e1d163022ffad135ea6cb5cb54ea704db9d7f70177d9cb5589e7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 情感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> private </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲言碎语</title>
      <link href="/articles/2019/09/19/1568902818001.html"/>
      <url>/articles/2019/09/19/1568902818001.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="9248778c1b9794da6515187fbd4d8b0fa301d57fc1e6cf8c2dff5463b3b5e96f">b9cc9643baf4dcc59b37da2f24103eacb543941c5b19021c269a584ed40df1ba06a9ed231a67e564583e1384f35dfb92d3cc7d4cf8d309782cf3c5937acea445f466c8f78d98fdc064f731fe6c0537f159eaf411be523be6298c0073b8a860b3323ecfc22146af762d8948528b0a1f02ff214fba6d49cf90f87ff24e9397b7d0b7a9aa14184d45b933e6a33b9802f75fa4b9ea3f500eb0115d01b913755fdf84621e2afc22ad6dc8d25981ee4d8eac29b62c85ff8a60512338fff03883bafe7363492bd43b2911f34f390419bc7ab342498ed1d5c905c5e20f34a949f3d9f6d6751bd97e4390881880b58b61be5333313f2bb7481b8161d032304fa9e7fcf66ec7e7f300f267bebaa0f281bd2805c58a6381d96fb8ecfdd370ee53185fd77cfdf29fed36b88e16539fa0bc36e4a806edef8215aea1bbfc6e988c8e2e2e9cfea5c37a7b645b4dd107638a3154212a86ed78e7dad7d62ef9c8fc8c9abf2c372225f7a389c9c8351f17299dda94dc24effbb4fc2c556ed48e926f104a4edf295ea58c612ff640d98266e15091bb334e7e9ac8b265e2ff23e723c6bda81b82baa2276977aa2241691abd0142431a9acc809eacdc2a32b1fceacdd05a32bee6ad147cff7310da2089705bbe7d5a97dca6512bf1ecf1e884f9ede2074dce805b1d470f72782b41dbc6a834c6059e3135da013f095127fc2b7b1d806b408c15917ce10818a1b1de3239cf4311fc5e2b88873f43078ad62c47a937a4b3360ec86f087b3c141280872dd50b50f64fb8251a68c924347b92f6ace8d679efa6bc014e06ff5aec5ba5567dc6d74798e75084e0603f26794212d7820afc1a64a0108259283eb0dfaba79f424ecd1c44f918e9ded956a11316072a2b7e964fb662c3494b96b597588ebdf94089e84e2c1ba0e1d332f1124a0bfc369a8c1c3f37bfe21cfbbfcc53eaae1482db2ec978c5c2bb82d70beb4f16c2ac5ec5a1dc28a72d22ae624a3e612c72c14e5309c566e7d32617b7dba72d90ab139925d833017d38997fcd90410775d18d4cb5c12abab16b4c29280c7aebe03cbe97331ab70a2a591f656fd44bc2e8712ad3445f4f5607761401a0eb9d8dfff2da25465d64a69659288fe060fa86999c8bf3180f90b7facf01889765536388fc6daf4b4227c789a77eb4e70bfd17c2df52e796b92f04f41491b33aa063d98023c99d1a1eff59c17064b90182892b4e5c445ab81acba209bb4688e33864f9cd54994d915961ba0007cd442bfd9b6766ed924e2bd19e62248805320872c8f0915455bb4a72a492c74a5cd14f2a66bea5c87b9bf2d2445f2726f5f69d14be9c9baa09f25923628f5767766da22f371d246949c3d8ec81cdef42dba2b6f748dd94e718efcfe8900875f20f8b4c47e8a6f86c3e033e368d40834caf23a884a1159a8ee51de3bd47add97f2b4095812bfb1dd59ecfd26c367fd1ecf37b45bffe20c2dc784d487b61859ea901283b3292279b58debd9a398781f1cf7dabc0b736923f67c09fe7607fdbb4142b22a24535ecee8263f2af2485255aa8f51998f2dc0449717a23c69576e4434c0c2a1db1a780f92d36ceea88c3bccac8dda5d7f81e94ae4a2e09a503f799400ea9b3987ef52b607d15c53affdb68cc03ac0607aaa50f901a5b8cc9149f842e793c04e4cf132e183beee0a94ff0f8535652aed73d6f6cf0b35650a00fc09aacabb7dd5a2a8c290db0974974f8dec2b12e37b580e072ee12300141d8f7252091812cd9b55ac7e86bbc15cbfde24cc765c65e6fd8318d6c312af66b1d298e95baeed0d35430a3c15804786f056bc76eb2cdf60c1fc2b0e8867fbdcd5f4e9055f50b370262b1cb402e79f975abf9aa471e3a973228d5cfd2c58c6f2d29d2397344d6ba094988dd59d0992cf434f5b53b42ad70faf49839454dfd53007b439fb1565774361e5d0dcb18189b6d19f78b378e39000d2d80269037e19b44a27d193aa8337d83cbbc7d898b69dad9f8aa393b13c5b49ebe31012270121754acfc106dcd988d41499d23021ea520e71bc8f4a28d9cc9401f39c169a945dafc2561523af3a256c03cbf20b2aee5a1ef693411b8ff9828789befa30835b56223a152e79634cf3da81d27d5de5b8f15a6d95d38519d5cb7f052b9b8ad170175d65c18bd833737516d32ea4cb23345e9fd17347d8aeb31574613767ced0685cca4e580c0c9c15cee2ec9e903998c4b7547f212fde9d56c3fa00ece84d5775db8e94b0de25809ff7f57d6b3f2384fd0a9c4ddd116e0fad220bd43d110e9cdc1db9a44d18b86d357117460bb1707e55fc7f6fbe1bbc9bb7286ae733f153372eaaecdda4eea45c19014df82afe61fe839d3235ebb63766fd9ad880c166579688de32085ae3c5ad8672a765eb7b9a20b579af07d612221cd436e30d79643e539c68ce7b2684973a891f70a26a8a85044e2d4a50215c2b76f0e30a3ad513585e516628cbfc737fe6ada46aab31a9fd8292a6b824c87171e78b313f2ba61659f6c2af561808db89dc17d87b94b1e2d916189e19318d5b19e4431a45d2b06ff8abab29c49d63b96158b36ded062472f037cc5b68ceadedb98ea4c9c3584d5791e79ab4f8b9434849b1ae731913e47fb91fe0af0fd0af3b83970281dad99192651b844b2b73f1bd26c717c86065d6c928821d9af525a8668aa163c6dea0efde7ab7a19cbe6c15e6c66dc791361e5c15227472869e1b772e8436feec7f92a9a760b38aa0b4fb52a292273661b58e609f02a97188094deb9bc3471a39a518a4c9a575ea9d1c768bed57c3ddde4722f5f9a96cd072b6e7922bca806106ee90b3701d110fb11dbdc5dc5752bd7ec4a1cf28d5517ea2581c85f6c3bb2c1af9b62768778eaa51473402cbfeeeb9421417a73f0d853f80b71c64d4f46785af7d02f4d61cece41bc417bb3dee29206972ef2d37492c67010e8077a4bb6d4809baf8eec586c7eae530dc54eefa52a12247ce73c612a8490985a33e03aa0337b642905f1cb7aee97dd763cb9739ea1500fba8cc28a74022bd7be9dd6dc5eb45a811f644dfe9fa6ae5f02c2fd2e757947d9a5413d29050a4f9d91e93c788c07902d24744a4cb636e398cbfcf99ee1ecb6cb89a6110072310a40d56d855fbb720108660d8ca33cbfcb8875df810f2e4f017ae51bcf9fa6748b17c7a9ed8bb75d4e7f26dd5110197c9b11139c6a665242044aac751f3cf6a2670bdeb4529c474c34dfa620848b5aff70196268b43b822bfe1ee034baafdfc7c4569a10e8dd0a1f647c81f9b1ffffef10bbe72fe53ddf26bacece5fcb2e54fb447a347ad34e141c0a7fdcca737ce3c79a4ec5151279d0dfe1e030ecb0438135c1a6cbcc08290e0d013a8d0e63cabf13c1ba45dbb2ea31b1ee349bbdfe75a1860d1c2f7ccf907209e682c7369b33c4d9aa54f25d0dee5079596685ac2f23313100a75ea3088d571224097f21802cb0f1ed3f4366a9c1121c4f0f41296b42f88c2c4d5075f2ec4f0680022b4cf9d1651d8427e9d94a9772c942e2593f3a0f3b97281cdd563d5542f2749a518e54267f889d16d90c76e70a958ab2fe97410a350071753e56e1d40f2226c62df95c92c20b67870de90f6d47e692d8ea3b9ae14d12ab4533b3acd955d3f920586b3135936a89c3dc912441d516f871e7842f8fa8b676afbe9c0238ee77c8e639fa965abc15a97ec301aff0b2b37a9e2eff69939ed40835cf7a046b62f9fa6ee1d2f473f3659ec587c7995a8696c40453da96c1e9d691db18c73e62fcf9ebcf355536437f5fffbf4a4bdb55a751fddf2550aac57d13db3d218f304cbefbbd91ca2be01f5b3070e76d7a9851ec71825ea7ee2c117673580cef8f8ec6071a7603627e31892f16803d8a976f9a73d680326f6f94c8296bc6e11519e2ef97226c6934e2b88e2b8318d1d6d7a705b713b16191c7d1379b71025d626be6c47e9641f8c37d682eaa84212a55b07f7b4d6617d8d7009f0a21de30f2c87e5704900397d4a76dd2bc3d735c3b350ed700cdac7a4096b1f14bf229e2986bb8098897d59862a98047f23d5d9dc2e649186aa541d3a4ee4dd710dca40e901b538918e7277b1c913710dad6e454f246fa49487236235ec67c1fc870630fe47b888e346391611c9cfec10057d964ae35f110b7df4c009c90a247e234f6fa0d51f69d9f2ff7ea622856d82614f95d5e649e3326302cfca9c86fe14820a67874fa98f617dd5083d958a7ad041c732900e854577792780dba6a7c11c2e211fbe32bd553797fa07ad636824ec866bb3371a82b2b7847ae8a99a334b85cd251583ddc133159dd933ce167197d1299b9942c360113f2eda5cf26ea215d3236c4d06855923fdeb62d2a236d320e284c2de298e2c7817f1834f61229beda4588e4d460fb490f84d07bd4538e90701679c058f872c1afe97097c78da6d7d52171d141d90f9cae30c03e59c4dab913ba96943626a6c6a4b9a5a6a749075d9b2ec1481e675ae4d902dd58aa8fd02b05c6e5c1badee3a4fe3dada56b3846bad81fd5d7ef987ca02bf9d0acb01fcd3082a6bfd135cc18c6e32a2306ed0bcabcced7c4343a0e6b9f0d2276f9d7db968c247f94bde8d63d3d0c2357caee64c0411667725e9d78cb307458591f4126eccbfac73cb1c6613dcf7d214d5f201fd7929ecc0f2fe47a5295782350f6fc29a577a5c0ee46372adbbe36dd651694ca7595fc89bb24c62842170d0c5021b7e5b7a680de3ae37c3fd197eb99f2e0ab2632a2d323eba16b5e735a6cc2deca25d9febcc47066bbfeaed3a2fbf458a26718796b8d9d266964c3ed19ec7144f74a90bbc35868bcf7fc526f3b2901992c638eaab89d2f00869082dda4ab30a27fe2dcf54f2cab9a06f5ed6ab13fcf4311270c8d85062380a6ad5ce373c1be2794e82faf5234244672680b96bc06e714ae8d4faf76ebc39546377c6df9b0a003d8ce699872e9e037bf1e68949f5c8cbed14d1043e58084d317dd6aa7daeba7496478962106302ed89e718ec64b7e0164e33bac250131a985e42951afd58a6f7efd41d4375da3d26075558da5e4a9ab2f5c6d1da80cd5b61449f24545db381a69fe2d13ce0e8ccd6007d873a098fc340179fdbecb50619450ffdc7154fc50ab23369e3e8415c30c8a0a0ba19a580064019add808e1652e3403a175ff76aa31f6a76d93da25b8fec914573474b0108482ae533fa57907a2515dd7c9b6a9ee98a1e6fe6e8f7e220fcc89c24b46452a94467ab7755bba70aca7c84ec75d852374b1efb043700b5b5b56ef8ced4d786d2d86bf632709d847593b6e4f48f19e1cbfd6b42068c2e6dd288b9277ed030ccb47e2d147623e21a65be09c571b7431a177b43f2a5c0cec993bded0fe25ef92ad24854a5f5f6859a2c6dcb77495cc98c7d40caf7060fdb3d43e76801ad0e4060f0cc2f06a28018db27a7300f6629b9cd05444d08cd681aaadf0c0c8d87438a20cbb67377e0636ec871dae62167e6161361d85f065517c837730ec2f6a90a7183375c39521b65d8030b328eafb6bd0b7a85bdd6782564a7c98770e5b819e7c4e9907caf19c083c65fd01e22b95f18f91e70450057cf062296bbb16d90755cc4f03848b802971cd8b06c55d7906457afac6d72b790a4398e0ea71dd0b3f13b636c7078a50ae84b76385b66a3b77bd76bbb4ae86b590fb9c73efff57290ef6de205f50fadf2c53034722cbc593392fa51021c28a6beb6f3ae0ad35daf1cd4840cabc1598145fb96d8d574318bf63606ff43516fe66eedf45933beb43d59ade76917ac2fc98e1848bfe6216975154b3419593bec405787f372517b2a096cef53442f21cd97077dcf6e46a3a7b05c969ef6514c443eb5817302ef4a00c17929f21b2369d1601e508a2b22ba47acdd3038153225617c009ff535b8a0b7de5825fa9c5a29e73a2a6f223633626cc0d3b685a90bf0237c1ca27f29995d07f8c8588ff2f1f847812558f4b2331b3151f3d61c8c1748e96f80430349c0afed3ed579d07a3ce7948eeffbf327a4eec53c3e29b1eed5179fdedce5edab1f379a3c9873f26d056fae377584ef1e4d3ed8f2776e422831cb204c251ac8cd5e99f3e70f7b3547c81ba8bf6731b90059869a4faf561c07743b77b8b3ccdd9883ab407b18f9bfdeceadb71e41de0c6289b7abe1393470c54e48acc7fff00f4ffd90b882876c61ff3edba9b0b7197901a0d3a341b77e17e0f70377f0ce75f444b1fdcee9619f7e829f783a49640c1e206a757e45fe03e326f597bf4779fe850a49dc3b1858e557bc1c588190e847ab7630b0cf3ced12921921d4fda975f9adb2819f3444987a947bd70a0656fba4785a538ef06340f7a9bdb9d5e27f3932ee88e20583abf9b9ab249d0c3fea286daa4d1355b2fbc10a886e2fa4e7b5bfcb6b8e516284056d2f547c18be5b5f7d4afd4b85ac7a30653c1692a5a077134c1565baca34730e236d652cef51ab7a1751958844b6d9eff48cf51a3d16fc592d94b0188e74bf5aff2f90e5f6e0ceb73bd550644d4741b56f4b873c4f898719233a33182a76f6fce97ba8e50943c67353914d12f3452aa099ded4b6da6391be02347c0cc8d2da28e1275d4ae4e7f8b72a8c068b33b51dcd0766043ddf125f45c679de5101f17787</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日刷leetcode--简单版（五）</title>
      <link href="/leetcode5.html"/>
      <url>/leetcode5.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="https://inkdp.cn/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="119-杨辉三角-ii">119. 杨辉三角 II</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-991e2526.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>此题与118类似，直接冲118中返回最后一个数组即可，但是要优化到O(k)就显得不是那么容易了</li><li>公式:<img src="https://cdn.inkdp.cn/img/image-570d44cb.png" alt="image.png"></li><li>简单的来说就是前面的数乘以一个分数,这个分数从左到右分别为n/1, (n-1)/2, …, 2/(n-1), 1/n，比如第3行就是分别乘以3/1，2/2，1/3</li><li>这里要注意的是[1]是第0行，而非第一行</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRow</span><span class="params">(rowIndex <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">int</span>,rowIndex+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> rowIndex == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">1</span>; i &lt;= rowIndex; i++ &#123;</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] * (rowIndex-i+<span class="number">1</span>)/i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :2 MB, 在所有 Go 提交中击败了90.24%的用户</p></blockquote><h3 id="121-买卖股票的最佳时机">121. 买卖股票的最佳时机</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-4ef0e447.png" alt="image.png"></p><h4 id="解题思路1">解题思路1</h4><ul><li>双循环，对于每组 i 和 j（其中 j &gt; i）我们需要找出 max(prices[j] - prices[i])</li></ul><h5 id="示例代码-无">示例代码（无）</h5><h4 id="解题思路二">解题思路二</h4><ul><li>循环一次，分别记录最小买入与最大利润即可</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxPrices, min := <span class="number">0</span>, math.MaxUint32</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; min &#123;</span><br><span class="line">            min = prices[i] <span class="comment">// 最小买入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - min &gt; maxPrices &#123;</span><br><span class="line">            maxPrices = prices[i] - min  <span class="comment">// 最大利润</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxPrices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了98.17%的用户<br>内存消耗 :3.1 MB, 在所有 Go 提交中击败了80.77%的用户</p></blockquote><h3 id="122-买卖股票的最佳时机-ii">122. 买卖股票的最佳时机 II</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-936d9087.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>此题与121不同，121只需求出一段最高与最低即可，而此题需要求出多段</li><li>所谓利润，就是卖出比买入高，这就是利润，在此题中所映射出来的就是 <code>prices[i+1] &gt; prices[i]</code>，这里我们假设今日卖出后，可在今日购买，这样一有利润我们就记录，这样就可以求出最高利润</li><li>举个栗子，比如数组是[1,2,5]，那么第一次判断发现 <code>2&gt;1</code>，所以我们立即卖出得到利润 <code>2-1=1</code>，第二天判断 <code>5&gt;2</code>，得到利润 <code>5-2=3</code>，所以总利润为 <code>1+3=4</code>;再举一个栗子[1,2,5,4,7]，这里我们可以得到 <code>2&gt;1,5&gt;2,7&gt;4</code>,分别相减后相加得到总利润为 <code>7</code></li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit1</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; prices[i+<span class="number">1</span>] &#123;</span><br><span class="line">            max += prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :3.1 MB, 在所有 Go 提交中击败了66.38%的用户</p></blockquote><h3 id="125-验证回文串">125. 验证回文串</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-e7e16206.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>一次循环，分别指定头指针与为指针，遇到非字母与数字则跳过</li><li>可在判断是否相同时进行大小写转换，也可在一开始就统一大小写</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; &#123;</span><br><span class="line">        <span class="keyword">for</span> (s[i] &lt; <span class="number">48</span> ||  (s[i] &gt; <span class="number">57</span> &amp;&amp; s[i]&lt; <span class="number">65</span>)  || (s[i] &lt; <span class="number">97</span> &amp;&amp; s[i] &gt; <span class="number">90</span>) || s[i] &gt; <span class="number">122</span>) &amp;&amp; i&lt;j &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (s[j] &lt; <span class="number">48</span> ||  (s[j] &gt; <span class="number">57</span> &amp;&amp; s[j]&lt; <span class="number">65</span>)  || (s[j] &lt; <span class="number">97</span> &amp;&amp; s[j] &gt; <span class="number">90</span>) || s[j] &gt; <span class="number">122</span>)  &amp;&amp; i&lt;j &#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ToUpper(s[i]) != ToUpper(s[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(ascii <span class="keyword">uint8</span>)</span> <span class="title">uint8</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ascii &gt;<span class="number">96</span> &amp;&amp; ascii &lt;= <span class="number">122</span> &#123;</span><br><span class="line">        ascii-=<span class="number">32</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ascii</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :2.7 MB, 在所有 Go 提交中击败了93.51%的用户</p></blockquote><h3 id="136-只出现一次的数字">136. 只出现一次的数字</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-ddc62dfc.png" alt="image.png"></p><h4 id="解题思路1">解题思路1</h4><ul><li>哈希表遍历，取出只出现一次的即可</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        list[nums[i]] ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">1</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> k</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :12 ms, 在所有 Go 提交中击败了93.55%的用户<br>内存消耗 :5.9 MB, 在所有 Go 提交中击败了14.34%的用户</p></blockquote><h4 id="解题思路2">解题思路2</h4><ul><li>^作二元运算符就是异或，相同为0，不相同为1</li><li>解释一下异或，<code>1^1=0</code>,<code>0^2=2</code></li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v :=<span class="keyword">range</span> nums &#123;</span><br><span class="line">        a ^= v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :4.8 MB, 在所有 Go 提交中击败了90.31%的用户</p></blockquote><h3 id="141-环形链表">141. 环形链表</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-2fe4d07f.png" alt="image.png"></p><h4 id="生成环链表">生成环链表</h4><p>根据<a href="https://www.jinjianh.com/articles/2019/09/26/1569488898577.html">GO实现一个单链表</a>，添加如下代码即可实现环列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(head *ListNode)</span> <span class="title">CreateCycle</span><span class="params">(pos <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p := head</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> head.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i == pos &#123;</span><br><span class="line">            p = head</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    head.Next = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解题思路-哈希">解题思路–哈希</h4><ul><li>题目本身并不难，但是把这个题目看懂颇费心思</li><li>如示例1所示，遍历其生成的链表为 <code>3 -&gt; 2 -&gt; 0 -&gt; -4 -&gt; 2 -&gt; 0 -&gt; ....</code></li><li>遍历单链表，如果当前节点为尾结点，这表示此链表不是环列表。如果当前节点存在哈希表中，这返回true,不存在则添加至哈希表中</li><li>时间复杂度O(n)，空间复杂度O(n)</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    nodes := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := nodes[head]; ok&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            nodes[head] = head.Val</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :8 ms, 在所有 Go 提交中击败了93.39%的用户<br>内存消耗 :6.1 MB, 在所有 Go 提交中击败了5.40%的用户</p></blockquote><h4 id="解题思路-双指针">解题思路–双指针</h4><ul><li>快慢指针同时遍历，当快指针指向链表尾部表示为非环链表</li><li>当快指针追上慢指针则表示当前为环链表</li><li>如同两个运动员赛跑，跑的快的运动员超过慢的运动员一圈的时候就可以判断他们跑的是环形跑道，如果跑的快的直接冲线了，那么他就不是环形跑道。</li><li>时间复杂度O(n)，空间复杂度O(n)</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow := head</span><br><span class="line">    fast := head.Next</span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :8 ms, 在所有 Go 提交中击败了93.39%的用户<br>内存消耗 :3.8 MB, 在所有 Go 提交中击败了91.11%的用户</p></blockquote><h3 id="160-相交联表">160. 相交联表</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-4c11d1e2.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-9370deab.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-9faf6e7e.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>思路有三种，暴力，哈希，和双指针，暴力和哈希比较简单，我采用了双指针的方式</li><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li>因为指针A是先跑完headA然后跑headB，指针B与之相反，所以他们最后一段路一定是携手共进，这时判断他们是否相等就可以了</li><li>图解如下<br><img src="https://cdn.inkdp.cn/img/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" alt="相交链表.png"></li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func getIntersectionNode(headA, headB *ListNode) *ListNode &#123;</span><br><span class="line">if headA &#x3D;&#x3D; nil || headB &#x3D;&#x3D; nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">Pa, Pb :&#x3D; headA,headB</span><br><span class="line">for Pa !&#x3D; Pb &#123;</span><br><span class="line">if Pa &#x3D;&#x3D; nil &#123;</span><br><span class="line">Pa &#x3D; headB</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">if Pb &#x3D;&#x3D; nil &#123;</span><br><span class="line">Pb &#x3D; headA</span><br><span class="line">&#125;</span><br><span class="line">Pa &#x3D; Pa.Next</span><br><span class="line">Pb &#x3D; Pb.Next</span><br><span class="line">&#125;</span><br><span class="line">return Pa</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :44 ms, 在所有 Golang 提交中击败了99.33%的用户<br>内存消耗 :7.9 MB, 在所有 Golang 提交中击败了5.53%的用户</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日刷leetcode--简单版（四）</title>
      <link href="/leetcode4.html"/>
      <url>/leetcode4.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="https://inkdp.cn/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="88-合并两个有序数组">88. 合并两个有序数组</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-85be80cb.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>采用双指针，从前往后，如果nums2中当前值小于nums1中的值，这插入并后移</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums1</span><br><span class="line">&#125;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(nums1) &amp;&amp; j &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i] &gt; nums2[j] &#123;</span><br><span class="line">reverses(nums1[i:])</span><br><span class="line">nums1[i] = nums2[j]</span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j &lt; n &#123;</span><br><span class="line">nums1[m+j] = nums2[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverses</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">nums[i] = nums[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了73.14%的用户<br>内存消耗 :3.6 MB, 在所有 Go 提交中击败了84.42%的用户</p></blockquote><h3 id="100-相同的树">100. 相同的树</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-00f58922.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>有两中情况下可直接返回<ol><li>p与q同时为空时为<code>True</code></li><li>p或q只有一个为空时<code>False</code></li></ol></li><li>p与q同时不为空是，判断其Val，同时递归判断两个的Left与Right</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.Val != q.Val &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :2.1 MB, 在所有 Go 提交中击败了87.07%的用户</p></blockquote><h3 id="101-对称二叉树">101. 对称二叉树</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-3af0001a.png" alt="image.png"></p><h4 id="解题思路-递归">解题思路–递归</h4><ul><li>这道题与上一题很像，上一题是要求树完全相等，此题是要求对称</li><li>两树相等时为<code>Left == Left</code>,<code>Right == Right</code>，而对称则是<code>Left == Right</code>，<code>Right == Left</code></li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isLeftRight(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isLeftRight</span><span class="params">(L *TreeNode, R *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> L == <span class="literal">nil</span> &amp;&amp; R == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> L == <span class="literal">nil</span> || R == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> L.Val != R.Val&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isLeftRight(L.Left, R.Right) &amp;&amp; isLeftRight(L.Right, R.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :3 MB, 在所有 Go 提交中击败了60.14%的用户</p></blockquote><h4 id="解题思路-迭代">解题思路–迭代</h4><ul><li>迭代我也不是很懂，就摘抄了一个，配合注释看一看</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123; <span class="comment">// 迭代方法，bfs</span></span><br><span class="line">L := []*TreeNode&#123;&#125;       <span class="comment">// 从左向右遍历顺序的队列</span></span><br><span class="line">R := []*TreeNode&#123;&#125;       <span class="comment">// 从右向左遍历顺序的队列</span></span><br><span class="line">L = <span class="built_in">append</span>(L, root)     <span class="comment">// 加入初始节点</span></span><br><span class="line">R = <span class="built_in">append</span>(R, root)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(L)!=<span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(R)!=<span class="number">0</span> &#123;   <span class="comment">// bfs</span></span><br><span class="line">Lv,rv := L[<span class="number">0</span>], R[<span class="number">0</span>]    <span class="comment">// 不同遍历顺序的队列，队首出队</span></span><br><span class="line">L, R = L[<span class="number">1</span>:], R[<span class="number">1</span>:]      <span class="comment">// 删除队首元素</span></span><br><span class="line"><span class="keyword">if</span> Lv==<span class="literal">nil</span> &amp;&amp; rv==<span class="literal">nil</span> &#123;  <span class="comment">// 空节点，不添加节点</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> Lv!=<span class="literal">nil</span> &amp;&amp; rv!=<span class="literal">nil</span> &amp;&amp; Lv.Val == rv.Val &#123;    <span class="comment">// 比较两种遍历顺序的出队节点，如果相同，继续搜索</span></span><br><span class="line">L = <span class="built_in">append</span>(L, Lv.Left, Lv.Right)</span><br><span class="line">R = <span class="built_in">append</span>(R, rv.Right, rv.Left)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 如果不同，证明不是镜像二叉树</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(L)==<span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(R)==<span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :3.2 MB, 在所有 Go 提交中击败了5.80%的用户</p></blockquote><h3 id="104-二叉树的最大深度">104. 二叉树的最大深度</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-59a22901.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>使用递归查看当前值是否为空，为空则返回0，接受到递归返回的0就加1</li><li>毕竟树的左右，看那边更大，返回大的一边。</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Ll := maxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">    Lr := maxDepth(root.Right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> Ll &gt; Lr &#123;</span><br><span class="line">        <span class="keyword">return</span> Ll</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Lr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :8 ms, 在所有 Go 提交中击败了79.37%的用户<br>内存消耗 :4.4 MB, 在所有 Go 提交中击败了61.74%的用户</p></blockquote><h3 id="107-二叉树的层次遍历-ii">107. 二叉树的层次遍历 II</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-28e94e96.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>看下面代码注释</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> <span class="params">(res [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node []*TreeNode</span><br><span class="line">    node = <span class="built_in">append</span>(node, root)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(node) &gt; <span class="number">0</span> &#123; <span class="comment">// node不为0就一直循环</span></span><br><span class="line">        <span class="built_in">len</span> := <span class="built_in">len</span>(node)</span><br><span class="line">        <span class="keyword">var</span> tmp []<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">    <span class="comment">// 循环次数等于每一层的节点数，每次都取第一个node，因为下面会将第一个node删除</span></span><br><span class="line">            indexNode := node[<span class="number">0</span>]</span><br><span class="line">            node = node[<span class="number">1</span>:]  <span class="comment">// 将第一个node删除</span></span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, indexNode.Val) <span class="comment">// 记录节点值</span></span><br><span class="line">            <span class="keyword">if</span> indexNode.Left != <span class="literal">nil</span> &#123; <span class="comment">// 如果左子树不为空，将左子树添加node</span></span><br><span class="line">                node = <span class="built_in">append</span>(node, indexNode.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> indexNode.Right != <span class="literal">nil</span> &#123; <span class="comment">// 如果右边树不为空，将右子树添加node</span></span><br><span class="line">                node = <span class="built_in">append</span>(node, indexNode.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res1 [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="built_in">len</span>(res)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        res1 = <span class="built_in">append</span>(res1, res[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了85.64%的用户<br>内存消耗 :6 MB, 在所有 Go 提交中击败了87.36%的用户</p></blockquote><p><strong>对树不是很了解，树相关题目后面再做</strong></p><h3 id="118-杨辉三角">118. 杨辉三角</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-84d3bce3.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li><img src="https://cdn.inkdp.cn/img/PascalTriangleAnimated2-9958c3e5.gif" alt="PascalTriangleAnimated2.gif"></li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(numRows <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr [][]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> numRows == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr = <span class="built_in">append</span>(arr, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> numRows == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; numRows; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> row []<span class="keyword">int</span></span><br><span class="line">row = <span class="built_in">append</span>(row, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">tmp := arr[i<span class="number">-1</span>][j<span class="number">-1</span>] + arr[i<span class="number">-1</span>][j]</span><br><span class="line">fmt.Println(tmp)</span><br><span class="line">row = <span class="built_in">append</span>(row, tmp)</span><br><span class="line">&#125;</span><br><span class="line">row = <span class="built_in">append</span>(row, <span class="number">1</span>)</span><br><span class="line">arr = <span class="built_in">append</span>(arr, row)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户<br>内存消耗 :2.3 MB, 在所有 Go 提交中击败了47.54%的用户</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我的前半生》阅读笔记</title>
      <link href="/articles/2019/08/31/1567227232395.html"/>
      <url>/articles/2019/08/31/1567227232395.html</url>
      
        <content type="html"><![CDATA[<p>可能受篇幅影响，这是用Kindle看书以来，看的最快的一本，大概也就一两天的时间。篇幅虽小，但却丝毫不影响该书的质量。</p><p>老实说，文章的开头给我的感觉并不是特别好，似乎一部言情小说的样子，“女主上来就被抛弃，然后成为职业女强人，遇到白马王子”这类书太多太多了，看完后发现写的还真就是这么回事。看完后我不由得佩服起作者来，与都市言情几乎同样的剧情路线在作者手中展示出了不一样的魅力。虽说是与都市言情一样的线路，但是剧情还是大有不同，有幸读过一两篇相关题材的书，名字早已忘记，但依稀记得书中女主都是青春靓丽的，年龄不过24左右，在嫁人之前就是商业精英之类的，被抛弃后直接走上人生巅峰的那种。讲道理，这种书YY起来是真的爽，这也就是都市爽文的卖点之一了。</p><p>似乎略有偏题，讲回本书，感觉该书很适合女性去看一看，不论你是否是书中女主前半生那样的人，都适合去看一看。初被抛弃时，女主是无助的，绝望的，即将一无所有是多么绝望，所幸，女主是坚强的，那句“人要脸，树要皮。一个女人失去她的丈夫，已经是一最大的难堪与狼狈，我不能再出洋相”让我感受到女主身体最深处的倔强。离开丈夫的女主没有让人失望，从天真阔太转变为一位成功的职业女性，气质的申华，远比外在好很多，甚至前夫都觉得她年轻漂亮了许多。“人际关系这一门科学永远没有学成毕业的一日，每天都似投身于砂石中，缓缓磨动，皮破血流之余所积得的宝贵经验便是一般人口中的圆滑”，慢慢学会如何处理人际关系后与其妹妹关系也转好。或许女主本就不是愚笨的，如书中所说“我跟你讲过，做太太也不好做，你总不相信，我们在老板面前，何尝不是随他搓圆搓扁，丈夫要我笨，我只好笨”。“# 这世界像一个大马戏团子，班主名叫‘生活&quot;，拿着皮鞭站在咱们背后使劲地抽打，逼咱们跳火圈、上刀山，你敢不去吗？皮鞭子响了，狠着劲咬紧牙关，也就上了”描绘出生活的不易。</p><p>文章的最后，女主再一次找到了真爱，在飞机上结束了自己的前半生。</p><p>后记，无意中发现还有电视剧，演员阵容大多都是我喜欢的，但是看了些剧情简介，似乎与此书大相径庭啊，瞬间就失去了兴趣。</p><p>文笔太差，想到什么就写什么，文章反倒显得杂乱无章。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《诸神的传说：希腊神话故事》读中笔记</title>
      <link href="/articles/2019/08/29/1567093295295.html"/>
      <url>/articles/2019/08/29/1567093295295.html</url>
      
        <content type="html"><![CDATA[<p>一开始开始看这本书是打算了解一下希腊神话中的神是什么样的，虽然之前也通过一些视频文字等了解过一些，指导诸如宙斯、雅典娜、阿波罗、波塞冬等，但是没有系统的去了解过，抱着好奇的态度翻开了这本书。<br>  <br>  这本书目前翻了几页，现在大概看了10%左右，不打算看下去了。可能由于文化差异的问题，我理解不了希腊神话中某些神的做法。该书号称将希腊神话进行收罗，整理后得出的版本，是很经典的书籍。可是给我的感觉是整个书杂乱无章（不排除存在翻译的原因），还没之前读的儿童读物讲的清楚，再就是篇幅过小，我还来不及记住该文主角是谁，这一章就讲完了。</p><p>虽然槽点很多，但是我还是挺喜欢希腊神话中的一些很经典的故事，比如奥德赛、木马计、塞壬的歌声等，可能该书的开头不是特别好，也可能是我带着主观意识去阅读导致的。但是目前不打算看了，毕竟时间有限，以后再看的话会更新该文章。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《天才在左，疯子在右》章节摘录</title>
      <link href="/articles/2019/08/23/1566551996115.html"/>
      <url>/articles/2019/08/23/1566551996115.html</url>
      
        <content type="html"><![CDATA[<h1 id="女人的星球">女人的星球</h1><p>我推门进来的时候，吓了他一大跳，还没等我看清，他人就躲到桌子底下去了，说实话我也被吓了一跳。</p><p>关上门后我把资料本子、录音笔放在桌上，并没直接坐下，而是蹲下看着他。我怕他在桌子底下咬我——有过先例。</p><p>他被吓坏了，缩在桌子下拼命哆嗦着，惊恐不安地四下看。</p><p>我：“出来吧，门我锁好了，没有女人。”</p><p>他只是摇头不说话。</p><p>我：“真的没有，我确定，你可以出来看一下，就看一眼，好吗？”</p><p>跟这个患者接触大约2个月了。他有焦虑+严重的恐惧症，还失眠，而恐惧的对象是女人。</p><p>他小心地探头看了下四周，谨慎地后退爬了出去，然后蹲坐在椅子上，紧紧地抱着自己双膝，惊魂未定地看着我。</p><p>我：“你看，没有女人吧。”</p><p>他：“你真的是男的？你脱了裤子我看看？”</p><p>我：“……我是男的，这点我可以确认。你忘了我了？”</p><p>他：“你还有什么证据？”</p><p>我：“我今天特地没刮脸，你可以看到啊，这个胡子是真的，不是粘上去的。你见过女人长胡子吗？就算汗毛重也不会重成我这样吧？”</p><p>他狐疑地盯着我的脸看了好一阵。</p><p>他：“上次她们派了个大胡子女人来骗我。”</p><p>我：“没有的，上次那个大胡子是你的主治医师，他可是地道的男人。”</p><p>他努力在想着。我观察着他，琢磨今天到底有没有交流的可能。</p><p>他：“嗯，好像是，你们俩都是男的……但是第一次那个不是。”</p><p>我：“对，那是女人，你没错。”</p><p>他：“现在她们化妆得越来越像了。”</p><p>我：“哪儿有那么多化妆成男人的啊。这些日子觉得好点没？”</p><p>他：“嗯，安全多了。”</p><p>我：“最近吃药顺利吗？”他曾经拒绝吃药，说那是女人给他的毒药，或者安眠药，等他睡了她们好害他。”</p><p>他：“嗯，就是吃了比较困，不过没别的事。”</p><p>我：“就是嘛，没事的，这里很安全。”</p><p>他：“你整天在外面小心点儿，小心那些女人憋着对你下手！”</p><p>我想了下，没觉得自己有什么值得女人那么鸡飞狗跳寻死觅活惦记的，于是问他为什么。</p><p>他：“她们早晚会征服这个地球的！”</p><p>我：“地球是不可能被征服的。”</p><p>他：“哦，她们会统治世界的。”</p><p>我：“为什么？”</p><p>他又疑神疑鬼地看着我，我也在好奇地看着他，因为从没听他说过这些。</p><p>他：“你居然没发现？”</p><p>我：“你发现了？”</p><p>他严肃地点了点头。</p><p>我：“你怎么发现的？”</p><p>他：“女人，跟我们不是一种动物。”</p><p>我：“那她们是什么？”</p><p>他：“我不知道，很可能是外星来的，因为她们进化得比我们完善。”</p><p>他好像镇定了一些。</p><p>我：“我想听听，有能证明的吗？”</p><p>他神秘地压低声音：“你知道DNA吗？”</p><p>我：“脱氧核糖核酸？知道啊！你想说什么？染色体的问题？”</p><p>他：“她们的秘密就在这里！”</p><p>我：“呃……什么秘密？染色体秘密？”</p><p>他：“没错！”</p><p>我：“到底是怎么回事？”</p><p>他：“人的DNA有23对染色体对不对？”</p><p>我：“对，46条。”</p><p>他依旧狐疑地看着我：“你知道多少？”</p><p>我：“男女前44条染色体都是遗传信息什么的，最后那一对染色体是性染色体，男的是X/Y，女人是X/X。这个怎么了？”</p><p>他严肃地看着我：“你们都太笨！这么简单的事都看不明白！”</p><p>我：“呃……我知道这个，但是不知道怎么有问题了……”</p><p>他：“男女差别不仅仅是这么简单的！男人的X/Y当中，X包含了两三千个基因，是活动频繁的，Y才包含了几十个基因，活动很小！明白了？”</p><p>我：“呃……不明白……这个不是秘密吧？你从哪儿知道的？”</p><p>他一脸恨铁不成钢的表情：“我原来去听过好多这种讲座。你们真是笨得没话说了，难怪女人要灭绝咱们！”</p><p>我实在想不出这里面有什么玄机。</p><p>他叹了口气：“女人最后两个染色体是不是X/X？”</p><p>我：“对啊，我刚才说了啊……”</p><p>他：“女人的那两个X都包含好几千个基因！而且都是活动频繁的，Y对X，几十对好几千！就凭这些，差别大了！女人比男人多了那么多信息基因！就是说女人进化得比男人高级多了！”</p><p>我：“但是大体的都一样啊？就那么一点儿……”</p><p>他有点儿愤怒：“你这个科盲！人和猩猩的基因相似度在99%以上，就是那不到1%导致了一个是人，一个是猩猩。男人比女人少那么点？还少啊！”</p><p>看着他冷笑我一时也没想好说什么。</p><p>他：“对女人来说，男人就像猩猩一样幼稚可笑。小看那一点儿基因信息？太愚昧！低等动物是永远不能了解高等动物的！女人是外星人，远远超过男人的外星人！”</p><p>我：“有那么夸张吗？”</p><p>他不屑地看着我：“你懂女人吗？”</p><p>我：“呃……不算懂……”</p><p>他：“但是女人懂你！她们天生就优秀得多，基因就比男人丰富。就是那些活动基因导致了完全不一样的结果！男人谁敢说了解女人？谁说谁就是胡说八道。我问你，从基因上看，是你高级还是宠物高级？”</p><p>我：“呃……我……”</p><p>我：“就是这样。你养的宠物怎么可能了解你？你吃饭它明白，你睡觉它明白，你看电影它就不见得明白了吧？你上网它就不理解了吧？你跟别人聊天它还是不明白吧？你看书它明白？不明白吧。你看球赛高兴了或者不高兴了它明白？它也不明白！它只能看到你的表面现象：你高兴了或者生气了。但是为什么，它永远不明白。”</p><p>我：“嗯……你别激动，坐下慢慢说。”</p><p>他：“你能看到女人喜欢这件衣服，为什么？因为好看。哪儿好看了？你明白吗？”</p><p>我：“嗯，有时候是这样……”</p><p>他：“女人生气了，你能看到她生气了，你知道为什么吗？你不知道……”</p><p>我：“经常是一些小事儿吧……”</p><p>他再度冷笑：“小事儿？你不懂她们的。你养的宠物打碎了你喜欢的杯子，你会生气，在宠物看来这没什么啊，有什么可气的？对不对？对不对！”</p><p>看着他站在椅子上我有点儿不安。</p><p>我：“你说的没错，先坐下来好不好？小心站那么高女人发现你了。”</p><p>他果然快速地坐了下来。</p><p>他：“没男人能了解女人的，女人的心思比男人多多了，女人早晚会统治这个世界，到时候男人可能会被留下一些种男，剩下的都杀掉。等科学更发达了，种男都不需要了，直接造出精子。可悲的男人啊，现在还以为在主导世界，其实快灭亡了，这个星球早晚是女人的……”</p><p>我：“可怜的男人……感情呢？不需要吗？”</p><p>他：“感情？那是为了繁衍的附加品。”</p><p>我：“我觉得你悲观了点儿……就算是真的，对你也没威胁的。”</p><p>他：“我悲观？我不站出来说明，我不站出来警告，你们会灭亡得更早！可惜我这样的人太少了。”</p><p>我：“是啊……我知道的只有你。”</p><p>他：“弗洛伊德，你知道吗？他也是和我一样，很早就发现了。”</p><p>我：“哎？不是吧？”</p><p>他：“弗洛伊德的临终遗言已经警告男人了。”</p><p>我：“他还说过这个？怎么警告的？”</p><p>他：“他死前警告所有男人，女人想要全世界！”</p><p>我已经起身在收拾东西了：“嗯，我大体上了解怎么回事了，过段时间我还会来看你的。”</p><p>他：“你不能声张，悄悄地传递消息，否则你也会很危险的。”</p><p>我：“好的，我记住了。”</p><p>我轻轻地关上了门。</p><p>几天后我问一个对遗传学了解比较多的朋友，有这种事儿吗？他说除了来自外星、干掉男人、征服世界那部分，基本属实。</p><p>不过，我们都觉得弗洛伊德那句临终遗言很有意思，虽然那只是个传闻。</p><p>“女人啊，你究竟想要什么？”</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《天才在左，疯子在右》阅读笔记</title>
      <link href="/articles/2019/08/23/1566551837849.html"/>
      <url>/articles/2019/08/23/1566551837849.html</url>
      
        <content type="html"><![CDATA[<p>断断续续于今日上班的路上将这本书看完，虽然因为盗版书的原因有大概十章没有看，但也总算是看完了。</p><p>作者以一个特殊的角度让我了解到了精神病人是什么样子的，书中描写的案例有各式各样的人，他们都有着各式各样的问题。老实说，看完之后对于精神病医生这个职业油然起敬，治疗好一个病人得需要多大的耐心和多缜密的思维逻辑，感觉这也是一个高危职业，书中有提到有不少医生变成了病人，甚至有些人选择了自杀。</p><p>曾听说过“精神病与天才只有一墙之隔”，书中有很多不知道是天才还是精神病的人，他们大多逻辑缜密，而且在某些相关知识的理解也很到位，但是我无法判断他到底是不是疯了，就如同文中某位病人所说的那样，你回到唐朝去对当时的人讲现在的种种，他们也会觉得你疯了。当然书中也有很多是真的疯了，让我最诡异的就是那位认为自己已经死亡的病人，我无法想象出最后身体长出金属(依稀记得是铝丝)，这个似乎超出了我的认知。</p><p>读完这本书感觉最大的收获莫过于书中提到最多的物理知识，算是对自己的一个科普，也同时进一步的了解了精神病人的世界是怎么样的。</p><p>推荐我最喜欢的一个章节：<a href="https://inkdp.cn/articles/2019/08/23/1566551996115.html">女人的星球</a>，没有别的意思，只是单纯的喜欢这章</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新皮肤 solo-nexmoe</title>
      <link href="/articles/2019/08/23/1566468138289.html"/>
      <url>/articles/2019/08/23/1566468138289.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>solo-nexmoe是移植Hexo的主题<a href="https://github.com/nexmoe/hexo-theme-nexmoe">Nexmoe</a>而得到的，皮肤效果基本与原作者一致</p><h2 id="项目地址">项目地址</h2><p><a href="https://github.com/Programming-With-Love/solo-nexmoe">https://github.com/Programming-With-Love/solo-nexmoe</a></p><h2 id="效果展示">效果展示</h2><p><img src="https://cdn.inkdp.cn/img/image-0f32e4c2.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-9386c650.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-4ff20186.png" alt="image.png"></p><h2 id="演示">演示</h2><ul><li><a href="https://www.inksp.cn/?skin=solo-nexmoe">墨殇的技术小站</a></li><li><a href="https://sszsj.cc:444/?skin=solo-nexmoe">鼠鼠在碎觉</a></li><li><a href="https://witheloov.com/?skin=solo-nexmoe">记录精彩的人生</a></li><li><a href="https://www.cjzshilong.cn/?skin=solo-nexmoe">邯城往事</a></li><li><a href="https://www.stackoverflow.wiki/blog/?skin=solo-nexmoe">贼拉正经的技术博客</a></li><li>…</li></ul><p>欢迎将你的博客加入这里</p><h2 id="说明">说明</h2><ul><li>本皮肤依赖于<a href="https://github.com/b3log/solo">b3log/solo</a>，安装solo可查看<a href="https://www.inkdp.cn/articles/2019/08/06/1565021931775.html">从零开始安装 Solo 博客</a></li><li>导航栏自定义图标为字体图标，可以前往<a href="https://www.inkdp.cn/articles/2019/08/23/1566548785550.html">solo-nexmoe 图标详解</a>查看图标对应名称，直接填入名称即可，目前包内所有图标都被应用了，填写是请删除前缀 <code>solo-</code>后填写</li><li>接上条，由于solo会自动拉取你的github项目，《我的开源》对应的图标会被覆盖，所以请升级到最新版本，关闭自动拉取设置，然后讲图标设置为 <code>github</code>即可</li><li>需要自定义新图标直接修改 <code>font-icon.scss</code>与 <code>font-icon.css</code>，如果你没有node环境，直接修改 <code>css</code>也是可以的，最后在导航管理处设置即可，你也可以提issue，我会定期收集一些图标更新</li><li>现用图标可前往github上查看或者<a href="https://img.hacpai.com/file/2019/08/download-9acf6646.zip">点击下载</a></li><li>侧边栏中的标签可替换为公告栏，操作方法 <code>后台管理</code>=&gt;<code>设置</code>=&gt;<code>偏好设置</code>=&gt;<code>参数设置</code>=&gt;<code>自定义模板变量</code>，更改 <code>key0=0</code>为 <code>key0=bulletin</code>即可，PS:(由于侧边栏很窄，所以公告栏外链网易云的，需要考虑一下页面美观度的问题)</li><li>友情链接提供两种显示方式，默认为原始版本的，操作方法如上，更改 <code>key1=0</code>为 <code>key1=list</code>即可(由于友链不能自定义图片，所以现在还很丑，等待D哥完成<a href="https://github.com/b3log/solo/issues/12861">友情链接添加图片属性</a>后，这个会很好看)</li></ul><h2 id="小功能">小功能</h2><ul><li>快捷键 <code>T</code>可直接返回顶部</li><li>自定义背景：默认使用canvas作为背景，在后台管理 → 偏好设定 → 参数设置 → 自定义模板变量中新加参数 <code>bg=*</code>,<code>*</code>对应0-9的数字，数字为透明度，<code>bg=1</code>对应 <code>opacity: .1</code>。设置好后背景图片为<a href="https://cdn.inkdp.cn/img/57873300p0-3496bc81.jpg">默认图片</a>。如需更改默认图片可新增参数 <code>bgUrl=图片地址</code>，示例 <code>bgUrl=https://static-solo.b3log.org/skins/Bubble/images/header-bg.jpg</code></li><li>后续添加中…</li></ul><h2 id="鸣谢">鸣谢</h2><ul><li>感谢皮肤原作者<a href="https://docs.nexmoe.com/">折影轻梦</a></li></ul><h2 id="论坛">论坛</h2><p>欢迎加入我们的小众开源社区，详情请看<a href="https://hacpai.com">这里</a></p><h2 id="最后">最后</h2><p>欢迎大家提issue，pr，以及点star</p><h2 id="更新通知">更新通知</h2><p>希望使用本皮肤的各位能够关注本帖，皮肤有BUG修复或者功能更新后会在本帖说明，重要的事说三遍<br>希望使用本皮肤的各位能够关注本帖，皮肤有BUG修复或者功能更新后会在本帖说明，重要的事说三遍<br>希望使用本皮肤的各位能够关注本帖，皮肤有BUG修复或者功能更新后会在本帖说明，重要的事说三遍</p><ul><li>2019-09-05：调换 <code>mater</code>分支与 <code>temporary</code>内容，目前连分支唯一差别就是友情链接页面</li><li>2019-09-09：修复头图误删元素问题，完成<a href="https://github.com/gooohlan/solo-nexmoe/issues/6">左侧可以添加公告栏</a>，将 <code>master</code>与 <code>tempoary</code>，详细操作查看说明。</li><li>2019-09-10：添加置顶标识，更换返回顶部图标</li><li>2019-09-10：修复<a href="https://github.com/gooohlan/solo-nexmoe/issues/8">文章第一次评论时，无法直接更新只评论列表</a></li><li>2019-09-10：修复最新版solo出现代码不高亮问题，没有出现代码不高亮可以不更新</li><li>2019-09-12：侧边栏分类文章数量正确显示</li><li>2019-09-19：修复solo3.6.5出现的无法从首页登录后台问题</li><li>2019-09-25：修复表格无法换行问题</li><li>2019-09-26：添加用户自定义背景功能</li><li>2019-10-24：修复文章中:huaji:等表情过大问题，D 哥完成了<a href="https://hacpai.com/forward?goto=https%3A%2F%2Fgithub.com%2Fb3log%2Fsolo%2Fissues%2F12861">友情链接添加图片属性</a>，所以友链可以以列表的方式显示，不过你先得在友链中添加图片属性，效果如下：<a href="https://www.inkdp.cn/links.html">友情链接-墨殇的技术小站</a></li><li>2019-12-26日：修复社区防盗链引发的皮肤图片403问题：<a href="https://hacpai.com/article/1577238746196%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%B7%A6%E4%BE%A7%E5%A4%B4%E5%83%8F%E4%B8%BA%E8%87%AA%E5%B7%B1%E8%AE%BE%E7%BD%AE%E7%9A%84">https://hacpai.com/article/1577238746196，更新左侧头像为自己设置的</a><strong>Favicon</strong>，而非社区头像</li><li>2020-03-27日：修复所有已知BUG，抱歉拖了这么久，给各位带来的不便深表歉意</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solo </tag>
            
            <tag> 皮肤 </tag>
            
            <tag> Nexmoe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solo-nexmoe 图标详解</title>
      <link href="/articles/2019/08/23/1566548785550.html"/>
      <url>/articles/2019/08/23/1566548785550.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本帖记录官方solo-nexmoe内所对应字体图标值</p><ul><li><p><code>solo-home</code> <i class="iconfont solo-home"></i></p></li><li><p><code>solo-list</code> <i class="iconfont solo-list"></i></p></li><li><p><code>solo-tags</code> <i class="iconfont solo-tags"></i></p></li><li><p><code>solo-tag</code> <i class="iconfont solo-tag"></i></p></li><li><p><code>solo-github</code> <i class="iconfont solo-github"></i></p></li><li><p><code>solo-about</code> <i class=" iconfont solo-about"></i></p></li><li><p><code>solo-search</code> <i class=" iconfont solo-search"></i></p></li><li><p><code>solo-rss</code> <i class=" iconfont solo-rss"></i></p></li><li><p><code>solo-calendarl</code> <i class=" iconfont solo-calendarl"></i></p></li><li><p><code>solo-category</code> <i class=" iconfont solo-category"></i></p></li><li><p><code>solo-left</code> <i class=" iconfont solo-left"></i></p></li><li><p><code>solo-right</code> <i class=" iconfont solo-right"></i></p></li><li><p><code>solo-browse</code> <i class=" iconfont solo-browse"></i></p></li><li><p><code>solo-heat</code> <i class=" iconfont solo-heat"></i></p></li><li><p><code>solo-about2</code> <i class=" iconfont solo-about2"></i></p></li><li><p><code>solo-top</code> <i class=" iconfont solo-top"></i></p></li><li><p><code>solo-login</code> <i class=" iconfont solo-login"></i></p></li><li><p><code>solo-logout</code> <i class=" iconfont solo-logout"></i></p></li><li><p><code>solo-spin</code> <i class=" iconfont solo-spin"></i></p></li><li><p><code>solo-comment</code> <i class=" iconfont solo-comment"></i></p></li><li><p><code>solo-gotop</code> <i class=" iconfont solo-gotop"></i></p></li><li><p><code>solo-</code> <i class=" iconfont solo-"></i>  自定义导航不设置图标时显示</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solo </tag>
            
            <tag> solo-nexmoe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日刷leetcode--简单版（三）</title>
      <link href="/leetcode3.html"/>
      <url>/leetcode3.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="58-最后一个单词的长度">58. 最后一个单词的长度</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-45f2c7e9.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>定义一个变量统计，从前往后遍历，遇到空格归零就可以了，注意处理最后几个个字符全为空格的情况</li><li>定义一个变量统计，从后往前便利，虽然时间复杂度同为 O(n)，但是第二个明显快很多</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLastWord</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">                <span class="keyword">for</span> i:= <span class="built_in">len</span>(s)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">                        <span class="keyword">if</span> s[i] == <span class="number">32</span>&#123;</span><br><span class="line">                                <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">                                        <span class="keyword">continue</span></span><br><span class="line">                                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        <span class="keyword">break</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        count ++</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.2 MB, 在所有 Go 提交中击败了 39.13%的用户</p></blockquote><h3 id="66-加一">66.加一</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-1081bedf.png" alt="image.png"></p><h5 id="解题思路">解题思路</h5><ul><li>从后面往前面循环，最后以一位加 1 即可，处理好末尾<code>9</code>与<code>999</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        c := <span class="number">1</span> <span class="comment">// 定义一个变量用来进位，进位归零则程序结束</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="built_in">len</span>(digits) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">                digits[i] += c</span><br><span class="line">                c--</span><br><span class="line">                <span class="keyword">if</span> digits[i] == <span class="number">10</span> &#123;</span><br><span class="line">                        digits[i] = <span class="number">0</span></span><br><span class="line">                        c = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> digits</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> c != <span class="number">0</span> &#123; <span class="comment">// 循环完后依旧存在进位则表示遇到了999</span></span><br><span class="line">                digits = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;, digits...)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.2 MB, 在所有 Go 提交中击败了 30.57%的用户</p></blockquote><h3 id="67-二进制求和">67.二进制求和</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-21de0dac.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>判断两个字符串的大小，保证 a 为较长的一个</li><li>从后往前循环相加，先循环较短的字符串，再循环长字符串剩余的，定义一个变量记录是否需要进位，两个字符串相加是需要加上进位的值</li><li>最后判断进位值是否为 0，不为 0 则在相加后字符串最前面一位加 1</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addBinary</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">la, lb := <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line"><span class="keyword">if</span> la &lt; lb &#123;</span><br><span class="line">la, lb = lb, la</span><br><span class="line">a, b = b, a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> carry, s <span class="keyword">byte</span></span><br><span class="line">str := <span class="built_in">make</span>([]<span class="keyword">byte</span>, la+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> lb &gt; <span class="number">0</span> &#123;</span><br><span class="line">la--</span><br><span class="line">lb--</span><br><span class="line">s = <span class="keyword">byte</span>(a[la]-<span class="string">&#x27;0&#x27;</span>) + <span class="keyword">byte</span>(b[lb]-<span class="string">&#x27;0&#x27;</span>) + carry</span><br><span class="line">carry = s / <span class="number">2</span></span><br><span class="line">s = s % <span class="number">2</span></span><br><span class="line">str[la+<span class="number">1</span>] = <span class="keyword">byte</span>(s + <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> la &gt; <span class="number">0</span> &#123;</span><br><span class="line">la--</span><br><span class="line">s = <span class="keyword">byte</span>(a[la]-<span class="string">&#x27;0&#x27;</span>) + carry</span><br><span class="line">carry = s / <span class="number">2</span></span><br><span class="line">s = s % <span class="number">2</span></span><br><span class="line">str[la+<span class="number">1</span>] = <span class="keyword">byte</span>(s + <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> carry == <span class="number">1</span> &#123;</span><br><span class="line">str[la] = carry + <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">str = str[la+<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(str[la:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.3 MB, 在所有 Go 提交中击败了 68.18%的用户</p></blockquote><h3 id="69-x-的平方根">69. x 的平方根</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-66ad4fc1.png" alt="image.png"></p><h4 id="解题思路-1">解题思路 1</h4><ul><li>使用官方包 math.Sqrt，然后提取整数部分即可(不提供代码)</li></ul><h4 id="解题思路-2">解题思路 2</h4><ul><li>使用二分法，判断中位数的积是否大于 x，是则右边向左移，否则左边直接等于中位数</li><li>注意的是取中位数是要取右中位数，也就是要加１，不然会死循环</li></ul><h5 id="示例代码-2">示例代码 2</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">l, r := <span class="number">0</span>, x/<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">mid := (l + r + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">sqrt := mid * mid</span><br><span class="line"><span class="keyword">if</span> sqrt &gt; x &#123;</span><br><span class="line">r = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l = mid</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(l, r, mid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :8 ms, 在所有 Go 提交中击败了 29.75%的用户<br>内存消耗 :2.8 MB, 在所有 Go 提交中击败了 5.23%的用户</p></blockquote><h3 id="70-爬楼梯">70. 爬楼梯</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-4aa9ad43.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>这是一个标准的斐波拉切数列，所以就不多说</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">res := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">res = a + b</span><br><span class="line">a, b = b, res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2 MB, 在所有 Go 提交中击败了 52.61%的用户</p></blockquote><h3 id="83-删除排序链表中的重复">83. 删除排序链表中的重复</h3><h4 id="题目描述">题目描述</h4><p><img src="https://cdn.inkdp.cn/img/image-191c979d.png" alt="image.png"></p><h4 id="解题思路">解题思路</h4><ul><li>因为是排序了的，所以就相对来说比较简单，判断是否与下一个相等，相等即后移即可，讲<code>Next</code>指向<code>Next.Next</code></li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">carry := head</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> carry != <span class="literal">nil</span> &amp;&amp; carry.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> carry.Val == carry.Next.Val &#123;</span><br><span class="line">carry.Next = carry.Next.Next</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">carry = carry.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了 96.46%的用户<br>内存消耗 :3.2 MB, 在所有 Go 提交中击败了 48.18%的用户</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190809 TGIF</title>
      <link href="/articles/2019/08/09/1565315193270.html"/>
      <url>/articles/2019/08/09/1565315193270.html</url>
      
        <content type="html"><![CDATA[<h1 id="史上最水的tgif来了">史上最水的TGIF来了</h1><p>想抢这个好几次了，可是每次都是在拥挤的地铁里就被人抢了，今天居然还在，既然抢到了就水一篇吧。</p><p>不知不觉来社区已经67天了，想起注册社区，搭建博客的时候我还在成都。还坐在办公室里悠闲的摸鱼，划水，想着回到家里晚上吃着女朋友做的饭菜，妙啊。</p><p>转眼间，两个月的时间，我已经来到广州工作，也入职了一个月，也成功从PHP转成了GO，看起来似乎完成了来广州的目的，然后女朋友去了新疆，又开始了异地。</p><p>初来广州时，我踌躇满志，幻想着来到这边之后的一切一切。一开始打算用一个月的时间来找工作，毕竟我知道刚从成都跑到广州来的时候状态有多么的不好，毕竟在成都真的是天天摸鱼划水，太久没写代码，啥都忘了。可以一边面试一边总结，这次一定要找到一个称心如意的工作，毕竟前两次选择的工作都过于草率，也很不利于自己以后的发展。记得是晚上11点多到的广州，很讽刺的是我父母都在这边却并没有人来接我，虽然早知如此，但多少还是有一丝的遗憾吧，最后那晚我去了我姑姑家，第二天，我把箱子扔到我爸那里，就直接去面试了。</p><p>来广州后的第一场面试，记得那天在下了很大的雨，去面试的路上鞋子都湿透了，心里在想下雨太难受了，还是天天出太阳比较好(我现在知道当时的想法有多么的愚蠢了，TMD好热)，扯远了…那家公司是做外包的，我面试的是PHP，面试官是做JAVA的，所以没问些什么，问了些数据库的东西，就随意吹了一下，这算是我强项，然后问我能不能独立完成项目，我告诉他能。然后就是老板之类的来面试我，就瞎吹了一些：公司刚刚淘汰一个团队，想重新组建一个团队，屋外坐着的就是刚找来没几天的Java和前端，给了我5K+提成，转正后6-8K+提成(不就是6吗)。毕竟来广州是想往go的方向走，而且不想去外包公司，所以当时没答应，算是婉拒了。</p><p>出门就接到我妈的微信电话，如实告诉我妈刚刚的情况。然后我妈就让我别挑，直接去上班，不满意可以慢慢找，但是就我就直接不干，说是要慢慢找下，然后我妈就不乐意了让我赶紧找，我头天晚上半夜到第二天就已经在面试了还要怎么赶紧找。</p><p>后面稀稀疏疏的面了几家，但是都是PHP，大多都在6-8k的样子。因为当时使用boss方式不对，所以没投到多少go的岗位，也就没多少面试机会。</p><p>后面面试了两家看着算是比较大公司，都是go，记得第一家离网易不是特别远，面试题我还做的不错，最后正式面试的时候回答的一塌糊涂，那时的我才发现自己好像只会最基础的CURD，所以面试的结果可想而知。第二家是映客直播，问了一些和头一天一样的问题，因为有做面试笔记的习惯，虽然都基本上回答上来了，但是感觉跟他要的人还是有所差距，看的出来面试官也在纠结，然后因为自己的不自信说错话导致面试凉凉。</p><p>我保持这每天跑3-4场面试的频率，但是我的父母好像都在不断地催促我快点找工作，我自己清楚的知道我当时的状态不是特别好，需要沉淀一下，总结一下再接着面试，可是我回家连电脑摆出来都困难，所有的面试比较都是手机做的。一场有一场的面试打得我头昏脑涨。索性在第四天，我找到了两家在当时的情况下来说还不错的公司，当时还有些纠结<a href="https://hacpai.com/article/1561715541829">选哪个 Offer</a>，最后我选了第二家，在纠结选哪家公司的时候我也从我爸那儿搬到了我妈那儿，在我妈附件租了房子，因为我父母离异10多年了，我妈担心我跟着我爸学坏了，一天3-4个电话打过来(我从没见过她这么关心我)。</p><p>来公司一个月了，办公室一天安静的飞起(除了敲键盘的声音)，明明就坐在你对面的人，交流却要用钉钉，所以也导致的了我现在都说不出办公室里面所以人的名字。不算压抑，我习惯了。但是慢慢发现公司似乎与自己预想的出入有些大，6.5的薪资跟我来广州预计的还是差别有些大，当时说的是后面可以加，入职了才发现好像都没调薪制度；公司架构模式这些听起来很高大上，毕竟我也是在写微服务的人了，回头一想，我还是在写接口，还是整天CURD，虽然是电商项目，但是我想象中的高并发之类的东西，好像跟我不想关呀，只是个拧螺丝的；我知道自己能力不够，可我是一个在项目中学习的人，对于我来说能学到东西或者能挣到钱，我觉得天天加班到11点都无所谓(反正我1点左右才睡)，然后现在一天闲的飞起，我已经连续看了两天小说了。既来之则安之吧。</p><p>最近整个人都变得很丧，回家倒头就玩手机，完全没有斗志，也不知道未来在何方，感觉上班有一次变成了摸鱼混日子，虽然知道自己要学的有很多，但是却不知道从何学起。熬夜玩手机成了日常，跑步记单词什么已经被抛之脑后，突然找不到一个奋斗的方向了，又陷入了“间歇性踌躇满志，持续性混吃等死”的状态。</p><p>不说了，对接下业务，鼓捣点新东西</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TGIF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始安装 solo 博客</title>
      <link href="/articles/2019/08/06/1565021931775.html"/>
      <url>/articles/2019/08/06/1565021931775.html</url>
      
        <content type="html"><![CDATA[<p>之前也写过类似的帖子，但是由于那时自己的各种原因写的不是特别好，所以今天写一个聚合帖，记录从购买服务器到安装solo然后通过nginx反向代理，最后升级https的全过程。此贴献给完全无基础的人，所以废话较多，见谅</p><h1 id="1-购买服务器">1. 购买服务器</h1><p>首先你得有自己的服务器，有的话就跳过。服务商可选的有很多，比如：<a href="https://cn.aliyun.com/">阿里云</a>、<a href="https://cloud.tencent.com/">腾讯云</a>、<a href="https://cloud.baidu.com/">百度云</a>、还有一些香港的服务商以及国外的（有特殊需求的可以考虑下）。腾讯和阿里对于新用户以及学生都有很大的优惠，配置的话如果只挂solo，买最低配1G1核1M即可。国内的几家都可以关注下，不定时会有很好的优惠活动。我比较推荐<a href="https://cn.aliyun.com/">阿里云</a>，前段时间刚买了一台3年才668多，不知道活动结束没有。阿里云购买服务器时会要求你安装系统（不知道可不可以不选），推荐选择centos。</p><h1 id="2-购买域名-可不买">2. 购买域名(可不买)</h1><p>建议还是买一个域名，直接通过IP访问的话不是特别好。购买域名时不要盯着 <code>.com</code>，<code>.cn</code>这种比较热门的域名，往往很贵。还有尽量选择可备案的域名，否则就会像<a href="https://sszsj.cc:444/">鼠鼠在碎觉</a>一样只能挂载444端口上运行。可通过<a href="http://xn--eqrt2g.xn--vuq861b/">域名.信息</a>查看可备案域名。如果你服务器买着国外的话似乎就不用备案。</p><h1 id="3-域名解析与备案">3. 域名解析与备案</h1><p>服务器和域名购买完后需要将域名解析到服务器，有些服务商可能不支持跨服务商解析，腾讯云域名可以解析阿里云服务器。解析过程大概需要10分钟。解析完成后如下图所示：<br><img src="https://cdn.inkdp.cn/img/image-5ff5a25e.png" alt="image.png"><br>如果不备案的话，80端口与443端口大概率会被封。所以备案还是需要的，备案的过程有点麻烦需要耐心。大致步骤如下：<br><img src="https://cdn.inkdp.cn/img/image-4527c63e.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-056ca9d6.png" alt="image.png"><br>接入备案很快，几天就完事了。</p><h1 id="4-为服务器安装系统">4. 为服务器安装系统</h1><p>给服务器安装系统不用像你给自己装系统那样麻烦，很方便，由于我使用的centos，所以推荐安装centos，以免出现不必要的错误。后续操作嘘设置服务器安全组，开发如下端口：<code>80</code>、<code>8080</code>、<code>3306</code>、<code>443</code>、<code>22</code>。具体左右我会在下面一一说明，<code>22用来远程连接服务器使用</code>，windows用户可下载xshell远程链接服务器。</p><h1 id="5-安装docker">5. 安装docker</h1><p>直接使用yum安装，简单快捷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#安装 Docker</span><br><span class="line">yum -y install docker</span><br><span class="line"></span><br><span class="line">#启动 Docker 后台服务</span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line">#测试运行 hello-world</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>出现hello world 就证明安装正常了<br><img src="https://cdn.inkdp.cn/img/image-cc55a2ad.png" alt="image.png"></p><h1 id="6-安装mysql">6.安装Mysql</h1><p>版本随意，我这里选择的5.6，你可以选择更高版本的，这个没关系，不影响使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 安装mysql:5.6,直接docker run 他会自动去官方镜想下载</span><br><span class="line"># MYSQL_ROOT_PASSWORD&#x3D;你的数据库密码</span><br><span class="line">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.6</span><br><span class="line"></span><br><span class="line"># docker安装的mysql默认允许远程连接，可以使用Navicat等软件连接数据库</span><br><span class="line"># 进入容器mysql</span><br><span class="line">docker exec -it mysql bash</span><br><span class="line"></span><br><span class="line"># 进入数据库 p后面跟你的密码</span><br><span class="line">mysql -uroot -pXXX</span><br><span class="line"></span><br><span class="line"># 创建数据库(数据库名:solo;字符集utf8mb4;排序规则utf8mb4_general_ci)</span><br><span class="line">create database solo DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line"># 出现Query OK, 1 row affected (0.00 sec)表示成功</span><br><span class="line">#退出数据库</span><br><span class="line">exit</span><br><span class="line">#退出容器</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h1 id="7-安装solo">7. 安装solo</h1><p>直接运行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach --name solo --network&#x3D;host \</span><br><span class="line">--env RUNTIME_DB&#x3D;&quot;MYSQL&quot; \</span><br><span class="line">--env JDBC_USERNAME&#x3D;&quot;root&quot; \</span><br><span class="line">--env JDBC_PASSWORD&#x3D;&quot;123456&quot; \</span><br><span class="line">--env JDBC_DRIVER&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot; \</span><br><span class="line">--env JDBC_URL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;solo?useUnicode&#x3D;yes&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC&quot; \</span><br><span class="line">--rm \</span><br><span class="line">b3log&#x2F;solo --listen_port&#x3D;8080 --server_scheme&#x3D;http --server_host&#x3D;www.jinjianh.com</span><br></pre></td></tr></table></figure><p>上面的命令建议手敲，免得出错，参数说明</p><ul><li><code>--env JDBC_PASSWORD=&quot;123456&quot;</code> 将123456换成你的密码</li><li><code>--listen_port=8080</code> 监听的端口</li><li><code>--server_scheme=http</code> 请求方式，暂时使用http，后面我们会换成https</li><li><code>--server_host=www.jinjianh.com</code> 你的域名，如果你没有域名可以写ip地址</li><li><code>--rm</code>因为这个容器后面要删掉，带上rm会省很多事。</li></ul><p>命令成功执行没有报错的话，通过 <code>docker ps</code>查看执行的容器列表中是否存在solo，存在这表示启动成功，直接访问你的域名加:8080即可访问你的博客，<a href="http://www.jinjianh.com:8080/">金戋博客–http://www.jinjianh.com:8080</a><br>如果你尚在备案中，你可以收藏本帖，后面等备案通过了在研究后面的部分。<br>如果你不想使用nginx也不想升级https，那么你可以先执行 <code>docker stop solo</code>，然后将上面 <code>--listen_port=8080</code>的 <code>8080</code>换成 <code>80</code>，然后去掉 <code>--rm</code>，再执行一次就ok。</p><h1 id="8-安装nginx">8. 安装nginx</h1><p>安装nginx前，我们现在本地建立几个文件，用于存放nginx的配置文件等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 切换到服务器根目录</span><br><span class="line">cd &#x2F;</span><br><span class="line"># 创建主目录</span><br><span class="line">mkdir dockerData</span><br><span class="line"># 创建文件</span><br><span class="line">mkdir dockerData&#x2F;nginx dockerData&#x2F;nginx&#x2F;conf dockerData&#x2F;nginx&#x2F;logs dockerData&#x2F;nginx&#x2F;www dockerData&#x2F;nginx&#x2F;ssl</span><br></pre></td></tr></table></figure><p>上面的 <code>dockerData</code>可以换成自己喜欢的名字</p><ul><li><code>dockerData/nginx</code> 用于存放docker下nginx自定义文件</li><li><code> dockerData/nginx/conf</code> 存放nginx配置文件</li><li><code>dockerData/nginx/log</code> 存放nginx日志文件</li><li><code>dockerData/nginx/www</code> 存放nginx访问的资源文件</li><li><code>dockerData/nginx/ssl</code> 存放ssl证书<br>启动nginx</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -p 80:80 -d --rm nginx</span><br></pre></td></tr></table></figure><p>如果你没有备案，可以将上面的 <code>80:80</code>换成 <code>8081:80</code>，因为这个东西一会儿也要删掉，所以加上 <code>--rm</code>参数，命令执行玩后通过 <code>docker ps</code>查看nginx是否在运行，在运行的情况下访问你的域名加端口号查看是否正常安装，<code>80</code>直接省略。如下表示访问成功<br><img src="https://cdn.inkdp.cn/img/image-ec38061d.png" alt="image.png"><br>导出配置文件</p><ul><li><code>docker cp nginx:/etc/nginx/nginx.conf /dockerData/nginx/conf/nginx.conf</code> 导出配置文件nginx.conf</li><li><code>docker cp nginx:/etc/nginx/conf.d /dockerData/nginx/conf/conf.d</code> 导出配置为你nginx.conf<br>执行 <code>docker stop nginx</code>，会自动删除现在的nginx容器，然后执行如下命令重新启动一个nginx容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;conf&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx nginx</span><br></pre></td></tr></table></figure><ul><li><code>-v /dockerData/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</code> 挂载配置文件 <code>nginx.conf</code></li><li><code>-v /dockerData/nginx/conf/conf.d:/etc/nginx/conf.d</code> 挂载配置文件 <code>default.conf</code></li><li><code>-v /dockerData/nginx/www:/usr/share/nginx/html </code> 挂载项目文件</li><li><code>-v /dockerData/nginx/logs:/var/log/nginx</code> 挂载配置文件</li></ul><p>访问你的域名，你会发现报错了</p><p><img src="https://cdn.inkdp.cn/img/image-9c8de340.png" alt="image.png"><br>这时我们可以前往 <code>/dockerData/nginx/logs</code>下查看日志文件</p><p><code>2019/08/05 14:57:54 [error] 6#6: *3 directory index of &quot;/usr/share/nginx/html/&quot; is forbidden, client: 121.32.33.217, server: localhost, request: &quot;GET / HTTP/1.1&quot;, host: &quot;www.jinjianh.com&quot; </code></p><p>因为 <code>/usr/share/nginx/html/</code>被挂载到了服务器上面的 <code>/dockerData/nginx/www</code>目录下，原来的欢迎页面在 <code>dockerData/nginx/www</code>是没有的，所有就报错了，这里我们随便建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 打开项目文件</span><br><span class="line">cd &#x2F;dockerData&#x2F;nginx&#x2F;www</span><br><span class="line"># 使用vim 创建并编辑文件</span><br><span class="line">vim index.html</span><br><span class="line"># 此时我们会进入vim界面，按 i 插入，然后输入</span><br><span class="line">&lt;h1&gt;Hello Docker-Nginx&lt;&#x2F;h1&gt;</span><br><span class="line"># 输入完后，按 esc，然后输入 :wq</span><br></pre></td></tr></table></figure><p>再次访问我们的域名就可以看到我们刚刚写的 <code>h1</code>标签内容</p><p><img src="https://cdn.inkdp.cn/img/image-70a4130f.png" alt="image.png"></p><h1 id="9-申请ssl证书-将http升级为https-可跳过">9. 申请ssl证书，将http升级为https(可跳过)</h1><p><code>https</code>想比与 <code>http</code>来说，最核心的内容就是多了一个ssl证书，证书是可以免费申请的。</p><h2 id="腾讯云">腾讯云</h2><p>访问 <a href="https://buy.cloud.tencent.com/ssl?fromSource=ssl">SSL证书选购</a> 申请</p><p><img src="https://cdn.inkdp.cn/img/image-05285d99.png" alt="image.png"></p><p>私钥可不填写<br><img src="https://cdn.inkdp.cn/img/image-98544bc3.png" alt="image.png"></p><p>选择手动DNS验证</p><p><img src="https://cdn.inkdp.cn/img/image-44754a07.png" alt="image.png"></p><p>可直接前往 <a href="https://cloud.tencent.com/document/product/400/4142#ManualVerification">SSL 证书 域名验证指引 - 操作指南 - 文档中心 - 腾讯云</a>查看</p><p><img src="https://cdn.inkdp.cn/img/image-3e6695e5.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-8828eaa2.png" alt="image.png"></p><p>前往<a href="https://console.cloud.tencent.com/ssl">证书管理-控制台</a>等待验证通过即可</p><p><img src="https://cdn.inkdp.cn/img/image-4c7bcc44.png" alt="image.png"></p><p>将 <code>nginx</code>下文件上传到 <code>/dockerData/nginx/ssl</code>目录下即可</p><h2 id="阿里云">阿里云</h2><p>访问<a href="https://common-buy.aliyun.com/?spm=5176.10695662.958455.3.3f9140d55mPzFH&amp;commodityCode=cas#/buy">云盾证书服务</a>申请，访问后如果有无内容可复制 <a href="https://common-buy.aliyun.com/?spm=5176.10695662.958455.3.3f9140d55mPzFH&amp;commodityCode=cas#/buy">https://common-buy.aliyun.com/?spm=5176.10695662.958455.3.3f9140d55mPzFH&amp;commodityCode=cas#/buy</a> 打开<br><img src="https://cdn.inkdp.cn/img/image-2f8ed8b3.png" alt="image.png"></p><p>走一下支付流程，然后申请</p><p><img src="https://cdn.inkdp.cn/img/image-af887011.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-a3de4d98.png" alt="image.png"><br><img src="https://cdn.inkdp.cn/img/image-8ef94cdf.png" alt="image.png"><br>操作流程基本与腾讯云一样，我就不详细说明了</p><h2 id="其他平台">其他平台</h2><p>免费的证书平台有很多，也可以去别的地方申请</p><h2 id="上传证书">上传证书</h2><p>一下示例为腾讯云证书，阿里云<br><img src="https://cdn.inkdp.cn/img/image-f9c0bb7e.png" alt="image.png"></p><p>验证完后，我们下载证书，解压后得到</p><p><img src="https://cdn.inkdp.cn/img/image-5b610f8d.png" alt="image.png"></p><p>最后把 <code>Nginx</code>下的两个文件上传至服务器 <code>/dockerDat/nginx/ssl</code>目录下，别的服务商申请的证书也一样，将最后的ssl证书放到 <code>/dockerDat/nginx/ssl</code>下即可</p><h2 id="配置nginx配置文件">配置nginx配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;dockerData&#x2F;nginx&#x2F;conf&#x2F;conf.d</span><br><span class="line">vim default.conf</span><br><span class="line"></span><br><span class="line"># 参考我的配置，配置自己的default.conf文件</span><br><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    ssl on;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;ssl&#x2F;1_www.jinjianh.com_bundle.crt;  # ssl 证书目录</span><br><span class="line">    ssl_certificate_key &#x2F;ssl&#x2F;2_www.jinjianh.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"># ......</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  rewrite ^(.*) https:&#x2F;&#x2F;$host$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line"># 按esc，然后输入:wq保持退出</span><br></pre></td></tr></table></figure><p>不重要的部分我省略了，可根据自己服务器配置做出相应调整<br>由于我们现在用的nginx容器并未监听443端口，所以需要删除现在的容器，重新启动一个新的nginx容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx  # 停止容器</span><br><span class="line">docker rm nginx # 删除容器</span><br><span class="line"># 启动新的</span><br><span class="line">docker run -d -p 80:80 -p 443:443 --name nginx \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;conf&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;ssl:&#x2F;ssl&#x2F; \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">-v &#x2F;dockerData&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx nginx</span><br></pre></td></tr></table></figure><ul><li><code>-p 443:443</code> 监听443端口</li><li><code>-v /dockerData/nginx/ssl:/ssl/</code> 挂载ssl证书目录</li></ul><p>访问查看，一切正常<br><img src="https://cdn.inkdp.cn/img/image-d2e1477f.png" alt="image.png"></p><h1 id="10-将solo通过nginx方向代理实现https访问">10. 将solo通过nginx方向代理实现https访问</h1><p>让solo还是跑在8080端口上，通过nginx代理到443端口即可，由于我们上面启动solo时添加了 <code>--rm</code>参数，只需要 <code>docker stop solo</code>即可自动删除solo容器，然后我们重新启动一个solo容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --detach --name solo --network&#x3D;host \</span><br><span class="line">--env RUNTIME_DB&#x3D;&quot;MYSQL&quot; \</span><br><span class="line">--env JDBC_USERNAME&#x3D;&quot;root&quot; \</span><br><span class="line">--env JDBC_PASSWORD&#x3D;&quot;123123&quot; \</span><br><span class="line">--env JDBC_DRIVER&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot; \</span><br><span class="line">--env JDBC_URL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;solo?useUnicode&#x3D;yes&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC&quot; \</span><br><span class="line">b3log&#x2F;solo --listen_port&#x3D;8080 --server_scheme&#x3D;https --server_host&#x3D;www.jinjianh.com --server_port&#x3D;</span><br></pre></td></tr></table></figure><ul><li><code>--server_scheme=http</code>换成 <code>--server_scheme=https</code>即可</li><li><code>--server_port</code>：最终访问端口，使用浏览器默认的 80 或者 443 的话值留空即可</li></ul><p>然后我们去配置nginx配置文件，实现nginx反向代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;dockerData&#x2F;nginx&#x2F;conf&#x2F;conf.d</span><br><span class="line">vim default.conf</span><br><span class="line"> location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;backend$request_uri;</span><br><span class="line">        proxy_set_header  Host $http_host;</span><br><span class="line">        proxy_set_header  X-Real-IP $remote_addr;</span><br><span class="line">        #root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        #index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"># 替换上面部分即可</span><br><span class="line"># 按esc，然后输入:wq保持退出</span><br></pre></td></tr></table></figure><h2 id="注意-nginx反代理上面的方式可能出现问题参考nginx反代">注意！！！Nginx反代理上面的方式可能出现问题参考<a href="https://hacpai.com/article/1492881378588#NGINX-%E5%8F%8D%E4%BB%A3">Nginx反代</a></h2><h2 id="注意-nginx反代理上面的方式可能出现问题参考nginx反代">注意！！！Nginx反代理上面的方式可能出现问题参考<a href="https://hacpai.com/article/1492881378588#NGINX-%E5%8F%8D%E4%BB%A3">Nginx反代</a></h2><h2 id="注意-nginx反代理上面的方式可能出现问题参考nginx反代">注意！！！Nginx反代理上面的方式可能出现问题参考<a href="https://hacpai.com/article/1492881378588#NGINX-%E5%8F%8D%E4%BB%A3">Nginx反代</a></h2><p>重启nginx，<code>docker restart nginx</code></p><p><img src="https://cdn.inkdp.cn/img/image-2c7eb017.png" alt="image.png"></p><p>完美</p><h1 id="11-后记">11. 后记</h1><h2 id="皮肤挂载">皮肤挂载</h2><ul><li>在你的服务器上创建一个目录用于存放皮肤，比如我的 <code>/dockerData/solo/skins/</code></li><li>然后将你要挂载的皮肤放到上面那个目录下</li><li>最后删除当前容器 重新启动一个容器，添加参数 <code>--v /dockerData/solo/skins/:/opt/solo/skins/</code>，这个添加时要注意位置，要添加到 <code>b3log/solo --listen...</code> 的上面一排</li><li>使用挂载皮肤时，默认会使用 <code>Pingsu</code>,</li></ul><h2 id="皮肤推荐">皮肤推荐</h2><p>我开源了两款皮肤 <a href="https://hacpai.com/article/1566468138289">solo-nexmoe</a>，因为我很懒的原因，solo-star没有手机端，所以你可以多挂载一款皮肤们比如官方皮肤 <code>Pinghsu</code>，如果你没有这款皮肤就会报错，没有请前往<a href="https://github.com/b3log/solo-skins">solo-skins</a>下载</p><h2 id="数据库占用内存过大优化">数据库占用内存过大优化</h2><p>由于我们购买的服务器是内存只有1G，然后docker安装的mysql虽然很快，但是实际上占用内存非常大，之前服务器在腾讯云的时候就经常挂掉，排查了很久才发现是docker下mysql的问题，迁移到阿里云后倒是没出先挂掉的问题，但是服务器内存占用也一直在90%以上，所以我们对mysql容器进行一些优化。<br>由于容器内不能vim，所以我们将mysql的配置文件复制到服务器上改了之后再复制回去，也可以将配置文件挂载到服务器上，过程我不多讲，只讲核心部分。</p><p>这里注意，如果你要删除容器重新挂载的话，请提前备份mysql数据，不然你就属于删库了<br>这里注意，如果你要删除容器重新挂载的话，请提前备份mysql数据，不然你就属于删库了<br>这里注意，如果你要删除容器重新挂载的话，请提前备份mysql数据，不然你就属于删库了<br>重要的话说三遍</p><p>在配置文件 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performance_schema_max_table_instances&#x3D;400</span><br><span class="line">table_definition_cache&#x3D;400</span><br><span class="line">table_open_cache&#x3D;256</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从容器中复制到服务器</span><br><span class="line">docker cp mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf &#x2F;dockerData&#x2F;mysql</span><br><span class="line"># 从服务器复制到容器</span><br><span class="line">docker cp &#x2F;dockerData&#x2F;mysql&#x2F;mysqld.cnf mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure><p>改完之后记得重启mysql，<code>docker restart mysql</code></p><h2 id="启用lute">启用lute</h2><p><strong>此内容适用于solo3.6.5+</strong></p><ul><li>启动Lute参考<a href="https://hacpai.com/article/1569240189601">Lute HTTP 使用指南</a></li><li>在solo启动参数末尾追加 <code>--lute_http=http://127.0.0.1:8249</code>/<code>--lute_http=http://localhost:8249</code>/<code>--lute_http=</code><br>solo成功启动后在终端输入 <code>docker logs solo</code>,日志显示有 <code>luteAvailable=true</code>即表示启用lute成功</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solo </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的时间复杂度计算</title>
      <link href="/articles/2019/08/03/1564826524260.html"/>
      <url>/articles/2019/08/03/1564826524260.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>时间复杂度与空间复杂度直接决定着一个算法的好坏，而大多时候在设计算法是时间复杂度要优先于空间复杂度。</p><h2 id="时间复杂度是什么-以下内容来着维基百科">时间复杂度是什么(以下内容来着维基百科)</h2><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" title="计算机科学">计算机科学</a>中，<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95" title="算法">算法</a>的<strong>时间复杂度</strong>（Time complexity）是一个<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0" title="函数">函数</a>，它定性描述该算法的运行时间。这是一个代表算法输入值的<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2" title="字符串">字符串</a>的长度的函数。时间复杂度常用<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7" title="大O符号">大O符号</a>表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是<a href="https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90" title="渐近分析">渐近</a>的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 <em>n</em> （必须比 <em>n0</em> 大）的输入，它至多需要 5<em>n</em>3 + 3<em>n</em> 的时间运行完毕，那么它的渐近时间复杂度是 O(<em>n</em>3)。<br/><br>为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。<br/><br>相同大小的不同输入值仍可能造成算法的运行时间不同，因此我们通常使用算法的最坏情况复杂度，记为 <strong><em>T</em>(<em>n</em>)</strong> ，定义为任何大小的输入 <em>n</em> 所需的最大运行时间。另一种较少使用的方法是平均情况复杂度，通常有特别指定才会使用。时间复杂度可以用函数 <em>T</em>(<em>n</em>) 的自然特性加以分类，举例来说，有着 <em>T</em>(<em>n</em>) = <em>O</em>(<em>n</em>) 的算法被称作“线性时间算法”；而 <em>T</em>(<em>n</em>) = <em>O</em>(<em>M**n</em>) 和 <em>M**n</em>= O(<em>T</em>(<em>n</em>)) ，其中 <em>M</em> ≥ <em>n</em> &gt; 1 的算法被称作“指数时间算法”。</p></blockquote><h2 id="常见算法时间复杂度">常见算法时间复杂度</h2><h3 id="搜索">搜索</h3><p><img src="https://cdn.inkdp.cn/img/image-8ba9a3db.png" alt="image.png"></p><h3 id="排序">排序</h3><p><img src="https://cdn.inkdp.cn/img/image-3a8afbfd.png" alt="image.png"></p><h3 id="数据结构">数据结构</h3><p><img src="https://cdn.inkdp.cn/img/image-fc45c2ae.png" alt="image.png"></p><h3 id="堆">堆</h3><p><img src="https://cdn.inkdp.cn/img/image-ed711758.png" alt="image.png"></p><h3 id="图">图</h3><p><img src="https://cdn.inkdp.cn/img/image-813479ac.png" alt="image.png"></p><h2 id="计算时间复杂度">计算时间复杂度</h2><p><strong>算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述</strong><br>1.在一个函数中，常数项对于函数的增长速度并不大，随意当T(n)=一个常数事，我们就可以说这个算法的时间复杂度为O(1)；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   i :&#x3D; 1</span><br><span class="line">   fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 该函数总共两条执行语句，所以时间复杂度T(n) &#x3D; 2，所以时间复杂度为O(1)</span><br></pre></td></tr></table></figure><p>2.如果T(n)不等于一个常数项时，可直接将常数项省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">sum +&#x3D; i</span><br><span class="line">&#125;</span><br><span class="line">sum +&#x3D; 1</span><br><span class="line">sum +&#x3D; 2</span><br><span class="line">sum +&#x3D; 3</span><br><span class="line">此函数共执行了 n+3次，所以T(n) &#x3D; n+3，时间复杂度为O(n)</span><br></pre></td></tr></table></figure><p>3.对于有高次幂的，低次幂的影响可以说是微乎其微。比如n^3对于n^2,n^2对于n，由于时间复杂度要求不是特别高，所以低次幂直接忽略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line"></span><br><span class="line">        for j :&#x3D; 0; j &lt; n; j++ &#123;</span><br><span class="line"></span><br><span class="line">            for k :&#x3D; 0; k &lt; n; k++ &#123;</span><br><span class="line">                &#x2F;&#x2F; xxx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">        for j :&#x3D; 0; j &lt; n; j++ &#123;</span><br><span class="line">                &#x2F;&#x2F; xxx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">上面函数的执行次数为n^3 + n^2，所以T(n) &#x3D; n^3 + n^2, 时间复杂度为O(n^3)</span><br></pre></td></tr></table></figure><p>4.因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">T(n) &#x3D; 3n^3，此时时间复杂度为 O(n^3)。</span><br></pre></td></tr></table></figure><p><strong>综合一下:只取最高次幂，最高次幂常数归1</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《追风筝的人》阅读笔记</title>
      <link href="/articles/2019/07/30/1564419665414.html"/>
      <url>/articles/2019/07/30/1564419665414.html</url>
      
        <content type="html"><![CDATA[<p>  离开成都时，励志要成为一个书虫，所以心一横买了Kindle，在买了一个半月后终于看完了第一本书——《追风筝的人》。</p><p>  “一个不能为自己挺身而出的孩子，长大之后只能是个懦夫”，如其父亲所说少年时的阿米尔确实是一个懦夫，在哈桑被欺凌时没有挺身而出，没有为自己口中的朋友挺身而出，这也成为了两人之间不可逾越的鸿沟。这个时候我试着问了一下自己，如果我是阿米尔我是否会挺身而出，是否会不顾一切的冲出求，而被阿塞弗折磨、欺辱与伤害。哈桑 —— 一个哈扎拉人，所以我理解了阿米尔，在那样的背景下，没有真正的人人平等，即使他们之间的关系如朋友般亲密也无济于事。</p><p>  在阿富汗遭到俄国入侵后，阿米尔与父亲来到了美国。在这里，他从一个平凡的人开始做起，过着一个普通人的生活，他失去了曾经的优越感，也和自己的父亲有了童年所没有的父子之情，生活过得还是非常幸福。</p><p>  当接到 拉辛汗电话时，他没有犹豫就走上了自我救赎的道路。在见到拉辛汗后，随之而来的是三观的崩塌，父亲的“偷窃”、哈桑的死亡、故乡的改变。虽有过犹豫，但是阿米尔战胜了自己属于美国人的优越感，走上了自我救赎的道路。</p><p>  文章除了对任务感情的描写，也详细的描述了阿富汗战后的惨状，索拉博是无数阿呼喊儿童的缩影，我很庆幸我所在的国家没有战乱。</p><p>  “我追。一个成年人在一群尖叫的孩子中奔跑。但我不在乎。我追，风拂过我脸庞，我唇上挂着一个潘杰希尔峡谷那样大大的微笑。我追”</p><p>  文章的结局对我来说是一个完美的结局，完成自我救赎的阿米尔仿佛回到了童年与哈桑一起追风筝的世界</p><h4 id="书籍下载：追风筝的人kindle正版-rar">书籍下载：<a href="https://cdn.jsdelivr.net/gh/inkdp/CDN@master/other/%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BAkindle%E6%AD%A3%E7%89%88-145b724e.rar">追风筝的人kindle正版.rar</a></h4>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日刷leetcode--简单版（二）</title>
      <link href="/leetcode2.html"/>
      <url>/leetcode2.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="/leetcode.html">日刷leetcode–简单版</a></p><hr><h3 id="26-删除排序数组中的重复项">26. 删除排序数组中的重复项</h3><blockquote><h4 id="题目描述">题目描述</h4><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2],</span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路">解题思路</h4><ul><li>题目中已说明，这是有序数组</li><li>采用双指针的方式，一个用于循环，一个用于记录不同的数</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j :=  <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] != nums[j] &#123;</span><br><span class="line">i++</span><br><span class="line">nums[i] = nums[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :100 ms, 在所有 Go 提交中击败了 84.75%的用户<br>内存消耗 :7.9 MB, 在所有 Go 提交中击败了 66.91%的用户</p></blockquote><hr><h3 id="27-移除元素">27. 移除元素</h3><blockquote><h4 id="题目描述">题目描述</h4><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len &#x3D; removeElement(nums, val);</span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路">解题思路</h4><ul><li>因为<code>你不需要考虑数组中超出新长度后面的元素</code>，所以遇到相同的移除就完事了</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == val &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums[:i], nums[i+<span class="number">1</span>:]...)</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.4 MB, 在所有 Go 提交中击败了 44.67%的用户</p></blockquote><hr><h3 id="28-实现-strstr">28. 实现 strStr()</h3><blockquote><h4 id="题目描述">题目描述</h4><p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个 &gt; 位置 (从 0 开始)。如果不存在，则返回  -1。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路">解题思路</h4><ul><li>定义两个数组指针 i 和 j，分别记录 haystack 和 needle</li><li>i 递增，从左往右依次匹配，如果当前 haystack 和 needle 字符相等，则继续匹配下一位，直到 j 的长度大于 needle 或者 haystack 和 needle 字符不相等</li><li>如果 haystack 和 needle 字符不相等，则 i 回到第一次匹配的位置，j 归 0 等待下一次匹配</li><li>判断 j 是否等于 needle 的长度，如果是这表示完全匹配</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] == val &#123;</span><br><span class="line">nums = <span class="built_in">append</span>(nums[:i], nums[i+<span class="number">1</span>:]...)</span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.3 MB, 在所有 Go 提交中击败了 53.10%的用户</p></blockquote><h3 id="35-搜索插入位置">35. 搜索插入位置</h3><blockquote><h4 id="题目描述">题目描述</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路">解题思路</h4><ul><li>这似乎是经典的二分了吧，所以微分就完事了</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> ; l &lt; r; &#123;</span><br><span class="line">mid := (l + r) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">l = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了 97.04%的用户<br>内存消耗 :3.1 MB, 在所有 Go 提交中击败了 50.79%的用户</p></blockquote><h3 id="38-报数">38. 报数</h3><blockquote><h4 id="题目描述">题目描述</h4><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。</span><br><span class="line">11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。</span><br><span class="line">21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。</span><br></pre></td></tr></table></figure><p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。<br>注意：整数顺序将表示为一个字符串。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路">解题思路</h4><ul><li>这道题其实并不难，难得是题目的描述可能让你弄不明白是怎么回事,</li><li>从第二行开始，后面的每一行都是数前面的<code>数字</code>有几个连续的，比如第二行数第一行有<code>1</code>个<code>1</code>，所以第二行对应<code>11</code></li><li>依次类推，第二行有<code>2</code>个<code>1</code>，所以第三行<code>21</code></li><li>4: <code>1211</code></li><li>5: <code>111221</code>(数连续的，<code>1</code>个<code>1</code>，<code>1</code>个<code>2</code>,<code>2</code>个<code>1</code>)</li><li>…</li><li>我们循环判断一个数字字符串，首先定义一个参照标准:<code>this := str[0]</code>，一个计数器<code>count := 1</code>,循环和从<code>str[1]</code>开始，判断<code>str[i] == this</code>，为真则<code>count ++ </code>，否则从新对<code>this</code>与<code>count</code>赋值。这样我们就完成了一次报数操作</li><li>要求求到第 N 位，这个 N 可以循环也可以递归，看个人喜好</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countStr</span><span class="params">(n <span class="keyword">int</span>, str []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(str)*<span class="number">2</span>)</span><br><span class="line">this := str[<span class="number">0</span>]</span><br><span class="line">count := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> this == str[i] &#123;</span><br><span class="line">count++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="keyword">byte</span>(count+<span class="string">&#x27;0&#x27;</span>), this) <span class="comment">// count为int型，+&#x27;0&#x27;相当于+48，得到count对应的ASCII码值</span></span><br><span class="line">this = str[i]</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="keyword">byte</span>(count+<span class="string">&#x27;0&#x27;</span>), this)</span><br><span class="line"><span class="keyword">return</span> countStr(n<span class="number">-1</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.2 MB, 在所有 Go 提交中击败了 50.58%的用户</p></blockquote><h3 id="53-最大子序列合">53. 最大子序列合</h3><blockquote><h4 id="题目描述">题目描述</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><p>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p></blockquote><h4 id="解题思路-1">解题思路 1</h4><ul><li>暴力法，时间复杂度为 O(n^2)使用双循环的形式累加即可，这里不过多阐述</li></ul><h4 id="解题思路-2">解题思路 2</h4><ul><li>分治法，这道题分治法并不是最简方式，但还是大概讲下思路</li><li>最大子序和要么在左半边，要么在右半边，要么是穿过中间，对于左右边的序列，情况也是一样，因此可以用递归处理。中间部分的则可以直接计算出来，3 个值取最大的即可，时间复杂度是 O(nlogn)</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maxSum(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSum</span><span class="params">(nums []<span class="keyword">int</span>, l, r <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l == r &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br><span class="line">    &#125;</span><br><span class="line">    mid := (l + r) / <span class="number">2</span></span><br><span class="line">    maxLeft := maxSum(nums, l, mid)</span><br><span class="line">    maxRight := maxSum(nums, mid+<span class="number">1</span>, r)</span><br><span class="line">    lSum, sum := math.MinInt64, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := mid; i &gt;= l; i-- &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> sum &gt; lSum &#123;</span><br><span class="line">            lSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rSum, sum := math.MinInt64, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := mid + <span class="number">1</span>; i &lt;= r; i++ &#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> sum &gt; rSum &#123;</span><br><span class="line">            rSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(max(maxLeft, maxRight), lSum+rSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :8 ms, 在所有 Go 提交中击败了 92.80%的用户</p><p>内存消耗 :3.3 MB, 在所有 Go 提交中击败了 73.67%的用户</p></blockquote><h4 id="解题思路-2">解题思路 2</h4><ul><li>动态规划，有关这个思路我找到了一段通熟易懂的理解方式</li></ul><blockquote><p>假设你是一个选择性遗忘的赌徒，数组表示你这几天来赢钱或者输钱，<br>你用 sum 来表示这几天来的输赢，<br>用 ans 来存储你手里赢到的最多的钱，</p><p>如果昨天你手上还是输钱（sum &lt; 0），你忘记它，明天继续赌钱；<br>如果你手上是赢钱(sum &gt; 0), 你记得，你继续赌钱；<br>你记得你手赢到的最多的钱</p></blockquote><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArrays</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum, ans := math.MinInt64, math.MinInt64</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += v</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum = v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ans &lt; sum &#123;</span><br><span class="line">            ans = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了 99.10%的用户<br>内存消耗 :3.3 MB, 在所有 Go 提交中击败了 80.78%的用户</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日刷leetcode（目录篇）</title>
      <link href="/leetcode.html"/>
      <url>/leetcode.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>此贴开于<code>2019-7-29</code>，时过境迁，发现自己也并没有剑刺每天刷题，成了一名标题党，今重拾算法，已贴为证！！！</p><p><s>谨以此贴记录我刷题的过程，那么我为啥要刷题呢</s></p><ol><li><s>熟悉各互联网公司的算法题目，为找工作做准备。</s></li><li><s>复习以前学过的编程语言，LeetCode支持几乎所有主流编程语言，大家可以用不同语言来做题。</s></li><li><s>熟悉常见的算法和数据结构，LeetCode提供了交流平台，一些大神会将自己的解法贴出来共享，有些巧妙的解法实在令人叫绝，虽然几乎都是英文，但上面的国人也特别多（中文拼音名字&gt;_&lt;）。</s></li><li><s>学习别人的编程思维，加快编程的速度，避免常见的BUG。</s></li></ol><p><s>以上内容摘抄自网络，纯属瞎说，真是的原因是：</s></p><ul><li><s>因为上班工作做完后，不敢明目张胆的摸鱼</s></li><li><s>下班无聊不想打游戏</s></li><li><s>算法真的很弱</s></li></ul><p><s>时过境迁，上次打开leetcode的时候还没有中文版，而现在已经有了–<a href="https://leetcode-cn.com/">力扣</a>。</s><br><s>由于篇幅的问题，我觉得5题一篇，话不多说。</s></p><h3 id="目录思路：">目录思路：</h3><ol><li>链表<ul><li><a href="skill/algorithm/13378.html">双指针技巧秒杀链表</a></li></ul></li><li>数组<ul><li><a href="skill/algorithm/17874.html">双指针技巧秒杀数组</a></li></ul></li><li>二叉树<ul><li><a href="skill/algorithm/14521.html">两种思路手撕二叉树</a></li></ul></li></ol><h3 id="旧版目录：">旧版目录：</h3><ul><li><a href="https://inkdp.cn/leetcode1.html">日刷leetcode–简单版系列（一）</a></li><li><a href="https://inkdp.cn/leetcode2.html">日刷leetcode–简单版系列（二）</a></li><li><a href="https://inkdp.cn/leetcode3.html">日刷leetcode–简单版系列（三）</a></li><li><a href="https://inkdp.cn/leetcode4.html">日刷leetcode–简单版系列（四）</a></li><li><a href="https://inkdp.cn/leetcode5.html">日刷leetcode–简单版系列（五）</a></li><li><a href="https://inkdp.cn/leetcode6.html">日刷leetcode–简单版系列（六）</a></li></ul><h4 id="简单篇暂停更新-后续打算系统的刷-目录做出更改">简单篇暂停更新，后续打算系统的刷，目录做出更改</h4><ol><li>数组<ul><li>简单[进行中]：此篇章尽量补书写题解<ul><li><a href="/leetcode_array1.html">leetcode-数组系列1</a></li><li><a href="/skill/algorithm/51727.html">leetcode-数组系列2</a></li><li><a href="/skill/algorithm/56303.html">leetcode-数组系列3</a></li><li><a href="/skill/algorithm/6574.html">leetcode-数组系列4</a></li><li><a href="/skill/algorithm/55663.html">leetcode-数组系列5</a></li><li><a href="/skill/algorithm/55343.html">leetcode-数组系列6</a></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 语言圣经练习解答 -- 第四章 (关闭)</title>
      <link href="/articles/2019/06/12/1560331304695.html"/>
      <url>/articles/2019/06/12/1560331304695.html</url>
      
        <content type="html"><![CDATA[<h2 id="go语言圣经-the-go-programming-language-第四章练习题答案">go语言圣经(The Go Programming Language)第四章练习题答案</h2><h4 id="练习-4-1：-编写一个函数-计算两个sha256哈希码中不同bit的数目-参考2-6-2节的-popcount函数">练习 4.1： 编写一个函数，计算两个SHA256哈希码中不同bit的数目。（参考2.6.2节的 PopCount函数。)</h4><blockquote><p>解题思路</p></blockquote><ul><li>循环字节数组</li><li>循环字节bit，对比是否相同</li></ul><iframe style="border:1px solid" src="https://wide.b3log.org/playground/1de1b0989661e96a455fb5f24c9752d2.go" width="99%" height="600"></iframe><h4 id="练习-4-2：-编写一个程序-默认打印标准输入的以sha256哈希码-也可以通过命令行标准参-数选择sha384或sha512哈希算法">练习 4.2： 编写一个程序，默认打印标准输入的以SHA256哈希码，也可以通过命令行标准参 数选择SHA384或SHA512哈希算法。</h4><blockquote><p>解题思路</p></blockquote><ul><li>获取命令行输入的参数</li><li>通过命令行参数返回值</li></ul><iframe style="border:1px solid" src="https://wide.b3log.org/playground/8a883544635b919cd2f822312adb81cf.go" width="99%" height="600"></iframe>> 实际效果<p><img src="https://cdn.inkdp.cn/img/image-0d9ee8d7.png" alt="image.png"></p><h4 id="练习-4-3-重写reverse函数-使用数组指针代替slice">练习 4.3: 重写reverse函数,使用数组指针代替slice。</h4><blockquote><p>解题思路(无)</p></blockquote><iframe style="border:1px solid" src="https://wide.b3log.org/playground/12a10f74a7fc189d271d8c6aa1de3d95.go" width="99%" height="600"></iframe><h4 id="练习-4-4-编写一个rotate函数-通过一次循环完成旋转">练习 4.4: 编写一个rotate函数,通过一次循环完成旋转。</h4><blockquote><p>解题思路</p></blockquote><ul><li>从新创建一个数组，新数组下标为原数组下标加上偏移值</li><li>如果超出最大长度则从最左边开始</li></ul><iframe style="border:1px solid" src="https://wide.b3log.org/playground/c7b0b5fc4d02333f29038bd4953cf880.go" width="99%" height="600"></iframe><h4 id="练习-4-6-写一个函数在原地完成消除-string中相邻重复的字符串的操作">练习 4.6: 写一个函数在原地完成消除[]string中相邻重复的字符串的操作。</h4><blockquote><p>解题思路</p></blockquote><ul><li><strong>原地完成消除</strong> / <strong>相邻重复</strong></li><li>原地消除表示必须在原有的数组上操作</li><li>遇到相同的先前移一位</li><li>下标保持不动继续检测当前位置是否跟下一位重复</li></ul><iframe style="border:1px solid" src="https://wide.b3log.org/playground/7504134d6e7f8ea5167e9afc393338bc.go" width="99%" height="600"></iframe><h4 id="练习-4-6-编写一个函数-原地将一个utf-8编码的-byte类型的slice中相邻的空格-参考">练习 4.6: 编写一个函数,原地将一个UTF-8编码的[]byte类型的slice中相邻的空格(参考</h4><p>unicode.IsSpace)替换成一个空格返回</p><blockquote><p>解题思路</p></blockquote><ul><li>基本一4.5一致，只是判断字母变成了判断空格</li></ul><iframe style="border:1px solid" src="https://wide.b3log.org/playground/4699347511e21456ae37d8d335046732.go" width="99%" height="600"></iframe><h4 id="练习-4-7-修改reverse函数用于原地反转utf-8编码的-byte-是否可以不用分配额外的内">练习 4.7: 修改reverse函数用于原地反转UTF-8编码的[]byte。是否可以不用分配额外的内</h4><p>存?</p><blockquote><p>解题思路</p></blockquote><ul><li>与原本的reverse基本一致</li></ul><iframe style="border:1px solid" src="https://wide.b3log.org/playground/1f127d8f4ff6c25d302547ebef5b5a35.go" width="99%" height="600"></iframe>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日刷leetcode--简单版（一）</title>
      <link href="/leetcode1.html"/>
      <url>/leetcode1.html</url>
      
        <content type="html"><![CDATA[<h3 id="返回总目录">返回总目录</h3><p><a href="/leetcode.html">日刷leetcode–简单版</a></p><h3 id="1-两数之后">1.两数之后</h3><blockquote><h4 id="题目描述">题目描述</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><h4 id="示例">示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路-1">解题思路 1</h4><ul><li>暴力法，双循环相加结果等于 target 就返回</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func twoSum(nums []int, target int) []int &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; len(nums); i++ &#123;</span><br><span class="line">        for j :&#x3D; i + 1; j &lt; len(nums); j++ &#123;</span><br><span class="line">            if nums[i] + nums[j] &#x3D;&#x3D;target &#123;</span><br><span class="line">                return []int&#123;i,j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :56 ms, 在所有 Go 提交中击败了 32.33%的用户<br>内存消耗 :3 MB, 在所有 Go 提交中击败了 78.76%的用户</p></blockquote><h4 id="解题思路-2">解题思路 2</h4><ul><li>遍历一次，求当前值的下标是否存在哈希表中，存在就返回，不存在就将当前值与下标存入哈希表</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    maps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        difference := target - v</span><br><span class="line">        <span class="keyword">if</span> _, ok := maps[difference]; ok &#123;  <span class="comment">// 判断是否存在指定k的值</span></span><br><span class="line">            <span class="keyword">return</span> []<span class="keyword">int</span>&#123;maps[difference], k&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maps[v] = k <span class="comment">// 将值作为key存储到map中</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了 89.93%的用户<br>内存消耗 :3.8 MB, 在所有 Go 提交中击败了 30.06%的用户</p></blockquote><hr><h3 id="7-整数反转">7.整数反转</h3><blockquote><h5 id="题目描述">题目描述</h5><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p>示例 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p>示例 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><h4 id="注意">注意</h4><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [− 231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><h4 id="解题思路">解题思路</h4><ul><li>依次取模再乘以 10 即可，注意取值范围</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">num = num*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">x = x / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> num &gt; math.MaxInt32 || num &lt; math.MinInt32 &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.2 MB, 在所有 Go 提交中击败了 41.71%的用户</p></blockquote><hr><h3 id="9-回文数">9.回文数</h3><blockquote><h5 id="题目描述">题目描述</h5><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路-1">解题思路 1</h4><ul><li>从示例中可以看出，负数和 10 的倍数的数都不是回文数，所以首先排除他们</li><li>转换为字符串，从两头往中间判断是否相等</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x%<span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">s := strconv.Itoa(x)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] != s[j] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :20 ms, 在所有 Go 提交中击败了 81.69%的用户<br>内存消耗 :5.5 MB, 在所有 Go 提交中击败了 15.78%的用户</p></blockquote><h4 id="解题思路-2">解题思路 2</h4><ul><li>从示例中可以看出，负数和 10 的倍数的数都不是回文数，所以首先排除他们</li><li>将数字分为两部分，的后半部分反转过来，要求后半部分不得大于前半部分</li><li>查看数字后半部分是否与前半部分相同，相同既是回文数，比如<code>1221</code>前半部分为<code>12</code>，后半部分也为<code>12</code>，所以他是回文数</li><li>如果数字位数为奇数，比如<code>12321</code>就会出现前半部分为<code>12</code>，后半部分为<code>123</code>，这样就不相等了，我们将后半部分除以 10 即可。</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x%<span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i &lt; x &#123;</span><br><span class="line">i = i * <span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">x /= <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x == i || x == i/<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :5.1 MB, 在所有 Go 提交中击败了 65.52%的用户</p></blockquote><hr><p><strong>PS:</strong> <font color="red">执行速度感觉是和网速有关的，如果你觉得你的程序够快，就多提交几次。上面思路二的代码一开始 40 多秒。</font></p><hr><h3 id="13-罗马数字转整数">13. 罗马数字转整数</h3><blockquote><h5 id="题目描述">题目描述</h5><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br></pre></td></tr></table></figure><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure></blockquote><h4 id="解题思路">解题思路</h4><ul><li>将罗马数字对应值放入哈希表中，注意哈希表 key 类型，因为字符串通过<code>s[i]</code>的方式取出来是对应的 ASCII ，所以哈希表的 key 最好使用<code>byte</code>类型。</li><li>定义一个变量记录当前罗马数字，循环字符串，依次相加，判断定义的变了是否小于当前相加的罗马数字，是即减去记录值的二倍。</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">roman := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>,</span><br><span class="line"><span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>,</span><br><span class="line"><span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>,</span><br><span class="line"><span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>,</span><br><span class="line"><span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>,</span><br><span class="line"><span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">index := <span class="number">999</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">this := roman[s[i]]</span><br><span class="line"><span class="keyword">if</span> index &lt; this &#123;</span><br><span class="line">sum = sum - index*<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">sum += this</span><br><span class="line">index = this</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :4 ms, 在所有 Go 提交中击败了 97.65%的用户<br>内存消耗 :3 MB, 在所有 Go 提交中击败了 45.05%的用户</p></blockquote><h3 id="14-最长公共前缀">14. 最长公共前缀</h3><blockquote><h5 id="题目描述">题目描述</h5><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 &quot;&quot;。<br>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></blockquote><h5 id="解题思路">解题思路</h5><ul><li>使用双循环的方式，取出第一个字符串的的一个字符，依次判断是否与剩余字符串的第一个字符相等</li><li>不相等或者剩余字符串长度不够时返回</li><li>如果双循环没有返回公共前缀则表示只传入了一个字符串，直接返回即可</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(strs[<span class="number">0</span>]); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(strs); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="built_in">len</span>(strs[j]) || strs[j][i] != strs[<span class="number">0</span>][i] &#123;</span><br><span class="line"><span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.5 MB, 在所有 Go 提交中击败了 35.75%的用户</p></blockquote><h3 id="20-有效的括号">20. 有效的括号</h3><blockquote><h5 id="题目描述">题目描述</h5><p>给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。<br>示例 1:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 示例 2:</span><br></pre></td></tr></table></figure><blockquote><p>输入: “()[]{}”<br>输出: true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 3:</span><br></pre></td></tr></table></figure><p>输入: “(]”<br>输出: false</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 示例 4:</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>输入: “([)]”<br>输出: false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入: “{[]}”<br>输出: true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 解题思路</span><br><span class="line"></span><br><span class="line">* 使用栈的特效，后进先出，匹配到右括号时去查询栈最后一个是否是相对应的左括号，如果是则从栈中去除，不是则返回 false</span><br><span class="line">* 最后判断剩余栈长度是否为 0</span><br><span class="line">* 使用切片模仿栈操作</span><br><span class="line"></span><br><span class="line">##### 示例代码</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;go</span><br><span class="line">func isValid(s string) bool &#123;</span><br><span class="line">brackets :&#x3D; map[int32]int32&#123;</span><br><span class="line">&#39;)&#39;: &#39;(&#39;,</span><br><span class="line">&#39;&#125;&#39;: &#39;&#123;&#39;,</span><br><span class="line">&#39;]&#39;: &#39;[&#39;,</span><br><span class="line">&#125;</span><br><span class="line">list :&#x3D; []int32&#123;&#125;</span><br><span class="line">for _, v :&#x3D; range s &#123;</span><br><span class="line">if v &#x3D;&#x3D; &#39;(&#39; || v &#x3D;&#x3D; &#39;&#123;&#39; || v &#x3D;&#x3D; &#39;[&#39; &#123;</span><br><span class="line">list &#x3D; append(list, v)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">l :&#x3D; len(list) - 1</span><br><span class="line">if len(list) !&#x3D; 0 &amp;&amp; list[l] &#x3D;&#x3D; brackets[v] &#123;</span><br><span class="line">list &#x3D; list[:l]</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return len(list) &#x3D;&#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100.00%的用户<br>内存消耗 :2.1 MB, 在所有 Go 提交中击败了 33.87%的用户</p></blockquote><h3 id="21-合并两个有序链表">21.合并两个有序链表</h3><blockquote><h5 id="题目描述">题目描述</h5><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></blockquote><h5 id="解题思路">解题思路</h5><ul><li>判断两个链表哪一个较小，然后递归地决定下一个添加到结果里的值。</li><li>判断两个链表是否为空，为空直接返回</li></ul><h5 id="示例代码">示例代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">l1.Next = mergeTwoLists(l1.Next, l2)</span><br><span class="line"><span class="keyword">return</span> l1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">l2.Next = mergeTwoLists(l1, l2.Next)</span><br><span class="line"><span class="keyword">return</span> l2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行结果">运行结果</h5><blockquote><p>执行用时 :0 ms, 在所有 Go 提交中击败了 100%的用户<br>内存消耗 :2.6 MB, 在所有 Go 提交中击败了 35.89%的用户</p></blockquote><h3 id="返回总目录">返回总目录</h3><p><a href="https://www.jinjianh.com/leetcode.html">日刷leetcode–简单版</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【go 语言圣经】练习答案 -- 目录篇 (关闭)</title>
      <link href="/articles/2019/06/16/1560663440490.html"/>
      <url>/articles/2019/06/16/1560663440490.html</url>
      
        <content type="html"><![CDATA[<h2 id="go语言圣经-the-go-programming-language-练习题答案">go语言圣经(The Go Programming Language)练习题答案</h2><h3 id="前言">前言</h3><p>go语言圣经是一本go入门非常不错的书籍，翻译至The Go Programming Language，本文记录该书章节后练习题答案</p><ul><li><a href="https://github.com/ThomasHuke/books/blob/master/gopl-zh.pdf">中文pdf获取地址1</a>  <a href="https://books.studyGolang.com/download/gopl-zh.pdf">中文pdf获取地址2</a></li><li><a href="https://github.com/KeKe-Li/book/blob/master/Go/The.Go.Programming.Language.pdf">英文原版获取地址</a></li><li><a href="https://https://weidian.com/item.html?itemID=2176920472">中文实体书获取地址</a> (一个还不赖的盗版书网站)</li><li>由于在书写过程中跟换了博客地址，所以你想阅读所有的需要同时关注两个博客</li><li>1-3章请前往我的<a href="https://blog.csdn.net/q1576962841">CSDN</a>查看</li><li>4-13章请关注我的<a href="https://www.jinjianh.com">个人博客(金戋博客)</a>或<a href="https://hacpai.com/member/jinjianh/articles">黑客派</a>查看。</li></ul><h3 id="目录">目录</h3><ul><li><p><a href="https://blog.csdn.net/q1576962841/article/details/85162346">【go语言圣经】练习答案–第一章</a> （完结）</p></li><li><p><a href="https://blog.csdn.net/q1576962841/article/details/85163080">【go语言圣经】练习答案–第二章</a> （完结）</p></li><li><p><a href="https://blog.csdn.net/q1576962841/article/details/86084461">【go语言圣经】练习答案–第三章</a> （完结）</p></li><li><p><a href="/articles/2019/06/10/1560159392016.html">【go语言圣经】练习答案–第三章(3.10-3.13)</a> （完结）</p></li><li><p><a href="/articles/2019/06/12/1560331304695.html">【go语言圣经】练习答案 – 第四章(更新中)</a></p></li></ul><p>此贴关闭–400多页的书我看不下去了:huaji:，因为我懒</p><p>查看剩余部分习题请移步<a href="https://www.cnblogs.com/taoshihan/p/8677343.html">[日常] Go语言圣经前言</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker导出mysql数据</title>
      <link href="/articles/2019/06/11/1560267833958.html"/>
      <url>/articles/2019/06/11/1560267833958.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  前几天无意中在社区看到一个帖子（<a href="https://hacpai.com/article/1553941852324">记一次清空数据仓库的过程</a>），讲的是自己无意中删库的经历。如文中所讲，大多时候删库这件事我们只是耳闻，并没有遇到过，可要是万一呢，到时候恐怕是追悔莫及，而且mysql也没有oracle的恢复机制，所以备份就成了一个非常有必要的操作。</p><p>  由于没有相关操作经验，所以从零开始讲如何数据，毕竟我还是比较珍惜我的小博客的。</p><h1 id="具体操作">具体操作</h1><p>  以前也导出过sql文件，但是都是直接用Navicat导出就完事了，但是这次我想实现的是自动备份，最好写成脚本的方式。</p><p>  基本思路：使用命令将数据库数据从docker容器中导出来，以时间戳命名。最多保持7天，过期文件自动删除。</p><h3 id="导出mysql数据">导出mysql数据</h3><h4 id="间接导出">间接导出</h4><p>  mysql 导出数据的命令还是蛮简单的：<code>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</code>，但这是linux里面执行的，我们的放在docker里面，所以要先进入容器，然后执行上述命令。然后你就会惊讶的发现，导出的文件在你的容器里面，然后你再从容器里面copy到你的主机上。这样做会在容器上产生大量sql文件，写定时任务是需要及时清理。</p><h4 id="直接导出">直接导出</h4><p>  上述方法是可行的，但是过于麻烦，有没有一步到位的呢？很显然是有的，命令是这个样子的：<code>docker exec -it [docker容器名称/ID] mysqldump -u[数据库用户名] -p[数据库密码] [数据库名称] &gt; [导出表格路径]</code>，比如我的<code>docker exec -it mysql mysqldump -uroot -p123456 solo &gt; /var/www/solo.sql</code>。没有报错的话，导出的数据库文件就会到你指定的目录下了。</p><h3 id="写成脚本方式运行">写成脚本方式运行</h3><p>博主是不会写Shell脚本的，所以现学了下，参考<a href="https://github.com/qinjx/30min_guides/blob/master/shell.md">Shell脚本编程30分钟入门</a></p><blockquote><p>间接导出(间接导出时请先创建相关文件目录)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -i mysql bash&lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># solo 为数据库的名称</span></span><br><span class="line"> XXX为数据库密码</span><br><span class="line">mysqldump -uroot -pXXX solo &gt; /mysqlData/$(date +%Y%m%d).sql</span><br><span class="line"><span class="comment">#删除超过1天的数据</span></span><br><span class="line">find /mysqlData/ -mtime +1 -<span class="built_in">type</span> f | xargs rm -rf</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 将docker中的备份的数据拷贝到宿主机上。</span></span><br><span class="line">docker cp mysql:/mysqlData/$(date +%Y%m%d).sql /var/www/html/solo/sqlData/</span><br><span class="line"><span class="comment">#删除超过7天的数据</span></span><br><span class="line">find /var/www/html/solo/sqlData -mtime +7 -<span class="built_in">type</span> f | xargs rm -rf</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>直接导出(导出时<code>exec</code>不需指定参数<code>-it</code>)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 进入你要保持数据的文件</span></span><br><span class="line"><span class="built_in">cd</span> /var/www/html/solo/sqlData</span><br><span class="line"><span class="comment"># 导出今日的sql</span></span><br><span class="line">docker <span class="built_in">exec</span> mysql mysqldump -uroot -p123123 solo &gt;`date +%Y%m%d%H%M%S`.sql</span><br><span class="line"><span class="comment"># 删除7天前的sql(+号后面跟天数,N天前,find后指定目录)</span></span><br><span class="line">find . -mtime +7 -<span class="built_in">type</span> f | xargs rm -rf</span><br></pre></td></tr></table></figure><h3 id="后记">后记</h3><p>  导出的sql文件中会出现一些版本备注信息等，这样的sql文件导入时有时会出现问题，会报错，导入之前需要将sql文件中的无用信息删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*!40101 SET @OLD_CHARACTER_SET_CLIENT&#x3D;@@CHARACTER_SET_CLIENT *&#x2F;;</span><br><span class="line">&#x2F;*!40101 SET @OLD_CHARACTER_SET_RESULTS&#x3D;@@CHARACTER_SET_RESULTS *&#x2F;;</span><br><span class="line">&#x2F;*!40101 SET @OLD_COLLATION_CONNECTION&#x3D;@@COLLATION_CONNECTION *&#x2F;;</span><br><span class="line">&#x2F;*!40101 SET NAMES utf8 *&#x2F;;</span><br><span class="line">&#x2F;*!40103 SET @OLD_TIME_ZONE&#x3D;@@TIME_ZONE *&#x2F;;</span><br><span class="line">&#x2F;*!40103 SET TIME_ZONE&#x3D;&#39;+00:00&#39; *&#x2F;;</span><br><span class="line">&#x2F;*!40014 SET @OLD_UNIQUE_CHECKS&#x3D;@@UNIQUE_CHECKS, UNIQUE_CHECKS&#x3D;0 *&#x2F;;</span><br><span class="line">&#x2F;*!40014 SET @OLD_FOREIGN_KEY_CHECKS&#x3D;@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS&#x3D;0 *&#x2F;;</span><br><span class="line">&#x2F;*!40101 SET @OLD_SQL_MODE&#x3D;@@SQL_MODE, SQL_MODE&#x3D;&#39;NO_AUTO_VALUE_ON_ZERO&#39; *&#x2F;;</span><br><span class="line">&#x2F;*!40111 SET @OLD_SQL_NOTES&#x3D;@@SQL_NOTES, SQL_NOTES&#x3D;0 *&#x2F;;</span><br></pre></td></tr></table></figure><p>这样的内容在sql中还不是一两句，到处都是。这里提供一段正则，可快速匹配到sql文件中所有<code>/*!40101XXXXX*/;</code>，通过正则<code>\/\*\![0-9]+\s[\s\S]+?\s\*\/;\n</code>实现快速替换。<br>替换完后的效果如下所示，多舒服。<br><img src="https://cdn.inkdp.cn/img/image-3766354f.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> docker </tag>
            
            <tag> Solo </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言圣经练习解答 -- 第三章</title>
      <link href="/articles/2019/06/10/1560159392016.html"/>
      <url>/articles/2019/06/10/1560159392016.html</url>
      
        <content type="html"><![CDATA[<h2 id="go语言圣经-the-go-programming-language-第三章练习题答案">go语言圣经(The Go Programming Language)第三章练习题答案</h2><h3 id="前言">前言</h3><p>go语言圣经是一本go入门非常不错的书籍，翻译至The Go Programming Language，本文记录该书章节后练习题答案</p><ul><li><a href="https://github.com/ThomasHuke/books/blob/master/gopl-zh.pdf">中文pdf获取地址1</a>  <a href="https://books.studyGolang.com/download/gopl-zh.pdf">中文pdf获取地址2</a></li><li><a href="https://github.com/KeKe-Li/book/blob/master/Go/The.Go.Programming.Language.pdf">英文原版获取地址</a></li><li><a href="https://https://weidian.com/item.html?itemID=2176920472">中文实体书获取地址</a> (一个还不赖的盗版书网站)</li><li>本文从第三章练习3.10开始，前面的请查看移步我的<a href="https://blog.csdn.net/q1576962841">CSDN</a></li></ul><h4 id="练习-3-10：-编写一个非递归版本的comma函数-使用bytes-buffer代替字符串链接操作">练习 3.10： 编写一个非递归版本的comma函数，使用bytes.Buffer代替字符串链接操作。</h4><blockquote><p>解题思路:</p></blockquote><ul><li>参考书中的comma函数，即实现基本的为数字添加逗号分隔符</li><li>确定了第一个逗号位置后，每隔三个数字添加一个逗号，最后末尾会多出来一个逗号，去掉即可</li><li>使用bytes.Buffe而非&quot;+&quot;</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">comma</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">    l := <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        buffer.WriteString(<span class="keyword">string</span>(s[i]))</span><br><span class="line"><span class="comment">// 取余3可以得到第一个插入逗号的位置,后面依次+3即可,末尾不加&quot;,&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">3</span> == l%<span class="number">3</span> &#123;  <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">3</span> == l%<span class="number">3</span> &amp;&amp; i != l<span class="number">-1</span> &#123;</span><br><span class="line">            buffer.WriteString(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s = buffer.String()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">#### 练习 <span class="number">3.11</span>： 完善comma函数，以支持浮点数处理和一个可选的正负号的处理。</span><br><span class="line">&gt; 解题思路:</span><br><span class="line"></span><br><span class="line">* 将整数部分分离处理处理即可，整树部分与<span class="number">3.10</span>相同</span><br><span class="line">* 首先判读第一个字符是否为<span class="string">&quot;+/-&quot;</span>，如果是，将符号添加到buffer中，然后去掉原字符串的第一个字符。</span><br><span class="line">* 通过小数点将字符串分隔为两个数组，下标为<span class="number">0</span>的为整数部分，如果存在小数点则下标为<span class="number">1</span>的为小数部分</span><br><span class="line">* 处理完整数部分后判断是否存在小数部分，存在着添加到buffer中</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">// 判断是否有正负号</span></span><br><span class="line"><span class="string">// 判断是否有小数部分</span></span><br><span class="line"><span class="string">func comma(s string) string &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    var buffer bytes.Buffer</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 获取正负号</span></span><br><span class="line"><span class="string">    if s[0] == &#x27;-&#x27; || s[0] == &#x27;+&#x27; &#123;</span></span><br><span class="line"><span class="string">        // 将符号添加到返回的字符串中</span></span><br><span class="line"><span class="string">        buffer.WriteByte(s[0])</span></span><br><span class="line"><span class="string">        s = s[1:]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 分离整数部分与小数部位</span></span><br><span class="line"><span class="string">    arr := strings.Split(s, &quot;.&quot;)</span></span><br><span class="line"><span class="string">    s = arr[0]</span></span><br><span class="line"><span class="string">    l := len(s)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 格式整数部分</span></span><br><span class="line"><span class="string">    for i := 0; i &lt; len(s); i++ &#123;</span></span><br><span class="line"><span class="string">        buffer.WriteString(string(s[i]))</span></span><br><span class="line"><span class="string">        // 取余3可以得到第一个插入逗号的位置,后面依次+3即可,末尾不加&quot;,&quot;</span></span><br><span class="line"><span class="string">        if (i+1)%3 == l%3 &amp;&amp; i != l-1 &#123;</span></span><br><span class="line"><span class="string">            buffer.WriteString(&quot;,&quot;)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 存在小数部分</span></span><br><span class="line"><span class="string">    if len(arr) &gt; 1 &#123;</span></span><br><span class="line"><span class="string">        buffer.WriteString(&quot;.&quot;)</span></span><br><span class="line"><span class="string">        buffer.WriteString(arr[1])</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    s = buffer.String()</span></span><br><span class="line"><span class="string">    return s // 末尾会多一个逗号,去掉 + &quot;.&quot; + arr[1]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="练习-3-12：-编写一个函数-判断两个字符串是否是是相互打乱的-也就是说它们有着相同的字符-但是对应不同的顺序">练习 3.12： 编写一个函数，判断两个字符串是否是是相互打乱的，也就是说它们有着相同的字符，但是对应不同的顺序。</h4><blockquote><p>解题思路:</p></blockquote><ul><li>拥有相同字符那么他们长度肯定是相同的</li><li>每个字符都有自己的Unicode码，记录每个字符串中每个字符出现的次数</li><li>循环记录的数组，对比个数是否相同</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isReverse</span><span class="params">(a, b <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 长度不一样直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于记录每个字符串出现的次数</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">    n := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// 以字符串Unicode码作为map的Key</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        m[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">    n[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断相同下标值是否相同</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="keyword">if</span> n[i] != v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习-3-13：-编写kb-mb的常量声明-然后扩展到yb">练习 3.13： 编写KB、MB的常量声明，然后扩展到YB。</h4><blockquote><p>1.简单粗暴法(没有解题思路)</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    KB = <span class="number">1000</span></span><br><span class="line">    MB = KB * KB</span><br><span class="line">    GB = MB * KB</span><br><span class="line">    TB = GB * KB</span><br><span class="line">    PB = TB * KB</span><br><span class="line">    EB = PB * KB</span><br><span class="line">    ZB = EB * KB</span><br><span class="line">    YB = ZB * KB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>2.结合书中例子定义KiB到YiB解决</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KiB &#x3D; 1024,       KB &#x3D; 1000</span><br><span class="line">MiB &#x3D; 1048576,    MB &#x3D; 1000000</span><br><span class="line">GiB &#x3D; 1073741824, GB&#x3D; 1000000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>KiB减去24就是KB</li><li>MIB减去48576就是MB</li><li>…</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _   = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    KiB  <span class="comment">// 1024</span></span><br><span class="line">    MiB  <span class="comment">// 1048576</span></span><br><span class="line">    GiB  <span class="comment">// 1073741824</span></span><br><span class="line">    TiB  <span class="comment">// 1099511627776 (exceeds 1 &lt;&lt; 32)</span></span><br><span class="line">    PiB  <span class="comment">// 1125899906842624</span></span><br><span class="line">    EiB  <span class="comment">// 1152921504606846976</span></span><br><span class="line">    ZiB  <span class="comment">// 1180591620717411303424 (exceeds 1 &lt;&lt; 64)</span></span><br><span class="line">    YiB  <span class="comment">// 1208925819614629174706176</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    KB = <span class="number">1000</span></span><br><span class="line">    MB = MiB - MiB % (KB * KB)</span><br><span class="line">    GB = GiB - GiB % (MB * KB)</span><br><span class="line">    TB = TiB - TiB % (GB * KB)</span><br><span class="line">    PB = PiB - PiB % (TB * KB)</span><br><span class="line">    EB = EiB - EiB % (PB * KB)</span><br><span class="line">    ZB = ZiB - ZiB % (EB * KB)</span><br><span class="line">    YB = YiB - YiB % (ZB * KB)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>感觉第一种更加简单粗暴</p><p><a href="https://www.jinjianh.com/articles/2019/06/16/1560663440490.html">返回目录</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习 </tag>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未来的路</title>
      <link href="/articles/2019/06/07/1559921813174.html"/>
      <url>/articles/2019/06/07/1559921813174.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a94b2107791d9f8b94b8f71bccc3178a45c871714af7a6f47b51e59cde6df18b">b9cc9643baf4dcc59b37da2f24103eac78ceb97cb01de3f9b031fb8a518eb84f0450125e268d2ea508dad90d98a2a140adcf5f58e05cd09ebdcfa70931b94758c3d7d2ea18a701085442ef1db661f67afcd0db8cd9682003b0a556b118ba4b08c3c8dbcf8ae2b13f43ffa7cc6e7e8174dcc796244bc35e5154f0de6b7fa4c2fbcd1d14d5223c1c53c9adc636078b7d9b7f1c9278a6727d4c2c2acab0e2f1378a7b57a2b2bd24015fb4f9107bd5f91cd0c74e39f431436b4d910aa9b19755ee101fa9a14021ecc89ea1e17aadc17ec79558ed9750342019a5bbe8177f6812d4928da75c78296866cee84553bcbc717cc988453523cce624e4fe0151e4738ee34ba2a78e9b7ea1a4b1a1f322cfde01956a203966e1a941c57f6a9ad5f829c1e2858f377e251b7c058bde8202de694f0e48e6f62c68d49cafca4d4e76f266f6366e9a41a84be748d443fb70edbb2ad3c6bddc6a004b681fb12333550f379e56873175bc2bdd2c624ab7e47031b8c7ef00163abaf640ed6dab9717f705dd0f0170386ecee7f75c2e085a5292c17789491ceb03dcb22883e2117c2fd0da360178fca337a3dade2467c1c87dd94eed1958f3390d151b17a48df307c02b28219b4da1f04f056c3b5e3b173d0ab1d14b90d36d3df0b8a0540a0e9ac26a39532f4e8e559db0a9a5d927481c3acd49900ca413156caf39ce1fe25b71c9e49a99b008bd07df0b5c91ad8fa78ab662e917a8845c8d66de9365290f9998e7ce64fa03783fd39fa2092dc5961225994750421c475143d806d64cfbc0a8e1722fbe8b93fe245223554d8b6e23a75bfdaf65c29fe6b22f6379f5010bd636565258308bdd13bb782baccddab0c543e44cfd02ff4a0257f9bdb83c634323e45d0c0e0983cfacf6c4c082476394bb41a410c02b6f9f72e1ab1c9b397b642d34909886d10531c862bb4f54defaa9ef8d47c005bbb5caf45c1a2d46481f3e8a061e006acbb0be68f56103da0881913ff3ff60b48bf92badf1a36367c74d1500d92b0a49ab38f5277c664ac1b98de343a11a0f80e9a51e8409bca8aff05340370caa6540be87f741aad93f475ea34ecebfe99e1ca13764072469fab567508c44f8b2075d1356aa4a9946830942e50e8f62739673727f686d58581120df9d836675b063fc52c539f8c472d0f023caa26b4300c3a3f1f05781e2c95f0c82d38e180a499b9d86dfe86605d181a77644baac2310d6fbc3803a1ea77845cd42c9949a610fdf1ab21e2cf06a46467958d57f50f8ffc2752887e7bfa86f796eff554ccbb2bef82e516e2a8c6c3a9432c270c2bb9fffc8efaf641d87209cb2cd54e43092f1fb52ecfd76c14e1d1e25de2ad0665267401299a8bab6d929cbcb82cc1681dcb890f301d71e38044a426b5a3191a48a887a43d623ee75dcde7c16a4d7848278ee8c85560c3d1b37e5a7904682b2f1ddebcfa3cfdd48661e587c4c2baa8dec4da684270ea2964747e459f885c6e3a0a8f06218a19de4f50affe4c35a880678c7e6e05120c657cb505c5ce5b510e37c9fd9743de6e1f40883e05615cb7950271a0182f01ab84af86386257d4616a22dfa498054a5e6a6ea85eff9d009d327b8f66a23bf817cb94037ff4de97d1aebc046710a99261057c9d3be69c400bae9c091e1ade67c3bd659a776b12934045c6ba4c62f6adb95b799ada0dca58c459432a30b05e859a4fa8d55080d763295319cf641daab49aecb8ff9c7484c3c68e456be7e4d8f3dade5553245b4218c88cb8f71d850b9e96adc2a339a3ff71f1033b0f10362c4f2d184288f1f0f5d69925636914702a9f60e958028336bcd26ce43c89c8188a1dc418855452f28ce77f65bfd7785b69908fca6c048f4211b9e499721f0b9c9f35747d915a128fbf4357fae0e75036a43b4690b2e2e6dee6210c50ef5e4320ffe6675c867d983075fa4f9c03674ca0111a8a0ecb55a5cdb90aedc4f2bd251c2cb01b96c4f6cf53f92e843e58d62a1c65fc3c56138a7c1e74f8fe4cbb7e4b1d7008eaa2f604fe918eba54c100d98bac24650f11754c12e0b3d2e840a86240fdc6cd04ff36da5cddaf72ba714410b3fb078e4cf284a7d765128abfb49b0b3253ac7375a32a0a2ce174a10d8c673c68c3ec292f0e8680c556bc55e5b3a4a574a32a027a0acc76631861667efc7ccc33da66e2bc9e16332cf7c0cdf903dc6edf243d0993ecfb324c5dffb26c0a90732fe0ee2febbc8d0adecec9a9a54ddeb6fd12d1fff4fa5d4a551f04dee70aa6982f3813a5a3b36f0d8a9afa2b8032ae1d895173e88770e3b2ccff2faf9c9d7705c9e724f2eb8f3bc823fcdda4f0945e681ee313307a1ea3099eb9e4fce51d6681ba343383ffd106ec66728de714b162d9548b06be27bb2c707e056e76c9c167fb0465a23a9c2a09f3b158b1e2348a4fdae654273e4fcdaae3799e3d1b46e9be626a3a70b8349d96ac51ac2a6f3c443f7b778674938cdb333824fe954e40b7aeb713425ccd2762a3f6cbe49d4c9c89c818f2d3ae9cd5d029875b0e9a98214748b567075ed5919d08fad58e6e4b8f0eee7ade1010356601817553eebcb589caa07b6520607848ae837f662c0580384ef751dbc49b8cde674aa6d2fb029e7eec55d0d2f6ca6ef26cd1598c0ec7b5f72ad157644a8a299ec036b3e115d1ff0f96eae8dea28e10344cd9b40f94a838d5a6467b239f0b9f65246a114ad8a8240c5e5ed328a5981403589aac61838d54cc69312464d837a41dfbe5f0ff485ad</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">请输入密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS/Javascript实现Word Clock</title>
      <link href="/articles/2019/06/02/1559477290334.html"/>
      <url>/articles/2019/06/02/1559477290334.html</url>
      
        <content type="html"><![CDATA[<h3 id="无意中看到了一款锁屏效果-world-clock-感觉有点意思-就想着用前端来实现他">无意中看到了一款锁屏效果–world clock，感觉有点意思，就想着用前端来实现他。</h3><h3 id="实现这个效果主要需要实现两个部分">实现这个效果主要需要实现两个部分</h3><ul><li>时间元素旋转显示</li><li>时间自动旋转</li></ul><blockquote><p>实现元素旋转显示</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// <span class="selector-tag">li</span> 通用样式</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#777</span>;</span><br><span class="line">        <span class="attribute">list-style</span>: none;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">        <span class="attribute">text-transform</span>: lowercase;</span><br><span class="line">        <span class="attribute">transform-origin</span>: <span class="number">0</span> center;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">// <span class="selector-tag">li</span> 行内样式</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span>&#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>); &#125;</span><br><span class="line">``````</span><br><span class="line">### 每个<span class="selector-tag">li</span>根据实际位置，旋转度数不同，总的加起来360度就可以了</span><br><span class="line"></span><br><span class="line">&gt; 时间初始化与自动旋转</span><br><span class="line"></span><br><span class="line">* 每一个<span class="selector-tag">li</span>去做循环，等于当前日期值的<span class="selector-tag">li</span>旋转度数为0，小于的当前日期值为负，大于为正。</span><br><span class="line">```<span class="selector-tag">html</span></span><br><span class="line">&lt;!<span class="selector-tag">--</span> 当前月份为6月，所以6月对应的旋转角度为0，小于6月的为负，大于6月为正<span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;!<span class="selector-tag">--</span> 整个旋转度数为360度，<span class="selector-tag">-30</span>°与330°效果一致<span class="selector-tag">--</span>&gt;</span><br><span class="line">&lt;ul class=&quot;month&quot; id=&quot;month&quot;&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(-150deg); color: rgb(119, 119, 119);&quot;&gt;一月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(-120deg); color: rgb(119, 119, 119);&quot;&gt;二月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(-90deg); color: rgb(119, 119, 119);&quot;&gt;三月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(-60deg); color: rgb(119, 119, 119);&quot;&gt;四月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(-30deg); color: rgb(119, 119, 119);&quot;&gt;五月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(0deg); color: rgb(255, 255, 255);&quot;&gt;六月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(30deg); color: rgb(119, 119, 119);&quot;&gt;七月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(60deg); color: rgb(119, 119, 119);&quot;&gt;八月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(90deg); color: rgb(119, 119, 119);&quot;&gt;九月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(120deg); color: rgb(119, 119, 119);&quot;&gt;十月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(150deg); color: rgb(119, 119, 119);&quot;&gt;十一月&lt;/li&gt;</span><br><span class="line">    &lt;li style=&quot;transform: rotate(180deg); color: rgb(119, 119, 119);&quot;&gt;十二月&lt;/li&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ul</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="源码如下">源码如下</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Word Clock<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://code.jquery.com/jquery-latest.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        width: 100%;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    div &#123;</span><br><span class="line">        height: 1000px;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ul &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 500px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    li &#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#777</span>;</span></span><br><span class="line">        list-style: none;</span><br><span class="line">        width: 150px;</span><br><span class="line">        text-transform: lowercase;</span><br><span class="line">        transform-origin: 0 center;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.month</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">        padding: 0 0 0 80px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.day</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">        padding: 0 0 0 130px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.week</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">        padding: 0 0 0 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.hour</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">        padding: 0 0 0 260px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.minute</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">        padding: 0 0 0 325px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.second</span> &gt; <span class="selector-tag">li</span> &#123;</span></span><br><span class="line">        padding: 0 0 0 410px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;month&quot;</span> <span class="attr">id</span>=<span class="string">&quot;month&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(-150deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>一月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(-120deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>二月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(-90deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>三月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(-60deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>四月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(-30deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>五月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(0deg); color: rgb(255, 255, 255);&quot;</span>&gt;</span>六月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(30deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>七月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(60deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>八月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(90deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>九月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(120deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>十月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(150deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>十一月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;transform: rotate(180deg); color: rgb(119, 119, 119);&quot;</span>&gt;</span>十二月<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;day&quot;</span> <span class="attr">id</span>=<span class="string">&quot;day&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;week&quot;</span> <span class="attr">id</span>=<span class="string">&quot;week&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;hour&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hour&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;minute&quot;</span> <span class="attr">id</span>=<span class="string">&quot;minute&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">mGetDate</span>(<span class="params">year, month</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(year, month, <span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> d.getDate();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">numberToChinese</span>(<span class="params">num</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> chineseNum = <span class="string">&#x27;零一二三四五六七八九十&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> chinese = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (num &lt;= <span class="number">10</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> chineseNum.split(<span class="string">&#x27;&#x27;</span>)[num]</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">20</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="string">&#x27;十&#x27;</span> + chineseNum.split(<span class="string">&#x27;&#x27;</span>)[num - <span class="number">10</span>]</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (num % <span class="number">10</span> == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> chineseNum.split(<span class="string">&#x27;&#x27;</span>)[num / <span class="number">10</span>] + <span class="string">&#x27;十&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> chineseNum.split(<span class="string">&#x27;&#x27;</span>)[<span class="built_in">parseInt</span>(num / <span class="number">10</span>)] + <span class="string">&#x27;十&#x27;</span> + chineseNum.split(<span class="string">&#x27;&#x27;</span>)[<span class="built_in">parseInt</span>(num % <span class="number">10</span>)]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> month = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;month&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> day = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;day&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> week = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;week&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> hour = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;hour&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> minute = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;minute&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> second = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;second&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> html = <span class="string">``</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 生成月html</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        html += <span class="string">`&lt;li&gt;`</span> + numberToChinese(i + <span class="number">1</span>) + <span class="string">`月&lt;/li&gt;`</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    month.innerHTML = html;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//  生成日html</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> months = myDate.getMonth() + <span class="number">1</span>;   <span class="comment">//月份从0开始获取，所以需要加1</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> year = myDate.getYear();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(year, months, <span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> days = d.getDate();</span></span><br><span class="line"><span class="javascript">    html = <span class="string">``</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; days; i++) &#123;</span></span><br><span class="line"><span class="javascript">        html += <span class="string">`&lt;li&gt;`</span> + numberToChinese(i + <span class="number">1</span>) + <span class="string">`日&lt;/li&gt;`</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    day.innerHTML = html;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 星期html</span></span></span><br><span class="line"><span class="javascript">    html = <span class="string">``</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">            html += `<span class="tag">&lt;<span class="name">li</span>&gt;</span>星期日<span class="tag">&lt;/<span class="name">li</span>&gt;</span>`</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            html += <span class="string">`&lt;li&gt;星期`</span> + numberToChinese(i + <span class="number">1</span>) + <span class="string">`&lt;/li&gt;`</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    week.innerHTML = html;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 时html</span></span></span><br><span class="line"><span class="javascript">    html = <span class="string">``</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        html += <span class="string">`&lt;li&gt;`</span> + numberToChinese(i) + <span class="string">`时&lt;/li&gt;`</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    hour.innerHTML = html;</span><br><span class="line"><span class="javascript">    <span class="comment">//分html</span></span></span><br><span class="line"><span class="javascript">    html = <span class="string">``</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        html += <span class="string">`&lt;li&gt;`</span> + numberToChinese(i) + <span class="string">`分&lt;/li&gt;`</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    minute.innerHTML = html;</span><br><span class="line"><span class="javascript">    <span class="comment">//秒html</span></span></span><br><span class="line"><span class="javascript">    html = <span class="string">``</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        html += <span class="string">`&lt;li&gt;`</span> + numberToChinese(i) + <span class="string">`秒&lt;/li&gt;`</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    second.innerHTML = html;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">setTime</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取当前时间</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> numArray = [myDate.getMonth() + <span class="number">1</span>, myDate.getDate(), myDate.getDay(), myDate.getHours() + <span class="number">1</span>, myDate.getMinutes() + <span class="number">1</span>, myDate.getSeconds() + <span class="number">1</span>];<span class="comment">// 月,日,星期,时,分,秒</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> l = <span class="number">6</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 遍历ul实现时间赋值与更改</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;ul&quot;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> length = $(<span class="built_in">this</span>).children().length</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> deg = <span class="string">&quot;rotate(&quot;</span> + (j + <span class="number">1</span> - numArray[<span class="number">6</span> - l]) * <span class="number">360</span> / length + <span class="string">&quot;deg)&quot;</span></span></span><br><span class="line"><span class="javascript">                $(<span class="built_in">this</span>).find(<span class="string">&quot;li&quot;</span>).eq(j).css(<span class="string">&quot;transform&quot;</span>, deg);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (j + <span class="number">1</span> - numArray[<span class="number">6</span> - l] == <span class="number">0</span> || (l == <span class="number">4</span> &amp;&amp; j == length - <span class="number">1</span> &amp;&amp; numArray[<span class="number">6</span> - l] == <span class="number">0</span>)) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    $(<span class="built_in">this</span>).find(<span class="string">&quot;li&quot;</span>).eq(j).css(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;#fff&quot;</span>);</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="built_in">this</span>).find(<span class="string">&quot;li&quot;</span>).eq(j).css(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;#777&quot;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTime()</span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.setInterval(<span class="string">&quot;setTime()&quot;</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="最后的效果">最后的效果</h3><p><img src="https://cdn.inkdp.cn/img/image-7492af1c" alt="image.png"></p><h3 id="写在最后-时间直接使用jq更改很僵硬-可以通过css动画实现">写在最后，时间直接使用jq更改很僵硬，可以通过CSS动画实现。</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about.html"/>
      <url>/about.html</url>
      
        <content type="html"><![CDATA[<h3 id="我是谁">我是谁</h3><ul><li>墨殇(InkDP)，一个间歇性自闭，持续性没心没肺的逗比青年</li><li>一个耿直的重庆汉子，毕业后为了生计选择南下成为一名广漂(已经回来啦)</li><li>计算机专业毕业的我，如今成为了一名专职码农，在一家外包公司担任Golang开发</li><li>自愈能力极强，每天都负能量爆棚，却依旧能嘻嘻哈哈的笑着</li><li>学习能力极强，但大多时候都是被动学习，很少主动学习心得东西</li><li>拖延症晚起患者，但能分期事情轻重缓急</li><li>…</li></ul><h3 id="技能树">技能树</h3><p>作为后端开发的我，最开始接触的是PHP，目前主语言是Go，平时无聊的时候也会玩玩前端，还是积累了一些前端的技术栈(html，css，js，vue，小程序)</p><h3 id="爱好">爱好</h3><p>爱打游戏，尤其是MOBA类游戏，最爱LOL，有空一起开黑呀(班德尔城：金戋丶)，买了switch，和一些游戏卡，快一年了塞尔达至今未通关，持续性吃灰。晚上饭后会看会儿书，书单很杂，基本都是来啥看啥。不健身，但偶尔也会心血来潮去跑跑步，做做俯卧撑或仰卧起坐。爱打羽毛球，但是好久没打过了。喜欢爬山，也快一年多没爬了，想念歌乐山。</p><h3 id="联系我">联系我</h3><ul><li>QQ：1576962841</li><li>微信：InkDPP</li><li>GitHub：<a href="https://github.com/gooohlan">https://github.com/gooohlan</a></li><li>技术博客：<a href="https://inkdp.cn/">https://inkdp.cn/</a></li><li>Email: <a href="mailto:me@inkdp.cn">me@inkdp.cn</a></li></ul><h3 id="个人简历">个人简历</h3><p>后面补</p>]]></content>
      
      
      
        <tags>
            
            <tag> 关于我 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
