---
title: Redis初探
toc_number: false
date: 2022-10-06 20:03:18
updated: 2022-10-06 20:03:18
tags:
categories:
cover:
keywords:
description:
---

# Redis初探

带着问题去寻找答案往往会是最好的学习方法，开始探究前，先问几个关于Redis的问题：

- Redis有哪些数据结构，其底层是什么
- Redis持久化机制
- Redis为什么是单进程的？为什么快？
- Redis如何保证的原子性
- Redis过期策略及其淘汰机制
- Redis的瓶颈及解决方案

由简入难，一个一个的研究，对每个关键点做到知其然并知其所以然

## Redis有哪些数据结构，其底层结构是什么

`redis`的常见的5种数据结构，分别是`string(字符串)`、`list(列表)`、`hash(哈希)`、`set(集合)`、`sorted set(有序集合)`。这些数据结构是暴露给外部接口调用的。

底层的数据结构有6种：`robj`、`sds(简单动态字符串)`、`dict(字典)`、`intset(整数集合)`、`skiplist(跳跃表)`、`ziplist(压缩列表)`、`quicklist(快速列表)`。

关于底层数据结构的很多，这里就不赘述了：

- [Redis的五种数据结构的底层实现原理(推荐阅读)](https://blog.csdn.net/a745233700/article/details/113449889)

- [一文理解Redis底层数据结构](https://www.modb.pro/db/71948)
- [深入了解Redis底层数据结构](https://juejin.cn/post/6844903936520880135)

对于常用的数据结构已经有了理解，那么不常用的呢？

- Streams

  Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。

  简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。

  而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。

- Geospatial

  可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？

- HyperLogLog

  供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV


- Bitmaps

  位图是支持按 bit 位来存储信息，可以用来实现 **布隆过滤器（BloomFilter）**

- Bitfields

  将 Redis 字符串视为一个位数组，并且能够处理具有不同位宽和任意非（必要）对齐偏移量的特定整数字段。实际上，使用此命令可以将位偏移量为1234的带符号5位整数设置为特定值，从偏移量4567中检索31位无符号整数。类似地，该命令处理指定整数的递增和递减，提供保证和良好指定的溢出和下溢行为，用户可以配置

## Redis持久化机制

Redis支持两种方式的持久化：

- RDB: 在指定的时间间隔内对你的数据进行快照存储
- AOF：记录每次对服务器写的操作，当服务器重启时会重新执行这些命令来回复原始的数据

相关定义网上的文章很多，在这里不做多余的赘述，简单说下优缺点

### RDB vs AOF

#### RDB优点

- RDB是一个紧凑压缩的二进制文件，代表Redis在某一个时间点上的数据快照，非常适合用于备份、全量复制等场景。
- RDB对灾难恢复、数据迁移非常友好，RDB文件可以转移至任何需要的地方并重新加载。
- RDB是Redis数据的内存快照，数据恢复速度较快，相比于AOF的命令重放有着更高的性能。

#### RDB缺点

- RDB方式无法做到实时或秒级持久化。因为持久化过程是通过fork子进程后由子进程完成的，子进程的内存只是在fork操作那一时刻父进程的数据快照，而fork操作后父进程持续对外服务，内部数据时刻变更，子进程的数据不再更新，两者始终存在差异，所以无法做到实时性。
- RDB持久化过程中的fork操作，会导致内存占用加倍，而且父进程数据越多，fork过程越长。
- Redis请求高并发可能会频繁命中save规则，导致fork操作及持久化备份的频率不可控；
- RDB文件有文件格式要求，不同版本的Redis会对文件格式进行调整，存在老版本无法兼容新版本的问题。

#### AOF优点

- AOF持久化有更好的实时性，我们可以选择三种不同的方式（appendfsync）：no、every second、always，every second作为默认的策略具有最好的性能，极端情况下可能会丢失一秒的数据。
- AOF文件只有append操作，无复杂的seek等文件操作，没有损坏风险。即使最后写入数据被截断，也很容易使用`redis-check-aof`工具修复；
- 当AOF文件变大时，Redis可在后台自动重写。重写过程中旧文件会持续写入，重写完成后新文件将变得更小，并且重写过程中的增量命令也会append到新文件。
- AOF文件以已于理解与解析的方式包含了对Redis中数据的所有操作命令。即使不小心错误的清除了所有数据，只要没有对AOF文件重写，我们就可以通过移除最后一条命令找回所有数据。
- AOF已经支持混合持久化，文件大小可以有效控制，并提高了数据加载时的效率。

#### AOF缺点

- 对于相同的数据集合，AOF文件通常会比RDB文件大；
- 在特定的fsync策略下，AOF会比RDB略慢。一般来讲，fsync_every_second的性能仍然很高，fsync_no的性能与RDB相当。但是在巨大的写压力下，RDB更能提供最大的低延时保障。
- 在AOF上，Redis曾经遇到一些几乎不可能在RDB上遇到的罕见bug。一些特殊的指令（如BRPOPLPUSH）导致重新加载的数据与持久化之前不一致，Redis官方曾经在相同的条件下进行测试，但是无法复现问题。


#### AOF混合持久

**AOF文件重写的流程是什么？听说Redis支持混合持久化，对AOF文件重写有什么影响？**

从4.0版本开始，Redis在AOF模式中引入了混合持久化方案，即：纯AOF方式、RDB+AOF方式，这一策略由配置参数`aof-use-rdb-preamble`（使用RDB作为AOF文件的前半段）控制，默认关闭(no)，设置为yes可开启。所以，在AOF重写过程中文件的写入会有两种不同的方式。当`aof-use-rdb-preamble`的值是：

- no：按照AOF格式写入命令，与4.0前版本无差别；
- yes：先按照RDB格式写入数据状态，然后把重写期间AOF缓冲区的内容以AOF格式写入，文件前半部分为RDB格式，后半部分为AOF格式

结合源码（6.0版本，源码太多这里不贴出，可参考`aof.c`）及参考资料，绘制AOF重写（BGREWRITEAOF）流程图：

![E5CAEE8F-32FB-4A33-A09E-39633394A7D5](https://cdn.inkdp.cn/img/20221007192359.png)

结合上图，总结一下AOF文件重写的流程：

- rewriteAppendOnlyFileBackground开始执行，检查是否有正在进行的AOF重写或RDB持久化子进程：如果有，则退出该流程；如果没有，则继续创建接下来父子进程间数据传输的通信管道。执行fork()操作，成功后父子进程分别执行不同的流程。
- 父进程：
  - 记录子进程信息（pid）、时间戳等；
  - 继续响应其他客户端请求；
  - 收集AOF重写期间的命令，追加至aof_rewrite_buffer；
  - 等待并向子进程同步aof_rewrite_buffer的内容；
- 子进程：
  - 修改当前进程名称，创建重写所需的临时文件，调用rewriteAppendOnlyFile函数；
  - 根据`aof-use-rdb-preamble`配置，以RDB或AOF方式写入前半部分，并同步至硬盘；
  - 从父进程接收增量AOF命令，以AOF方式写入后半部分，并同步至硬盘；
  - 重命名AOF文件，子进程退出。

### 从持久化中恢复数据

数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？

其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：

![image-20221007193840977](https://cdn.inkdp.cn/img/20221007193841.png)

Redis 4.0版本后AOF支持了混合持久化，加载AOF文件需要考虑版本兼容性，所以回复数据流程发生了变化：

![image-20221007203352211](https://cdn.inkdp.cn/img/20221007203352.png)

在AOF方式下，开启混合持久化机制生成的文件是“RDB头+AOF尾”，未开启时生成的文件全部为AOF格式。考虑两种文件格式的兼容性，如果Redis发现AOF文件为RDB头，会使用RDB数据加载的方法读取并恢复前半部分；然后再使用AOF方式读取并恢复后半部分。由于AOF格式存储的数据为RESP协议命令，Redis采用伪客户端执行命令的方式来恢复数据。

如果在AOF命令追加过程中发生宕机，由于延迟写的技术特点，AOF的RESP命令可能不完整（被截断）。遇到这种情况时，Redis会按照配置项`aof-load-truncated`执行不同的处理策略。这个配置是告诉Redis启动时读取aof文件，如果发现文件被截断（不完整）时该如何处理：

- yes：则尽可能多的加载数据，并以日志的方式通知用户；
- no：则以系统错误的方式崩溃，并禁止启动，需要用户修复文件后再重启。

## Redis为什么是单进程的？为什么快？

### 为什么是单进程的

官方FAQ：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。

> `注1`：这里我们一直在强调的单线程，只是在`处理我们的网络请求`的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！ 例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）
>
> `注2`：从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！以后的版本中是否还是单线程的方式需要考证！

#### 优势与劣势

 **优势：**

- 代码更清晰，处理逻辑更简单
- 不用考虑各种锁问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 不存在多进程或者多线程导致的切换而消耗CPU

**劣势：**

- 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善

### 为什么快

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
- 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
- 使用多路I/O复用模型，非阻塞IO
- 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求
