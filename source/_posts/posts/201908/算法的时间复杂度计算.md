title: 算法的时间复杂度计算
date: '2019-08-03 18:02:04'
updated: '2020-10-26 16:58:10'
tags: [算法]
permalink: /articles/2019/08/03/1564826524260.html
---
## 写在前面

   时间复杂度与空间复杂度直接决定着一个算法的好坏，而大多时候在设计算法是时间复杂度要优先于空间复杂度。

## 时间复杂度是什么(以下内容来着维基百科)

> 在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6 "计算机科学")中，[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95 "算法")的**时间复杂度**（Time complexity）是一个[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0 "函数")，它定性描述该算法的运行时间。这是一个代表算法输入值的[字符串](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2 "字符串")的长度的函数。时间复杂度常用[大O符号](https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7 "大O符号")表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是[渐近](https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%91%E5%88%86%E6%9E%90 "渐近分析")的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 *n* （必须比 *n0* 大）的输入，它至多需要 5*n*3 + 3*n* 的时间运行完毕，那么它的渐近时间复杂度是 O(*n*3)。<br/>
> 为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。<br/>
> 相同大小的不同输入值仍可能造成算法的运行时间不同，因此我们通常使用算法的最坏情况复杂度，记为 ***T*(*n*)** ，定义为任何大小的输入 *n* 所需的最大运行时间。另一种较少使用的方法是平均情况复杂度，通常有特别指定才会使用。时间复杂度可以用函数 *T*(*n*) 的自然特性加以分类，举例来说，有着 *T*(*n*) = *O*(*n*) 的算法被称作“线性时间算法”；而 *T*(*n*) = *O*(*M**n*) 和 *M**n*= O(*T*(*n*)) ，其中 *M* ≥ *n* > 1 的算法被称作“指数时间算法”。

## 常见算法时间复杂度

### 搜索

![image.png](https://cdn.jsdelivr.net/gh/inkdp/CDN@main/img/image-8ba9a3db.png)

### 排序

![image.png](https://cdn.jsdelivr.net/gh/inkdp/CDN@main/img/image-3a8afbfd.png)

### 数据结构

![image.png](https://cdn.jsdelivr.net/gh/inkdp/CDN@main/img/image-fc45c2ae.png)

### 堆

![image.png](https://cdn.jsdelivr.net/gh/inkdp/CDN@main/img/image-ed711758.png)

### 图

![image.png](https://cdn.jsdelivr.net/gh/inkdp/CDN@main/img/image-813479ac.png)

## 计算时间复杂度

**算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述**
1.在一个函数中，常数项对于函数的增长速度并不大，随意当T(n)=一个常数事，我们就可以说这个算法的时间复杂度为O(1)；

```
func main() {
   i := 1
   fmt.Println(i)
}
// 该函数总共两条执行语句，所以时间复杂度T(n) = 2，所以时间复杂度为O(1)
```

2.如果T(n)不等于一个常数项时，可直接将常数项省略

```
for i := 0; i < n; i++ {
	sum += i
}
sum += 1
sum += 2
sum += 3
此函数共执行了 n+3次，所以T(n) = n+3，时间复杂度为O(n)
```

3.对于有高次幂的，低次幂的影响可以说是微乎其微。比如n^3对于n^2,n^2对于n，由于时间复杂度要求不是特别高，所以低次幂直接忽略

```
for i := 0; i < n; i++ {

        for j := 0; j < n; j++ {

            for k := 0; k < n; k++ {
                // xxx
            }
        }
    }
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
                // xxx
        }
    }
上面函数的执行次数为n^3 + n^2，所以T(n) = n^3 + n^2, 时间复杂度为O(n^3)
```

4.因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。

```
比如
T(n) = 3n^3，此时时间复杂度为 O(n^3)。
```

**综合一下:只取最高次幂，最高次幂常数归1**

