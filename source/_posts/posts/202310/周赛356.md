---
title: 周赛356
toc_number: false
abbrlink: 25029
date: 2023-10-24 08:02:32
updated: 2023-10-24 08:02:32
tags:
  - Golang
  - leetcode
  - 周赛
categories:
  - - 技术
    - 算法
katex: true
cover: https://goohlan.fishpi.cn/img/202311010835081.png
keywords:'算法,LeetCode,周赛356'
description:
---

### 2798. 满足目标工作时长的员工数目

![image-20231024080330047](https://goohlan.fishpi.cn/img/202310240805952.png)

啊？怎么会有这么简单的题

```go
func numberOfEmployeesWhoMetTarget(hours []int, target int) (res int) {
    for _, hour := range hours {
        if hour >= target {
            res++
        }
    }
    return
}
```

### 2799. 统计完全子数组的数目

![image-20231024083813489](https://goohlan.fishpi.cn/img/202310240838529.png)

#### 暴力：

两次循环，判断每个子数组是否满足要求

```go
func countCompleteSubarrays(nums []int) (res int) {
    set := make(map[int]struct{})
    for _, num := range nums {
        set[num] = struct{}{}
    }
    l := len(set)
    
    for i := 0; i < len(nums); i++ {
        cnt := make(map[int]int)
        for _, x := range nums[i:] {
            cnt[x]++
            if len(cnt) == l {
                res++
            }
        }
    }
    return res
}
```



#### 滑动窗口：

找到符合条件的滑动窗口 $[left,right]$，此时 $right$ 右侧有 $k$ 个元素，那就有 $k+1(滑动窗口本身)$ 个滑动窗口满足条件

因为 $k=len(nums)-right-1$，此时就有 $len(nums)-right$ 个满足条件的滑动窗口

移动 $left$ 累加满足条件的滑动窗口个数，直到 $[left,right]$ 不满足条件

继续移动 $right$，找到下一个满足条件的 $[left,right]$

```go
func countCompleteSubarrays(nums []int) int {
    set := make(map[int]struct{})
    for _, num := range nums {
        set[num] = struct{}{}
    }
    l := len(set)
    
    cnt := make(map[int]int)
    left := 0
    res := 0
    for _, num := range nums {
        cnt[num]++
        for len(cnt) == l { // 满足条件,左端点向右移动
            x := nums[left]
            cnt[x]--
            if cnt[x] == 0 {
                delete(cnt, x)
            }
            left++
        }
        res += left
    }
    return res
}
```

### 2800. 包含三个字符串的最短字符串

![image-20231025082959905](https://goohlan.fishpi.cn/img/202310250829977.png)

#### 枚举：

枚举 $a,b,c$ 的全排列 $a',b',c'$，合并 $a',b'$ 得到最短字符串 $x$，再合并 $x,c'$ 得到最短字符 s。

合并 $a',b'$ 时，在没有完全包含的情况下， 相当于在 $b'$ 的左右两边分别添加一些字母，得到最短字符串 $s$。

取最短且字典序最小的 $s$ 作为答案。

```go

func merge(s, t string) string {
    // 先特判完全包含的情况
    if strings.Contains(s, t) {
        return s
    }
    if strings.Contains(t, s) {
        return t
    }
    for i := min(len(s), len(t)); ; i-- {
        // 枚举：s 的后 i 个字母和 t 的前 i 个字母是一样的
        x := s[len(s)-i:]
        y := t[:i]
        if x == y {
            return s + t[i:]
        }
    }
}

func minimumString(a string, b string, c string) (res string) {
    strList := []string{a, b, c}
    
    arr := [][]int{{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 1, 0}, {2, 0, 1}}
    for _, a := range arr {
        s := merge(merge(strList[a[0]], strList[a[1]]), strList[a[2]])
        if res == "" || len(s) < len(res) || len(s) == len(res) && s < res {
            res = s
        }
    }
    return
}
```

#### KMP:

合并字段是使用`KMP`的思路进行合并：

- 设 $p = t+"\#"+ s$，求出 $p$ 的公共子串
- $s$ 加上 $t$ 去掉公共子串就是最短字符串

```go
func mearge2(s, t string) string {
    if strings.Contains(s, t) {
        return s
    }
    if strings.Contains(t, s) {
        return t
    }
    
    p := t + "#" + s
    n := len(p)
    next := make([]int, n) // 通过next计算子串
    for i := 1; i < n; i++ {
        j := next[i-1]
        for j > 0 && p[i] != p[j] {
            j = next[j-1]
        }
        if p[i] == p[j] {
            j++
        }
        next[i] = j
    }
    
    // s+t去掉公共子串
    return s + t[next[n-1]:]
}

```

### 2801. 统计范围内的步进数字数目

![image-20231027143218816](https://goohlan.fishpi.cn/img/202310271432372.png)

#### 解题思路:

抄一下灵神的思路：原文见[数位 DP 通用模板](https://leetcode.cn/problems/count-stepping-numbers-in-range/solutions/2364624/shu-wei-dp-tong-yong-mo-ban-by-endlessch-h8fj/)

定义 $calc(n)$ 表示不超过 $n$ 的步进数字数目。那么答案就是

$$cacl(hight)-cacl(low-1)$$

$$=calc(hight)-cacl(low)+valid(low)$$

由于 $low$ 是个很大的数字，不方便减一，所以用 $valid(low)$ 表示：如果 $low$ 是步进数字，那么多减了 $1$，再加 $1$ 补回来。

如何计算 $calc(n)$ 呢？（下文用 $s$ 表示 $n$ 的字符串形式）

一种通用套路是，定义 $f(i, pre, isLimit, isNum)$ 表示构造第 $i$ 位及其以后数位的合法方案数，其中参数的含义为：
