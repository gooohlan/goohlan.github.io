---
title: 周赛356
toc_number: false
date: 2023-10-24 08:02:32
updated: 2023-10-24 08:02:32
tags:
  - Golang
  - leetcode
  - 周赛
categories:
  - - 技术
    - 算法
katex: true
cover: https://goohlan.fishpi.cn/img/202311010835081.png
keywords:'算法,LeetCode,周赛356'
description:
---

### 2798. 满足目标工作时长的员工数目

![image-20231024080330047](https://goohlan.fishpi.cn/img/202310240805952.png)

啊？怎么会有这么简单的题

```go
func numberOfEmployeesWhoMetTarget(hours []int, target int) (res int) {
    for _, hour := range hours {
        if hour >= target {
            res++
        }
    }
    return
}
```

### 2799. 统计完全子数组的数目

![image-20231024083813489](https://goohlan.fishpi.cn/img/202310240838529.png)

#### 暴力：

两次循环，判断每个子数组是否满足要求

```go
func countCompleteSubarrays(nums []int) (res int) {
    set := make(map[int]struct{})
    for _, num := range nums {
        set[num] = struct{}{}
    }
    l := len(set)
    
    for i := 0; i < len(nums); i++ {
        cnt := make(map[int]int)
        for _, x := range nums[i:] {
            cnt[x]++
            if len(cnt) == l {
                res++
            }
        }
    }
    return res
}
```



#### 滑动窗口：

找到符合条件的滑动窗口 $[left,right]$，此时 $right$ 右侧有 $k$ 个元素，那就有 $k+1(滑动窗口本身)$ 个滑动窗口满足条件

因为 $k=len(nums)-right-1$，此时就有 $len(nums)-right$ 个满足条件的滑动窗口

移动 $left$ 累加满足条件的滑动窗口个数，直到 $[left,right]$ 不满足条件

继续移动 $right$，找到下一个满足条件的 $[left,right]$

```go
func countCompleteSubarrays(nums []int) int {
    set := make(map[int]struct{})
    for _, num := range nums {
        set[num] = struct{}{}
    }
    l := len(set)
    
    cnt := make(map[int]int)
    left := 0
    res := 0
    for _, num := range nums {
        cnt[num]++
        for len(cnt) == l { // 满足条件,左端点向右移动
            x := nums[left]
            cnt[x]--
            if cnt[x] == 0 {
                delete(cnt, x)
            }
            left++
        }
        res += left
    }
    return res
}
```

### 2800. 包含三个字符串的最短字符串

![image-20231025082959905](https://goohlan.fishpi.cn/img/202310250829977.png)

#### 枚举：

枚举 $a,b,c$ 的全排列 $a',b',c'$，合并 $a',b'$ 得到最短字符串 $x$，再合并 $x,c'$ 得到最短字符 s。

合并 $a',b'$ 时，在没有完全包含的情况下， 相当于在 $b'$ 的左右两边分别添加一些字母，得到最短字符串 $s$。

取最短且字典序最小的 $s$ 作为答案。

```go

func merge(s, t string) string {
    // 先特判完全包含的情况
    if strings.Contains(s, t) {
        return s
    }
    if strings.Contains(t, s) {
        return t
    }
    for i := min(len(s), len(t)); ; i-- {
        // 枚举：s 的后 i 个字母和 t 的前 i 个字母是一样的
        x := s[len(s)-i:]
        y := t[:i]
        if x == y {
            return s + t[i:]
        }
    }
}

func minimumString(a string, b string, c string) (res string) {
    strList := []string{a, b, c}
    
    arr := [][]int{{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 1, 0}, {2, 0, 1}}
    for _, a := range arr {
        s := merge(merge(strList[a[0]], strList[a[1]]), strList[a[2]])
        if res == "" || len(s) < len(res) || len(s) == len(res) && s < res {
            res = s
        }
    }
    return
}
```

#### KMP:

2r93IUeVlikBHE50vVfntJ3TIao1UDWF

