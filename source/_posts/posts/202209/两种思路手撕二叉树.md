---
title: 两种思路手撕二叉树
toc_number: false
tags:
  - Golang
  - leetcode
  - 学习
  - 二叉树
categories:
  - - 技术
    - 算法
keywords: '算法,LeetCode,二叉树,二叉树的最大深度,填充每个节点的下一个右侧节点指针,二叉树的前序遍历,二叉树的后序遍历,翻转二叉树,二叉树的直径'
abbrlink: 14521
date: 2022-09-15 07:58:08
updated: 2022-09-15 07:58:08
cover:
description:
---

先在开头总结一下，二叉树解题的思维模式分两类：

> **1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。
>
> **2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。
>
> 无论使用哪种思维模式，你都需要思考：
>
> **如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

下文通过几道简单的题目，实践运用这几条总纲，理解「遍历」和「分解问题」的思维又和区别和联系

二叉树相关的题目，无非是在二叉树遍历时的前序/中序/后续位置做文章，当然这并不能包含所有的，但是大部分如此，万变不离其宗，因此我们可以定义出一个基础框架：

```go
func traverse(root *TreeNode){
    if root == nil {
        return
    }
    // 前序位置
    traverse(root.Left)
    // 中序位置
    traverse(root.Right)
    // 后序位置
}
```

先不管所以为的前中后序，单看`traverse`，他在做的无非就是把整个二叉树所有节点遍历一遍，本质上与你遍历数组和链表类似。

### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

![image-20220915081346242](https://cdn.inkdp.cn/img/20220915081346.png)

{% tabs 104 %}

<!-- tab 遍历 -->

**解题思路：**

{% note no-icon info simple %}

经典二叉树前序遍历，二叉树入门级题目，套入上文的框架，前序遍历则在前序位置将节点放入数组即可

{% endnote %}

**示例代码：**

```go
var list []int

func preorderTraversal(root *TreeNode) []int {
   preorder(root)
   return list
}

func preorder(node *TreeNode) {
   if node == nil {
      return
   }
   list = append(list, node.Val)
   preorder(node.Left)
   preorder(node.Right)
}
```

上述代码使用了`全局变量`，在`leetcode`提交时会有问题，稍微改造一下即可

```go
func preorderTraversal(root *TreeNode) []int {
   var list []int
   var preorder func(node *TreeNode)
   preorder = func(node *TreeNode) {
      if node == nil {
         return
      }
      list = append(list, node.Val)
      preorder(node.Left)
      preorder(node.Right)
   }
   preorder(root)
   return list
}
```

<!-- endtab -->

<!-- tab 分解问题 -->

**解题思路：**

{% note info no-icon simple%}

1111

{% endnote %}

<!-- endtab -->

{% endtabs %}
