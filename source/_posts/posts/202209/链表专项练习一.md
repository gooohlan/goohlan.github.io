---
title: 链表专项练习一
toc_number: false
tags:
  - Golang
  - leetcode
  - 学习
  - 链表
categories:
  - - 技术
    - 算法
keywords: '算法,LeetCode,数组,Golang,链表'
cover: 'https://cdn.inkdp.cn/img/20220906001312.jpg'
abbrlink: 13378
date: 2022-09-05 23:53:43
updated: 2022-09-07 22:49:43
description:
---

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

![image-20220905235445328](https://cdn.inkdp.cn/img/20220905235445.png)

#### 解题思路：

{% note no-icon info simple %}

同时循环两个链表，去除较小的一个只放入新链表，直到其中一个节点为`nil`

{% endnote %}

#### 示例代码：

```go
// 分别取出两个链表的当前值比较,较小的赋值给新链表
// 初始化时需要声明一个虚拟节点,避免空指针
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
   head := &ListNode{}
   pre := head
   for list1 != nil && list2 != nil {
      // 比较两个节点的值, 将较小的节点放到pre指针
      if list1.Val < list2.Val {
         pre.Next = list1
         list1 = list1.Next
      } else {
         pre.Next = list2
         list2 = list2.Next
      }
      pre = pre.Next
   }

   if list1 != nil {
      pre.Next = list1
   }

   if list2 != nil {
      pre.Next = list2
   }
   return head.Next
}
```

### [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

![image-20220907222209208](https://cdn.inkdp.cn/img/20220907222209.png)

{% tabs 23 %}

<!-- tab 分治法 -->

#### 解题思路：

{% note no-icon info simple %}

简单粗暴，从第一个往后一依次合并

**进阶：**使用递归合并

{% endnote %}

#### 示例代码：

```go
func mergeKLists1(lists []*ListNode) *ListNode {
   pre := &ListNode{}
   cur := &ListNode{}
   if len(lists) == 0 {
      return nil
   }
   pre = lists[0]
   for i := 1; i < len(lists); i++ {
      cur = lists[i]
      pre = mergeTwoLists(pre, cur) // 21题函数
   }
   return pre
}
```

<!-- endtab -->

<!-- tab 最小堆 -->

#### 解题思路：

{% note no-icon info simple %}

此题关键难点在于，如何快速从`K`个链表中找出最小节点

这里我们使用[优先级队列（二叉堆）](https://labuladong.github.io/algo/2/23/65/) 这种数据结构，构建一个[最小堆](https://www.cnblogs.com/ganshuoos/p/14199368.html)，把所有链表节点放入其中，然后每次取出最小节点加入新链表即可。

注意：取出节点后需要将下一个节点放入最小堆中

{% endnote %}

#### 示例代码：

```go
// 使用最小堆存储所有链表头结点节点
// 遍历最小堆,取出最小节点添加到新链表,同时将取出节点下一个节点放入最小堆中
func mergeKLists(lists []*ListNode) *ListNode {
   h := new(minHeap)
   // 将所有链表的头结点放入最小堆
   for _, list := range lists {
      if list != nil {
         heap.Push(h, list)
      }
   }

   head := &ListNode{}
   pre := head
   for h.Len() > 0 {
      // 取出最小节点
      node := heap.Pop(h).(*ListNode)
      if node.Next != nil {
         // 将最小节点下一节点加入最小堆
         heap.Push(h, node.Next)
      }
      // 最小节点放入链表
      pre.Next = node
      pre = pre.Next
   }
   return head.Next
}
```

<!-- endtab -->

{% endtabs %}


### [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

![image-20220906221020843](https://cdn.inkdp.cn/img/20220906221020.png)

#### 解题思路：

{% note no-icon info simple %}

遍历原链表，根据需求把链表分成两个小链表，一个链表所有元素小于`x`，另一个链表所有元素大于等于`x`，最后把两个链表连接到一起就可以了。

{% endnote %}

#### 示例代码：

```go
func partition(head *ListNode, x int) *ListNode {
   head1 := &ListNode{} // 存放小于x的链表
   head2 := &ListNode{} // 存放大于等于x的链表
   p1, p2 := head1, head2
   for head != nil {
      if head.Val < x {
         p1.Next = head
         p1 = p1.Next
      } else {
         p2.Next = head
         p2 = p2.Next
      }
      head = head.Next
   }
   p2.Next = nil
   // 连接两个链表
   p1.Next = head2.Next
   return head1.Next
}
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

#### 解题思路：

{% note no-icon info simple %}

假设链表有`n`个节点,那么倒数第`k`个节点,就是正数第`n-k+1`个节点

遍历一次链表,获取链表长度`n`,再重新遍历一次找到第`n-k+1`个节点即可

能不能遍历一次就搞定呢

首先我们定义一个指针`p1`,`p1`先走`k`步,那么他还需要走`n-k`步即可到达尾部

此时我们再申明一个指针`p2`,指向头部, `p1`和`p2`同时前进,当`p1`到达尾部时,`p1`正好走了`n-k`步,在`n-k+1`个节点上,就是倒数第k个节点

为了方便删除操作,申明`p2`时申明一个前置节点,按照上述步骤,`p1`到达末尾, `p2`到达倒数第`n`个节点的前置节点, 直接删除`p2`下一个节点即可

{% endnote %}

#### 示例代码：

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
   p := &ListNode{0, head}
   p1, p2 := head, p
   for i := 0; i < n; i++ {
      p1 = p1.Next
   }

   for p1 != nil {
      p1 = p1.Next
      p2 = p2.Next
   }
   p2.Next = p2.Next.Next
   return p.Next
}
```

### 参考链接：

- [双指针技巧秒杀七道链表题目](https://labuladong.github.io/algo/1/4/)
