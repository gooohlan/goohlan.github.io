---
title: 周赛350
toc_number: false
abbrlink: 25413
date: 2023-07-03 07:35:49
updated: 2023-07-03 07:35:49
tags:
categories:
cover:
keywords:
description:
---

### 2739. 总行驶距离

![image-20230703073648441](https://cdn.gooohlan.cn/img/202307030736479.png)

####  解题思路：

根据题意，每消耗5升，就会补充1升，那就相当于每次只消耗4升，可以补充的燃油就等于 $mainTank/4$ 

假设 $mainTank$ 正好是4的倍数，最后一次是得不到补充的，所以实际上补充的燃油应该是 $(mainTank-1)/4$

这里额外补充的燃油不可以超过副油箱的总量

#### 示例代码：

```go
func distanceTraveled(mainTank int, additionalTank int) int {
    return (min((mainTank-1)/4, additionalTank) + mainTank) * 10
}
func min(a, b int) int {if a < b {return a}; return b}
```

### 2740. 找出分区值

![image-20230703075008448](https://cdn.gooohlan.cn/img/202307030750472.png)

#### 解题思路：

将数组排序，最小值必然是两个相邻元素的差，假设其分别为 $nums[i-1]$ 和 $ nums[i] $，以这两个数为界限，即可满足题意。

#### 示例代码：

```go
func findValueOfPartition(nums []int) int {
    sort.Ints(nums)
    res := math.MaxInt
    for i := 1; i < len(nums); i++ {
        res = min(res, nums[i]-nums[i-1])
    }
    return res
}

func min(a, b int) int { if a < b { return a }; return b }
```

### 2741. 特别的排列

![image-20230703075947383](https://cdn.gooohlan.cn/img/202307030759409.png)

#### 解题思路：

**前置知识：[从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/circle/discuss/CaOJ45/)**

一眼动态规划，定义 $dfs(i, j)$ 表示当前集合为 $i$，上一次选择的数下标是 $j$ 时，可以构造除特别排列的个数

枚举当前要选择的下标 $k$， 如果 $nums[k]$ 与 $nums[j]$ 满足整除的要求，则
$$
dfs(i,j) = \sum_{k \in i} dfs(i\backslash \left\{ k \right\}, k)
$$

其中 $i\backslash \left\{ k \right\}$ 表示从集合 $i$ 中移除 $k$

当 $i$ 为0时，集合已经使用完，表示找到一个特别的排列

设全集 $U=\left\{0,1,2,...,n-1\right\}$，枚举每一个下标 $j$，求特别列第一个数下标为 $j$ 的特别列个数 $dfs(U\backslash \left\{ j \right\}, j)$，并求和即为答案

#### 示例代码：

```go
func specialPerm(nums []int) int {
    const mod int = 1e9 + 7
    n := len(nums)
    m := 1 << n
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }
    
    var dfs func(int, int) int
    dfs = func(i int, j int) (res int) {
        if i == 0 {
            return 1
        }
        
        if memo[i][j] != -1 {
            return memo[i][j]
        }
        
        for k, x := range nums {
            if i>>k&1 == 1 && (nums[j]%x == 0 || x%nums[j] == 0) {
                res = (res + dfs(i^(1<<k), k)) % mod
            }
        }
        memo[i][j] = res
        return res
    }
    var res int
    for i := range nums {
        res = (res + dfs((m-1)^(1<<i), i)) % mod
    }
    return res
}
```

