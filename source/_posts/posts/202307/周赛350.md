---
title: 周赛350
toc_number: false
abbrlink: 25413
date: 2023-07-03 07:35:49
updated: 2023-07-03 07:35:49
tags:
categories:
cover:
keywords:
description:
---

### 2739. 总行驶距离

![image-20230703073648441](https://cdn.gooohlan.cn/img/202307030736479.png)

####  解题思路：

根据题意，每消耗5升，就会补充1升，那就相当于每次只消耗4升，可以补充的燃油就等于 $mainTank/4$ 

假设 $mainTank$ 正好是4的倍数，最后一次是得不到补充的，所以实际上补充的燃油应该是 $(mainTank-1)/4$

这里额外补充的燃油不可以超过副油箱的总量

#### 示例代码：

```go
func distanceTraveled(mainTank int, additionalTank int) int {
    return (min((mainTank-1)/4, additionalTank) + mainTank) * 10
}
func min(a, b int) int {if a < b {return a}; return b}
```

### 2740. 找出分区值

![image-20230703075008448](https://cdn.gooohlan.cn/img/202307030750472.png)

#### 解题思路：

将数组排序，最小值必然是两个相邻元素的差，假设其分别为 $nums[i-1]$ 和 $ nums[i] $，以这两个数为界限，即可满足题意。

#### 示例代码：

```go
func findValueOfPartition(nums []int) int {
    sort.Ints(nums)
    res := math.MaxInt
    for i := 1; i < len(nums); i++ {
        res = min(res, nums[i]-nums[i-1])
    }
    return res
}

func min(a, b int) int { if a < b { return a }; return b }
```

### 2741. 特别的排列

![image-20230703075947383](https://cdn.gooohlan.cn/img/202307030759409.png)

#### 解题思路(回溯)：

使用回溯的思路，定义 $dfs(track, j)$，其中 $track$ 为数组，存储已选择下标，$j$ 表示上一次选择的下标。同时使用全局 $used$ 标记是否选择过。

当数组 $tarck$  长度等于 $nums$ 的长度时，表示找到一个特别的排列，直接返回。

枚举当前要选择的下标 $k$， 如果 $nums[k]$ 与 $nums[j]$ 满足整除的要求，将 $k$ 加入 $track$ 数组中并标记 $used$ 为已使用，并进行回溯，结束回溯从 $track$ 中取出 $k$ 并重置 $used$ 中 $k$ 的状态

枚举 $nums$ 中的每一个元素，求和

#### 示例代码：

```go
func specialPerm(nums []int) int {
    const mod int = 10e9 + 7
    used := make(map[int]bool)
    var dfs func(track []int, j int) int
    
    dfs = func(track []int, j int) (res int) {
        if len(track) == len(nums) {
            return 1
        }
        
        for k, x := range nums {
            if !used[k] && (nums[j]%x != 0 || x%nums[j] != 0) {
                track = append(track, x)
                used[k] = true
                res = (res + dfs(track, k)) % mod
                used[k] = false
                track = track[:len(track)-1]
            }
        }
        return res
    }
    var res int
    for i, num := range nums {
        used[i] = true
        res = (res + dfs([]int{num}, i)) % mod
        used[i] = false
    }
    return res
}
```

这样写下来代码阅读性很高，但是有个致命缺点，因为 $track$ 中的值是无序的，做剪枝很麻烦(使用下面的集合可以进行剪枝)，时间复杂度为 $n!$ 会超时

#### 解题思路(回溯-位运算)

**前置知识：[从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/circle/discuss/CaOJ45/)**

一眼动态规划，定义 $dfs(i, j)$ 表示当前集合为 $i$，上一次选择的数下标是 $j$ 时，可以构造除特别排列的个数

枚举当前要选择的下标 $k$， 如果 $nums[k]$ 与 $nums[j]$ 满足整除的要求，则
$$
dfs(i,j) = \sum_{k \in i} dfs(i\backslash \left\{ k \right\}, k)
$$

其中 $i\backslash \left\{ k \right\}$ 表示从集合 $i$ 中移除 $k$

当 $i$ 为0时，集合已经使用完，表示找到一个特别的排列

设全集 $U=\left\{0,1,2,...,n-1\right\}$，枚举每一个下标 $j$，求特别列第一个数下标为 $j$ 的特别列个数 $dfs(U\backslash \left\{ j \right\}, j)$，并求和即为答案

#### 示例代码：

```go
func specialPerm(nums []int) int {
    const mod int = 1e9 + 7
    n := len(nums)
    m := 1 << n - 1
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }
    
    var dfs func(int, int) int
    dfs = func(i int, j int) (res int) {
        if i == 0 {
            return 1
        }
        
        if memo[i][j] != -1 {
            return memo[i][j]
        }
        
        for k, x := range nums {
            if i>>k&1 == 1 && (nums[j]%x == 0 || x%nums[j] == 0) {
                res = (res + dfs(i^(1<<k), k)) % mod
            }
        }
        memo[i][j] = res
        return res
    }
    var res int
    for i := range nums {
        res = (res + dfs(m^(1<<i), i)) % mod
    }
    return res
}
```

