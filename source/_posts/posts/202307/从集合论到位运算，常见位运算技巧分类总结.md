---
title: 从集合论到位运算，常见位运算技巧分类总结
toc_number: false
abbrlink: 7087
date: 2023-07-14 08:20:14
updated: 2023-07-14 08:20:14
tags:
categories:
cover:
keywords:
description:
katex: true
---

{% note primary modern %}

本文非原创，转载自[灵茶山艾府](https://leetcode.cn/u/endlesscheng/)，具体出处见文章底部

{% endnote %}

### 前言

本文将扫清位运算的迷雾，在集合论与位运算之间建立一座桥梁。

在高中，我们学了集合论（set theory）的相关知识。例如，包含若干帧数的集合 $S=\left\{ 0,2,3 \right\}$。在编程中，通常用哈希表（hash table）实现集合，例如 Java 中的 `HashSet`，Golang 中的 `map`。

在集合论中，有交集 $ \cap$、并集 $\cup$、包含于 $\subseteq$ 等等概念。如何编程实现「求两个哈希表的交集」，需要一个个遍地遍历哈希表中的元素。有没有更高效的做法呢？

该二进制上场了。

集合可以用二进制表示，二进制**从低到高**第 $i$ 位为 1 表示 $i$ 在集合中，为 0 表示 $i$ 不在集合中。例如集合 $\left\{ 0,2,3 \right\}$ 可以用二进制数 1101 表示；反过来，二进制数 1101 就对应集合 $\left\{ 0,2,3 \right\}$。

正式地说，包含非负整数的集合 $S$ 可以用如下方式「压缩」成一个数字：

$$f(S) =\sum_{i\in S} 2^i $$

上面举例的 ${0,2,3}$ 可以压缩成 $2^0+2^2+2^3=13$，也就是二进制数 1101。

利用位运算「并行运算」的特点，我们可以高效地做一些和集合相关的运算，按照常见的应用场景，可以分为以下四类：

1. 集合与集合
2. 集合与元素
3. 遍历集合
4. 枚举集合

### 一、集合与集合

其中 $\&$ 表示按位与，$|$ 表示安慰或，$\oplus$  表示按位异或，$ ∼ $ 表示按位取反。

其中「对称差」指仅在其中一个集合的元素。

| **术语**   | **集合**                        | **位运算**                   | **举例**                                                     | **二进制**                                 |
| ---------- | ------------------------------- | ---------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| 交集       | $A \cap B$                      | $a \& b$                     | $\left\{ 0,2,3 \right\} \cap \left\{ 0,1,2 \right\} = \left\{ 0,2 \right\}$ | $1101 \& 0111 = 0101$                      |
| 并集       | $A \cup B$                      | $a | b$                      | $\left\{ 0,2,3 \right\} \cup \left\{ 0,1,2 \right\} = \left\{ 0,1,2,3 \right\}$ | $1101 | 0111 = 1111$                       |
| 对称差     | $A\triangle B$                  | $a \oplus b$                 | $\left\{ 0,2,3 \right\} \triangle \left\{ 0,1,2 \right\} = \left\{ 1,3 \right\}$ | $1101\oplus0111 = 1010$                    |
| 差         | $A \backslash B$                | $a\& \sim b$                 | $\left\{ 0,2,3 \right\} \backslash \left\{ 1,2 \right\} = \left\{ 0,3 \right\}$ | $1101 \& 1001 = 1001$                      |
| 差（子集） | $A \backslash B(B \subseteq A)$ | $a \oplus b$                 | $\left\{ 0,2,3 \right\} \backslash \left\{ 0,2 \right\} = \left\{ 3 \right\}$ | $1101 \oplus 0101 = 1000$                  |
| 包含于     | $A \subseteq B$                 | $a \& b = a$<br>$a \& b = a$ | $\left\{ 0,2 \right\} \subseteq \left\{ 0,2,3 \right\}$      | $0101 \&1101=0101$<br>$0101 | 1101 = 1101$ |

> 注1：按位取反的例子中，仅列出最低 4 个比特位取反的结果，即 0110 取反后是 1001。
>
> 注2：包含于的两周运算写法是等价的，再编程时只需要判断其中任意一种。
>
> 注3：编程时，请注意运算符的优先级。例如 `==` 再某些语言中优先级跟高。

### 二、集合与元素

通常会用到位移计算

其中 `<<` 表示左移，`>>` 表示右移。

> 注：左移 $i$ 位相当于成 $2^i$，右移 $i$ 位相当于除以 $2^i$

| **术语**                 | **集合**                               | **位运算**                              | **举例**                                               | **二进制**             |
| ------------------------ | -------------------------------------- | --------------------------------------- | ------------------------------------------------------ | ---------------------- |
| 空集                     | $\emptyset$                            | 0                                       |                                                        |                        |
| 单元素合集               | $\left\{ i \right\}$                   | $1 << i$                                | $\left\{ 2 \right\}$                                   | $1<<2$                 |
| 全集                     | $U=\left\{ 0,1,2,...n-1 \right\}$      | $(1 << n)-1$                            | $\left\{ 0,1,2,3 \right\}$                             | $(1<<4)-1$             |
| 补集                     | $\complement_U S = U \backslash S$     | $\sim S$ 或者 $((1 << n) - 1) \oplus s$ |                                                        |                        |
| 属于                     | $i \in S$                              | $(s >> i)\& 1 =1$                       | $2 \in \left\{ 0,2,3 \right\}$                         | $(1101 >> 2) \& 1 = 1$ |
| 不属于                   | $i \notin S$                           | $(s >> i) \& 1 = 0$                     | $1 \notin \left\{ 0,2,3 \right\}$                      | $(1101 >> 2) \& 1 = 0$ |
| 添加元素                 | $S \cup \left\{ i \right\}$            | $s | (1 << i)$                          | $\left\{ 0,3 \right\} \cup \left\{2 \right\} $         | $1001 | (1 << 2)$      |
| 删除元素                 | $S \backslash \left\{ i \right\}$      | $s\&\sim(1 << i)$                       | $\left\{ 0,2,3 \right\} \backslash \left\{2 \right\} $ | $1101 \& \sim (1<<2)$  |
| 删除元素（一定在集合中） | $S\backslash\left\{i\right\}(i \in S)$ | $s\oplus(1 << i)$                       | $\left\{ 0,2,3 \right\} \backslash \left\{2 \right\} $ | $1101 \oplus(1 << 2)$  |
| 删除最小元素             |                                        | $s\&(s-1)$                              |                                                        | 见下                   |

```go
      s = 101100
    s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1
s&(s-1) = 101000
```

此外，某些数字可以借助标准库的函数算出：

| **术语**                               | **Python**      | **Java**              | **C++**                | **Go**              |
| -------------------------------------- | --------------- | --------------------- | ---------------------- | ------------------- |
| 集合大小（元素个数）                   | `s.bit_count()` | `Integer.bitcount(s)` | `__builtin_popount(s)` | `bits.OnesCount(s)` |
| 二进制长度（减一得到集合中的最大元素） | `s.bit_`        |                       |                        |                     |
|                                        |                 |                       |                        |                     |

 
