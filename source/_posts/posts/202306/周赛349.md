---
title: 周赛349
toc_number: false
date: 2023-06-26 07:40:49
updated: 2023-06-26 07:40:49
tags:
  - Golang
  - leetcode
  - 周赛
categories:
  - - 技术
    - 算法
keywords: '算法,LeetCode,周赛349'
cover:
description:
---

### 2733. 既不是最小值也不是最大值

![image-20230626074635610](https://cdn.gooohlan.cn/img/202306260746633.png)

#### 解题思路：

{% note no-icon info simple %}

根据题意，只需要取出3个数，求中间那个即可，操作最简单的就是，取前3个数排序之后的中间那个数

{% endnote %}

#### 示例代码：

```go
func findNonMinOrMax(nums []int) int {
    if len(nums) < 3 {
        return -1
    }
    sort.Ints(nums[:3])
    return nums[1]
}
```

### 2734. 执行子串操作后的字典序最小字符串

![image-20230626075614098](https://cdn.gooohlan.cn/img/202306260756135.png)

#### 解题思路:

{% note no-icon info simple %}

字符`a`变`z`不会让字典序变小，操作的子串中不能包含`a`，替换其余字符串即可

从左到右遍历，找到第一个不为`a`的字符，向后继续遍历，每个字符减一，直到到了字符串末尾或者遇到了`a`

上述思路如果遇到全部为`a`的字符串会一次都不执行，题目要求必须要操作一次，所以我们把最后一个字符串变成`z`即可满足题意

{% endnote %}

#### 示例代码：

```go
func smallestString(s string) string {
    b := []byte(s)
    for i, char := range(b) {
        if char != 'a' {
            for j := i; j < len(s) && b[j] != 'a';j++ {
                b[j]--
            }
            return string(b)
        }
    }
    b[len(b)-1] = 'z'
    return string(b)
}
```

### 2735. 收集巧克力

![image-20230626080820640](https://cdn.gooohlan.cn/img/202306260808669.png)

#### 解题思路:

{% note no-icon info simple %}

如果不操作，第`i`个巧克力必须花费`nums[i]`收集，总成本为所有`nums[i]`之和

如果操作一次，那么第`i`个巧克力话费`min(nums[i], nums[i+1]%n)`收集，**在求和状态下，向左移或者想右移结果一致**。

如果操作两次，那么第`i`个巧克力话费`min(nums[i], nums[i+1]%n, nums[i+2]%n)`收集，以此类推

定义`cost`数组，`cost[i]`表示操作`k`次，取到类型为`i`的巧克力最小花费。操作`k`次，总花费就等于`cost`数组之和，再加上`k * x`

{% endnote %}

#### 示例代码：

```go
func minCost(nums []int, x int) int64 {
    n := len(nums)
    res := math.MaxInt
    cost := make([]int, n)
    for i := 0; i < n; i++ {
        cost[i] = nums[i]
    }

    for i := 0; i < n; i++ { // 执行几次操作
        curCost := 0 // 执行i次操作的花费
        for j := 0; j < n; j++ {  // 更新每个位置巧克力能够取到的最小花费
            cost[j] = min(cost[j], nums[(j+i)%n])
            curCost += cost[j]
        }
        res = min(res, curCost + i * x)
    }
    return int64(res)
}
func min(a, b int) int { if b < a { return b }; return a }

```

