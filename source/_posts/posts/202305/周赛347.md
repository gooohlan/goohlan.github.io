---
title: 周赛347
toc_number: false
tags:
  - Golang
  - leetcode
  - 周赛
categories:
  - - 技术
    - 算法
keywords: '算法,LeetCode,周赛347'
abbrlink: 12549
date: 2023-05-30 08:45:23
updated: 2023-05-30 08:45:23
cover:
description:
---

### 2710. 移除字符串中的尾随零

![image-20230530090649271](https://cdn.gooohlan.cn/img/202305300906292.png)

#### 示例代码：

```go
func removeTrailingZeros(num string) string {
    b := []byte(num)
    i := len(b)
    for ; i > 0 && num[i] == '0'; i-- {
    }
    return string(b[:i+1])
    
    // return strings.TrimRight(num, "0") // 库函数写法
}
```

### 2711. 对角线上不同值的数量差

![image-20230602182827762](https://cdn.gooohlan.cn/img/202306021828934.png)

{% tabs 705 %}

<!-- tab 暴力 -->

#### 解题思路

{% note no-icon info simple %}

枚举每个位置，往左上和右下遍历，用哈希表统计不同元素个数

{% endnote %}

#### 示例代码

```go
func differenceOfDistinctValues(grid [][]int) [][]int {
    m, n := len(grid), len(grid[0])
    ans := make([][]int, m)
    
    for i := range ans {
        ans[i] = make([]int, n)
        for j := range ans[i] {
            // 左上
            set := map[int]struct{}{}
            for x, y := i-1, j-1; x >= 0 && y >= 0; {
                set[grid[x][y]] = struct{}{}
                x--
                y--
            }
            sz := len(set)
            
            // 右下
            set = map[int]struct{}{}
            for x, y := i+1, j+1; x < m && y < n; {
                set[grid[x][y]] = struct{}{}
                x++
                y++
            }
            ans[i][j] = abs(sz, len(set))
        }
    }
    return ans
}

func abs(a, b int) int {
    if a < b {
        return b - a
    }
    return a - b
}
```

<!-- endtab -->

<!-- tab 前后缀分解 -->

#### 解题思路

{% note no-icon info simple %}

从第一行和第一列的每个位置出发，向右下遍历，这一条线为`s`，`s`范围为`[1, m+n-1]`，`m`为行数，`n`为列数。从最后一行和最后一列出发去遍历，第一列从上到下。

横纵坐标分别为`i,j`，根据每一条线纵坐标的范围，`minJ := max(0, n-s)`，`maxJ := min(n-1, n-s+m-1)`，因为在一条只显示，所以`i-j`的值是固定的，为`s-n`，`i := s + j - n`，有了横纵坐标，就可以一次遍历求出所有的结果

具体讲解见: https://www.bilibili.com/video/BV1fo4y1T7MQ?t=630.2

{% endnote %}

#### 示例代码

```go
func differenceOfDistinctValues(grid [][]int) [][]int {
    m, n := len(grid), len(grid[0])
    ans := make([][]int, m)
    for i := range ans {
        ans[i] = make([]int, n)
    }
    for s := 1; s < m+n; s++ {
        minJ := max(0, n-s)
        maxJ := min(n-1, n-s+m-1)
        
        // topLeft
        set := map[int]struct{}{}
        for j := minJ; j < maxJ; j++ {
            i := s + j - n
            set[grid[i][j]] = struct{}{}
            ans[i+1][j+1] = len(set) // 左上个数
        }
        
        // bottomRight
        set = map[int]struct{}{}
        for j := maxJ; j > minJ; j-- {
            i := s + j - n
            set[grid[i][j]] = struct{}{}
            ans[i-1][j-1] = abs(ans[i-1][j-1], len(set)) // ans[i-1][j-1]为左上个数, len(set)为右下个数,这里直接求解了
        }
    }
    return ans
}
```

<!-- endtab -->

{% endtabs %}

### 2712. 使所有字符相等的最小成本

![image-20230602191250241](https://cdn.gooohlan.cn/img/202306021912316.png)

#### 解题思路

{% note no-icon info simple %}

没有一对相邻的`0-1`队都需要翻转一次，因为翻转一次只能修复一个，对后续的没有影响，比如，`010101`，翻转第一次后为`110101`，还需要翻转4次，所以遇到相邻不相同就翻转即可，每次翻转时选择短的那半段

{% endnote %}

#### 示例代码

```go
func minimumCost(s string) int64 {
    n := len(s)
    var sum int64
    for i := 1; i < n; i++ {
        if s[i] != s[i-1] {
            sum += min(i, n-i)
        }
    }
    return sum
}
```

